---
layout: documentation
title:  کلاس های Abstract (انتزاعی)
cattitle: آموزش شی گرایی در php
date:   2017-11-02 19:42:42 +0330
jdate: پنج شنبه 11 آبان 1396
caturl: 2017/11/01/object-oriented-programming-in-php.html
# permalink: /:categories/:title.html
thumbnail: phpOOPTutorialPAGE.png
refrence: http://haamid.ir/کلاسهای-abstract-یا-انتزاعی-در-php/ <br> http://alihossein.ir/tutorials/آموزش-کلاس-های-abstract <br> http://python.coderz.ir/lessons/l05.html
---
<h3>مفهوم Abstract  (انتزاع)</h3>

<p>
انتزاع در لغت به معنای جدا کردن، گرفتن، درآوردن جزئی از یک کل  می باشد.
</p>

<p>
تجرید در برنامه‌نویسی شی‌گرا به همراه مفهوم چندریختی می‌آید و توسط دو مفهوم «کلاس‌های مجرد» (Abstract Classes) و «متدهای مجرد» (Abstract Methods) ارایه می‌گردد.
</p>

<p>
«کلاس مجرد» کلاسی است که شامل یک یا چند «متد مجرد» باشد و «متد مجرد» متدی است که اعلان (Declare) شده ولی بدنه آن ‌تعریف (Define) نشده است. کلاس‌های مجرد قابلیت نمونه‌سازی ندارند و نمی‌توان از آن‌ها شی ایجاد نمود؛ چرا که هدف از توسعه آن‌ها قرار گرفتن در بالاترین سطح (یا چند سطح بالایی) درخت وراثت، به عنوان کلاس پایه برای ارث‌بری کلاس‌های پایین‌تر می‌باشد. ایده طراحی کلاس مجرد در تعیین یک نقشه توسعه برای کلاس‌های فرزند آن است؛ تعیین صفات و متدهای لازم ولی واگذاردن تعریف متدها بر عهده کلاس‌های فرزند.
</p>

<p>
به عنوان نمونه سه کلاس «ماهی»، «گربه» و «کبوتر» را در نظر بگیرید. این کلاس‌ها جدا از رفتارهای خاص خود (مانند: «پرواز کردن» در کبوتر یا «شنا کردن» در ماهی)، در یک سری رفتار به مانند «نفس کشیدن»، «غذا خوردن» و... مشترک هستند. راه درستِ توسعه این کلاس‌ها تعیین یک «کلاس پایه» برای رفتارهای مشترک و ارث‌بری هر سه آن‌ها می‌باشد. ولی از آنجا که هر یک، این رفتارهای مشترک را به گونه‌ای دیگر انجام می‌دهد؛ راه درست‌تر آن است که یک «کلاس مجرد» به عنوان «کلاس پایه» آن‌ها در نظر بگیریم؛ در این حالت هر کدام از کلاس‌ها ضمن دانستن رفتارهای لازم می‌تواند آن‌‌ها را متناسب با خواست خود تعریف نماید.
</p>



<h3> کلاس های Abstract (انتزاعی)</h3>
<p>توجه کنید که کلاس هایی که از نوع abstract تعریف بشن ، نمیشه ازشون شی ای ساخت و تنها می توان از آنها مشتق گرفت.
</p>
<p>
یکی از مزایای کلاس abstract این است که می توان در داخل آنها تابع هایی (متد) تعریف کرد که بدنه نداشته باشن.برای این منظور باید نوع اون تابع هم abstract باشد و  زمانی که که یک کلاس از کلاس abstract مشتق بشه اون توابع رو باید پیاده کنه یعنی بدنه ی اون تابع رو تکمیل کند.
</p>
<p>پس در داخل کلاس هایی از نوع abstract هم میتوان تابع های معمولی نوشت هم تابع هایی از نوع abstract که بدنه نداشته باشن.
</p>

<p>کاربرد دیگه ی کلاسهای abstract این هست که شما با این نوع کلاسها میتونید نویسنده های کلاسهای فرزند رو وادار کنید که برخی توابع رو بازنویسی کنند( در ادامه بیشتر متوجه این موضوع میشید).</p>


<h3>نحوه ی تعریف یک کلاس abstract</h3>

<p>
برای تعریف یک کلاس انتزاعی از کلمه کلیدی abstract  قبل از class  استفاده میکنیم :
</p>
<pre><code class="language-php  line-numbers">abstract class Animal
{
    public $name;
    public $age;

    public function Describe()
    {
        return $this->name . ", " . $this->age . " years old";
    }

    abstract public function Greet();
}
</code></pre>

<p>
الان اگه شما از کلاس بالا نمونه بگیرید با اررور مواجه میشید. طبیعی هم هست دیگه 🙂
</p>

<p>
یادتون باشه درون کلاس abstractتون میتونید متد هایی رو تعریف کنید و از اونها استفاده کنید و اون متد ها میتونن abstract باشن یا نه…
</p>
<p>
اگه متدی رو از نوع abstract تعریف کردید ، توسعه دهنده های دیگه رو مجبور میکنید : در صورتی که از کلاس شما کلاسی رو به ارث بردن ، حتما نابع رو دوباره بنویسن. مثلا هر کلاسی که از کلاس بالا مشتق بشه ، باید متد Greet رو دوباره بنویسه.</p>

<p>
کلاس زیر از کلاس بالا مشتق شده :
</p>

<pre><code class="language-php  line-numbers">class Dog extends Animal
{
    public function Greet()
    {
        return "Woof!";
    }

    public function Describe()
    {
        return parent::Describe() . ", and I'm a dog!";
    }
}
</code></pre>


<p>
همونطور که میبینید ما مجبور بودیم که متد  ()Greet  رو بازنویسی کنیم. حالا میتونیم از کلاس Dog بصورت زیر نمونه بگیریم :
</p>

<pre><code class="language-php  line-numbers">$animal = new Dog();
$animal->name = "Bob";
$animal->age = 7;
echo $animal->Describe();
echo $animal->Greet();
</code></pre>
<br>
<hr>
<p>
به عنوان مثال دیگر اگر بخواهیم چندین کلاس مختلف برای کار با دیتابیس های مختلف در برنامه تعریف کنیم که در آن برخی کارها یکسان می باشد؛ میتوانیم یک کلاس abstract برای تعریف اولیه و توابع یکسان آنها تعریف کنیم و سپس به نسبت هر دیتابیس توابع مخصوص آن را فراخوانی کرد
</p>

<pre><code class="language-php  line-numbers"><?php
abstract class Base_DB{
    private $id;
    abstract function update($data,$id);
    abstract function insert($data);
    function save($data){
        if(is_null($this->id)){
            $this->insert($data);
        }else{
            $this->update($data,$this->id);
        }
    }
}
class MySQL_DB extends Base_DB{
    function update($data,$id)
    {
        // کدهای مربوط به ویرایش
    }
    function insert($data)
    {
        // کدهای مربوط به درج کردن
    }
}
class Oracle_DB extends Base_DB{
    function update($data,$id)
    {
        // کدهای مربوط به ویرایش
    }
    function insert($data)
    {
        // کدهای مربوط به درج کردن
    }
}
</code></pre>


<p>
<ul>
<li>در خط 2 کلاسی از نوع abstract تعریف شده.</li>
<li>در خط 4 و 5 تابع های Insert , Update از نوع &nbsp;abstract تعریف شده اند و می بینید که این توابع بدنه ندارند.</li>
<li>در خط 6 هم یک تابع معمولی تعریف شده.</li>
<li>در خط 14 و 24 یک کلاس معمولی ایجاد شده که از کلاس abstract مشتق شده است.پس بنابراین باید توابعی که به صورت abstract تعریف شده بودند راتکمیل کند و بدنه ی آنها را تشکیل دهد که این کار در خط های (15 و 19) &nbsp;&nbsp;(25و29) اینجام شده است.</li>
</ul>
</p>

<p>
با کمک کلاس های MySQL_DB و Oracle_DB که در بالا تعریف شد می توان با تابع save و یا هر تابع دیگری کارهای مربوطه را انجام داد؛ توجه داشته باشید که توابع update و insert که در کلاس Base_DB به صورت abstract تعریف شده اند باید در کلاسهایی که از آن سرچشمه می گیرند تعریف شده باشند.
</p>


