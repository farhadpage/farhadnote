<!DOCTYPE html>
<html lang="">
<!-- head -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور | مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" />
<meta name="author" content="Farhad Mirzapour" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" />
<meta property="og:description" content="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" />
<link rel="canonical" href="http://localhost:4000/search.html" />
<meta property="og:url" content="http://localhost:4000/search.html" />
<meta property="og:site_name" content="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" />
<meta name="twitter:site" content="@farhadmirzapour" />
<meta name="twitter:creator" content="@Farhad Mirzapour" />
<script type="application/ld+json">
{"@type":"WebPage","headline":"مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور","url":"http://localhost:4000/search.html","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/img/logo/blankspace-avatar.png"},"name":"Farhad Mirzapour"},"author":{"@type":"Person","name":"Farhad Mirzapour"},"description":"مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <!-- stylesheets -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css">
    <link rel="stylesheet" href="/assets/main.css">
    <link rel="stylesheet" href="/assets/prisma/prism.css">
    <!-- favicons and rss -->
    <link rel="alternate" type="application/rss+xml" title="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" href="/feed.xml">
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/img/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/img/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/img/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
</head>
<body>
<!-- header -->
<header class="header" role="banner" aria-label="Header">
    <button class="hamburger-button" onclick="hamburgerMenu();" role="button" aria-label="Hamburger menu button">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </button>
    <a href="/" class="logo" role="link" aria-label="Home">
        <img alt="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" src="/assets/img/logo/farhadmirzapour-logo.png" role="img" aria-label="Logo">
    </a>
    <nav class="navigation" role="navigation" aria-label="Navigation">
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
            <li role="menuitem" aria-label="Navigation menu item">
                <a href="/" class="logo" role="menuitem" aria-label="Home">
                    <img alt="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" src="/assets/img/logo/farhadmirzapour-logo.png" role="img" aria-label="Logo">
                </a>
            </li>
            
            <li role="menuitem"><a href="/blog" role="menuitem" aria-label="مقالات">مقالات</a></li>
            
            <li role="menuitem"><a href="/contactus" role="menuitem" aria-label="تماس">تماس</a></li>
            
        </ul>
    </nav>
    <div class="searchbox" role="search" aria-label="Search">
        <form action="/search" id="searchthis" method="get" role="form" aria-label="Search form">
            <i class="fa fa-search" aria-hidden="true"></i>
            <input type="search" id="search" name="query" placeholder="Search..." role="textbox" aria-label="Search textbox">
        </form>
    </div>
</header>

<nav id="hamburger-menu" role="navigation" aria-label="Hamburger menu">
    <div class="searchbox" role="search" aria-label="Search">
        <form action="/search" id="searchthis" method="get" role="form" aria-label="Search form">
            <i class="fa fa-search" aria-hidden="true"></i>
            <input type="search" id="search" name="query" placeholder="Search..." role="textbox" aria-label="Search textbox">
        </form>
    </div>
    <div class="home-nav" role="navigation" aria-label="Site navigation">
        <a href="/" role="menuitem" aria-label="Home">صفحه اصلی</a>
        
        <a href="/blog" role="menuitem" aria-label="مقالات">مقالات</a>
        
        <a href="/contactus" role="menuitem" aria-label="تماس">تماس</a>
        
    </div>

    
</nav>
<!-- main content -->
<main class="container" role="main">
    
<ul id="search-results">
    <h2 class="searching-text">Searching.....</h2>
</ul>
<script>
  window.store = {
    
        
          "documentation-object-oriented-programming-in-php-class-structure" :{
            "title": "ساختار کلاس در PHP",
            "content": "ساختار کلاس هادر php یک کلاس با کلمه کلیدی (class) بوجود میاد و با یک اسپیس و تایپ یک اسم، شما اسم اون کلاس رو تعریف میکنید و در نهایت با قرار دادن براکت های باز و بسته ( { }&nbsp;) کار یک class رو شروع میکنید . دقیقا مثل مثال زیر :class MyClass{  // class propertys and methods go here;}بعد از به وجود آوردن کلاس ما با استفاده از کلمه کلیدی new می تونیم از اون کلاس استفاده کنیم و یک شی (object) با همون کلاس بسازیم . در زیر میتونید این روش رو ببینید:$obj = new MyClass;شما با قرار دادن شی (obj$) در داخل var_dump میتونید محتوای کلاس رو مشاهده کنید:var_dump($obj);معرفی property هابرای اضافه کردن اطلاعات در کلاس ها از property ها استفاده میشه . کار اونها دقیقا شبیه متغیرها در php معمولیه و تنها تفاوتشون اینکه قبل از تایپ اسم property از کلمات کلیدی private ,&nbsp;protected و public استفاده میشه ، این کلمات کلیدی رو در کپسوله سازی (پنهان سازی) بطور کامل توضیح می دم فقط فعلا در همین حد بدونید که این کلمات باید برای تعریف property ها و method ها قبل از اسم اونها قرار بگیرند:class MyClass{  public $name = 'john doe';}$obj = new MyClass;var_dump($obj);در بالا با استفاده از کلمه public تعیین کردیم که property مون برای استفاده در یک object قابل مشاهدست و همینطور property به اسم name$ تعریف و بعد اون رو مقدار دهی کردیم و بعد با تعریف یک شی و قرار دادن اون در var_dump اطلاعات کامل رو برگشت دادیم .شما به راحتی میتونید بعد از تعریف شی دوباره property رو مقداردهی کنید البته تنها در حالتی که اون property از نوع public باشه و همینطور به راحتی میتونید اون رو با استفاده از echo چاپ کنید . البته برای چاپ یا مقداردهی دوباره ، نیاز به دسترسی به اون property از طریق object دارید برای اینکار بعد از تایپ اسم object با قرار دادن یک فلش ( &lt;- ) و تایپ اسم property میتونید به اون دسترسی داشته باشید . به مثال زیر دقت کنید:class MyClass{  public $name = 'John Doe';}$obj = new MyClass;echo $obj-&gt;name . '&lt;/br &gt;';$obj-&gt;name = 'Hesam Mousavi';echo $obj-&gt;name ;معرفی method هاmethod ها دقیقا کار توابع رو در کلاس ها انجام میدن یعنی تفاوتی چندانی با هم ندارن method ها هم با قرار گرفتن کلمه کلیدی&nbsp;private&nbsp;,&nbsp;protected&nbsp;و&nbsp;public قبل از function تعریف میشن . یک method میتونه به شی ها کمک کنه که در داخل کلاس ها عملیاتی رو انجام بدن البته این عملیات توسط متدها مشخص میشه .&nbsp;برای مثال متدهایی برای set و get کردن اطلاعات property داخل کلاس می نویسیم . به کد زیر دقت کنید:class MyClass{  public $name = 'John Doe';  public function setProperty($newval)  {     $this-&gt;name = $newval;  }  public function getProperty()  {     return $this-&gt;name . \"&lt;/br &gt;\";  }}$obj = new MyClass;echo $obj-&gt;name;نکته : در کد بالا ما در دو جا از this$ استفاده کردیم و بعد با یک فلش و قرار دادن اسم property بهش دسترسی پیدا کردیم . در اصل این طریقه دسترسی به property ها و  method ها در داخل یک  method است . چون بطور معمولی شما نمی تونید با تایپ فقط اسم property یا method بهش دسترسی داشته باشید تنها زمانی که از this$ و با روش بالا عمل کنید میتونید به یک  property و  method از یک کلاس داخل یک method دسترسی پیدا کنید .در کد بالا من فقط با قرار دادن obj-&gt;name$ اومدم مقدار این  property رو چاپ کردم اما در مثال زیر من ابتدا من با استفاده از متد getProperty میام مقدار فعلی name$ رو چاپ میکنم و بعد در مرحله بعدی با استفاده از متد setProperty و ارسال یک مقدار به عنوان آرگومان میام یک مقدار جدید برای name$ تعیین میکنم و بعد دوباره با چاپ کردن متد getProperty میام مقدار فعلیش رو چاپ می کنیم . این یک روش مهم برای set و get کردن  property هاست که به زودی در قسمت بعد دلیلش رو هم میفهمید ولی فعلا از دید امتحان کردن یک متد بهش نگاه کنید:class MyClass{  public $name = \"John Doe\";  public function setProperty($newval)  {      $this-&gt;name = $newval;  }  public function getProperty()  {      return $this-&gt;name . \"\";  }}$obj = new MyClass;echo $obj-&gt;getProperty(); // Get the property value$obj-&gt;setProperty(\"Hesam Mousavi\"); // Set a new oneecho $obj-&gt;getProperty(); // Read it out again to show the changeنتیجه زیر حاصل از اجرای کد بالاست:John DoeHesam Mousaviثابت هایک ثابت چیزی شبیه به یک متغیر است، که می تواند یک مقدار را در خود نگاه دارد. یک بار که شما یک ثابت را تعریف کنید آن ثابت دیگر تغییر نخواهد کرد.class MyClass {    const requiredMargin = 1.7;    function __construct($incomingValue) {        // Statements here run every time        // an instance of the class        // is created.    }}در این کلاس، requiredMargin یک ثابت است. این ثابت با استفاده از کلمه کلیدی const اعلان شده است و تحت هیچ شرایطی مقدار آن بع غیر از 1.7 تغییر نخواهد کرد. توجه داشته باشید که نام ثابت پیشوند $ مشابه آنچه در مورد متغیرها به کار می رود ندارد.کلمه کلیدی staticاعلان اعضا یا متدهای کلاس به صورت static آنها را بدون نیاز به نمونه سازی از کلاس در دسترس می کند. یک عضو اعلان شده به صورت static نمی تواند با یک شی کلاس نمونه سازی شده در دسترس باشد(البته از طریق یک متد استاتیک می تواند).&lt;?phpclass Foo {    public static $my_static = 'foo';    public function staticValue() {        return self::$my_static;    }}print Foo::$my_static . \"\\n\";$foo = new Foo();print $foo-&gt;staticValue() . \"\\n\";",
            "url": "/documentation/object-oriented-programming-in-php/class-structure"
          }
          ,
        
          "documentation-object-oriented-programming-in-php-encapsulation" :{
            "title": "Encapsulation (کپسوله سازی)",
            "content": "کپسوله سازی (Encapsulation)کپسوله سازی همون پنهان سازی اطلاعاته اما ما چرا باید اطلاعاتی رو پنهان سازی کنیم . در جلسه قبل اگه یادتون باشه من دوتا method درست کردم به اسم های set و get که هر کدوم کار خودشون رو انجام می دادن یعنی یکی مقداردهی property مون رو انجام میداد و یکی مقدار property رو برامون بر میگردوند اما چرا باید اینطوری باشه . این سوالیه که منم داشتم چون ما به راحتی میتونیم از خود property استفاده کنیم و مقداردهی و چاپش کنیم اما این درست نیست . گاهی property ها و method های حساسی وجود داره که قابل استفاده در object ها نیستن ! چرا نیستن ؟ چون پنهان سازی شدن . اگه یادتون باشه در جلسه قبلی سه کلمه کلیدی public , private و protected رو معرفی کردم اما فقط از public استفاده کردم و گفتم تو این جلسه میگم اینا به چه کاری میان بزارین با تعریف کردن هر کدوم اینا به نتیجه برسیم .protected  : اگر property یا method ای قبلش از این کلمه استفاده بشه به این معنیه که شما از اون property و method  فقط در کلاس ها میتونید استفاده کنید و اصلا نمی تونید در object ای که میسازید مورد استفاده قرارش بدید . [ البته با روش های خاص میشه ]private : اگر property یا method ای قبلش از این کلمه استفاده بشه به این معنیه که شما از اون property و method فقط و فقط میتونید در داخل همون کلاس استفاده کنید و پس یعنی قابلیت استفاده در object رو هم ندارید . private شبیه protected  اما استفاده نشدن در کلاس های دیگه بین اونا فرق میزاره .و در نهایت public : اگر property یا method ای قبلش از این کلمه استفاده بشه به این معنیه که شما از اون property و method به راحتی می تونید در کلاس ها و object ها استفاده کنید . به همین سادگی .خب حالا شما میگین اینا فقط تعریف بودن اما هنوز کپسوله سازی رو دقیقا نفهمیدم که چی هست . شما گاهی میخواین اطلاعاتی رو به نسبت حساسیتش از object یا کلاس های دیگه مخفی کنید . برای همین به نسبت کاری که قراره انجام بدید در از private یا protected استفاده میکنید تا دیگه در object ها قابلیت استفاده نداشته باشن .خب حالا فکر کنم باید متوجه شده باشید چرا از method های set و get استفاده کردیم ولی هر موضوعی با مثال واضح تر میشه پس به مثال های زیر دقت کنید تا بیشتر براتون این موضوع جا بیوفته .class MyClass{  public $name = 'John Doe';}$obj = new MyClass;echo $obj-&gt;name . '&lt;/br &gt;';$obj-&gt;name = 'Hesam Mousavi';echo $obj-&gt;name ;این همون مثال جلسه قبلیه در این مثال property ما از نوع public برای همین با ساخت object به راحتی می تونید از خود object هم عمل مقدار دهی دوباره و هم مقدار فعلیش رو برگشت بدید . حالا به مثال زیر هم دقت کنید .class MyClass{  protected $name = 'John Doe';}$obj = new MyClass;echo $obj-&gt;name;در بالا property ما از نوع protected برای همین در object نه میتونید مقدار دهی کنید و نه میتونید مقدار فعلی رو بر گردونید در واقع اگه کد بالا رو اجرا کنید بهتون ارور میده .اما در مثال زیر با استفاده از متدهای get و set به راحتی یک property ای که از نوع protected باشه رو مقدار دهی یا مقدار فعلی رو برگشت میدیم .class MyClass{  protected $name = \"John Doe\";  public function setProperty($newval)  {      $this-&gt;name = $newval;  }  public function getProperty()  {      return $this-&gt;name . \"\";  }}$obj = new MyClass;echo $obj-&gt;getProperty(); // Get the property value$obj-&gt;setProperty(\"Hesam Mousavi\"); // Set a new oneecho $obj-&gt;getProperty(); // Read it out again to show the changeحالا میبینید که در کد بالا به راحتی با استفاده از method ها تونیستم عمل مقدار دهی و همینطور برگشت مقدار فعلی یک property از نوع protected رو انجام بدیم . برای کلمه private هم همین وضعیت بالا (protected) برقراره اما یک ویژگی دیگه ای که private داره اینکه در کلاس های دیگه قابل استفاده نیست .",
            "url": "/documentation/object-oriented-programming-in-php/encapsulation"
          }
          ,
        
          "documentation-object-oriented-programming-in-php-inheritance" :{
            "title": "Inheritance (وراثت)",
            "content": "وراثت (Inheritance)وراثت یکی از شکل‌های «قابلیت استفاده مجدد» کد بوده که برنامه‌نویس را قادر می‌سازد تا با ارث‌بری صفات و متدهای یک یا چند کلاس موجود، کلاس‌های جدیدی را ایجاد نماید.برای نمونه فرض کنیم صاحب کلاس کارخانه خودروسازی مثال پیش، قصد تولید یک مدل خودرو جدید با رویکرد باربری دارد؛ بنابراین می‌بایست کلاسی جدید برای تولید آن تهیه نماید. ولی کلاس جدید علاوه‌بر صفات (ظرفیت بارگیری و..) و متدهای (انجام بارگیری، تخلیه بار و...) خاص خودش به صفات (رنگ بدنه، ظرفیت باک و...) و متدهای (راندن، سوخت گیری، توقف و...) مشابه در کلاس قبل هم نیاز دارد؛ در این حالت نیازی به تعریف مجدد آن‌ها نیست و می‌توان صفات و متدهای کلاس پیش را در کلاس جدید به ارث برد.به کلاسی که از آن ارث‌بری می‌شود ”Parent Class“ یا ”Base Class“ (کلاس پایه) یا ”Superclass“ و به کلاسی که اقدام به ارث‌بری می‌کند ”Child Class“ (کلاس فرزند) یا ”Derived Class“ یا ”Subclass“ گفته می‌شود.ارث‌بری توسط «نسبت هست-یک» (IS-A Relationship) بیان می‌شود؛ این نسبت می‌گوید کلاس فرزند یک نوع از چیزی است که کلاس پایه هست. کلاس A از کلاس B ارث‌بری دارد؛ در این حالت می‌گوییم: A is a type of B، یعنی درست است اگر بگوییم: «سیب» یک نوع «میوه» است یا «خودرو» یک نوع «وسیله نقلیه» است ولی توجه داشته باشید که این یک ارتباط یک‌طرفه از کلاس فرزند به کلاس پایه است و نمی‌توانیم بگوییم: «میوه» یک نوع «سیب» است یا «وسیله نقلیه» یک نوع «خودرو» است.کلاس‌ها می‌توانند مستقل باشند ولی هنگامی که وارد رابطه‌های وراثت می‌شوند، یک ساختار سلسله مراتب (Hierarchy) به شکل درخت را تشکیل می‌دهند. برای نمونه به ساختار سلسله مراتب وراثت پایین که مربوط به برخی اشکال هندسی است توجه نمایید، پیکان‌ها نشانگر نسبت is-a هستند.در برنامه‌نویسی شی‌گرا نسبت دیگری نیز با عنوان «نسبت دارد-یک» (HAS-A Relationship) وجود دارد که بیانگر مفهومی به نام «ترکیب» (Composition) است که شکل دیگری از قابلیت استفاده مجدد کد می‌باشد ولی مفهومی متفاوت با وراثت دارد. این نسبت زمانی بیان می‌شود که درون یک کلاس (مانند: C) از کلاس دیگری (مانند: D) نمونه‌سازی شده باشد؛ یعنی شی کلاس C درون خودش شی‌ای از کلاس D را داشته باشد؛ در این حالت می‌گوییم: C has a D. به یاد دارید خواندیم کلاس خودرو از کلاس‌های کوچکتری ساخته شده است؛ مثلا کلاس موتور - یعنی درون این کلاس یک شی از کلاس موتور ایجاد شده است، اکنون می‌توانیم بگوییم: «خودرو» یک «موتور» دارد.وراثت در PHPدر نظر بگیرید شما باید یک متدی با یک وظیفه ای خاصی بنویسید اما دقیقا این متد در پدر یا پدر پدر کلاس فعلیتون وجود داره خوب بنظرتون باید دوباره اون method رو بنویسید یا از اون متدی که در کلاس های پدر هست استفاده کنید . اول اینکه دوباره نویسی کدهاتون فوق العاده کم میشه و بعدش اینکه مدیریت روی کدهاتون به راحتی بالا میره . کیه که این روش کد نویسی رو نخواد . چون واقعا کار رو راحتتر میکنه .بزارید یک مثال ساده بزنم . در پایین من یک کلاس معمولی به اسم Father میسازم و یک method توش قرار میدم .class father{    public function getEyeCount() {        return 2 ;    }}خب حالا که کلاس پدر رو ساختیم میخوام یک کلاس دیگه مثل زیر بسازم به اسم child و به father متصل کنم.class child extends father{}$obj = new child;echo $obj---&gt;getEyeCount; // 2در بالا ما با کمک کلمه کلیدی extends تونستیم کلاس child رو به کلاس father مرتبط کنیم و با استفاده از متدی که در کلاس father هست مقداری رو در کلاس فرزند برگردونیم .نکته : به یاد داشته باشید property ها و method های که از نوع private باشن قابلیت ارث بری ندارن و نمیشه در کلاس های فرزند از این نوع method ها و property ها استفاده کرد .در اینجا چند مسئله پیش میاد که شاید برای شما هم سوال شده باشه ! مسئله اول اینکه یک کلاس که از کلاس پدر ارث می بره خودش (فرزند) میتونه ویزگی های ( method ها و peroperty های ) خودش رو داشته باشه ؟ مسئله دوم اینکه آیا میشه method ها و property های که در کلاس پدر هست در کلاس فرزند هم دوباره نویسی کرد با یک ویژگی خاص دیگه ؟ بزارید اینجا به این دو مسئله جواب بدیم تا دیگه سوالی در موردش نباشه .یک کلاس که از کلاس پدر ارث می بره خودش (فرزند) میتونه ویزگی های خودش رو داشته باشه ؟جواب این مسئله بله است . چرا ؟ این دفعه بزارید با یک سوال از شما به چرایی این موضوع پی ببریم . آیا شمایی که ویژگی های رو از والدینتون به ارث میبرید . آیا خودتون اخلاق و ویژگی های خاص خودتون رو ندارید ؟ فکر کنم فهمیده باشید داستان چیه . چون مسئله سختی نیست . ولی با این حالبه کد زیر توجه کنید که در داخل کلاس فرزند یک متد جدید میسازیم و به راحتی ازش استفاده میکنیم .class MyClass{  public $prop1 = \"I'm a class property!\";  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1;  }}class MyOtherClass extends MyClass{  public function newMethod()  {      echo \"From a new method in\" . __CLASS__ ;  }}// Create a new object$newobj = new MyOtherClass;// Output the object as a stringecho $newobj-&gt;newMethod();// Use a method from the parent classecho $newobj-&gt;getProperty(); نتیجه کد بالا بصورت زیر به نمایش در میاد اما شاید براتون سوال شده باشه که __CLASS__ دقیقا چیه این اسم کلاس رو برامون بر میگردونه .From a new method in MyOtherClass.I'm a class property!مفهوم Overriding آیا میشه method ها و property های که در کلاس پدر هست در کلاس فرزند هم دوباره نویسی کرد با یک ویژگی دیگه ؟جواب این مسئله هم بله است ، شما به راحتی مثل کد زیر می تونید همون متدی که در کلاس پدر هست با همون اسم در کلاس فرزند بسازین و دوباره نویسی کنید با ویژگی های جدید اینطوری اول چک میکنه که اون method در کلاس فزرند هست یا خیر اگر بود که برگشت داده میشه و اگر نبود به کلاس پدر میره و دنبال اون method میگرده و اگر بود برمیگردونه.class Foo{    public function printItem($string)    {        echo 'Foo: ' . $string . PHP_EOL;    }    public function printPHP()    {        echo 'PHP is great.' . PHP_EOL;    }}class Bar extends Foo{    public function printItem($string)    {        echo 'Bar: ' . $string . PHP_EOL;    }}$foo = new Foo();$bar = new Bar();$foo-&gt;printItem('baz'); // Output: 'Foo: baz'$foo-&gt;printPHP();       // Output: 'PHP is great'$bar-&gt;printItem('baz'); // Output: 'Bar: baz'$bar-&gt;printPHP();       // Output: 'PHP is great'کلمه کلیدی Finalدر PHP5 کلمه کلیدی final معرفی شد که از همپوشانی یک متدی که به صورت final‌تعریف شده توسط کلاس های فرزند جلوگیری می کند. اکر کلاس خودش به صورت final تعریف شود آنگاه نمی تواند ارث بری شود.&lt;?phpclass BaseClass {    public function test() {        echo \"BaseClass::test() called\";    }    final public function moreTesting() {        echo \"BaseClass::moreTesting() called\";    }}class ChildClass extends BaseClass {    public function moreTesting() {        echo \"ChildClass::moreTesting() called\";    }}مثال بالا منجر به خطای زیر شده است :Cannot override final method BaseClass::moreTesting()عملگرهای parent و selfparent و self در PHP دو کلمه کلیدی هستند که کدنویسی را در زمان نوشتن برنامه های شیء گرا راحت می کنند. از کلمه کلیدی parent برای دسترسی به سازنده و متدهای کلاس والد و از کلمه کلیدی self برای دسترسی به کلاس جاری و استفاده از اعضا و متدهای استاتیک و همچنین ثابت های کلاس استفاده می شود. نحوه استفاده از این دو کلمه برای دسترسی به اعضا و متدها به صورت زیر است :parent :: class memberself :: class memberیعنی مثلا اگر بخواهیم از یک ثابت در یک کلاس استفاده کنیم کافیست کلمه self و بعد از آن دو نقطه و سپس نام ثابت را بنویسیم. در کد زیر نحوه استفاده از این دو کلمه کلیدی آمده است :&lt;?php     class ParentClass     {         const NAME = \"ParentClass\";         function __construct()         {             echo \"In \" . self::NAME . \" constructor\" . \"\";         }     }     class Child extends ParentClass     {         const NAME = \"Child\";         function __construct()         {             parent::__construct();             echo \"In \" . self::NAME . \" constructor\" . \"\";         }     }     $child = new Child(); خروجی :  In ParentClass constructor In Child constructor    همانطور که احتمالا متوجه شده اید برای دسترسی به اعضا، متدها و ثابت ها بعد از این دو کلمه کلیدی علامت دو نقطه (::) می گذاریم. کلمه کلیدی self در خط 7 به کلاس ParentClass و در خط 17 به کلاس Child اشاره دارد. در همین دو خط علامت دو نقطه و سپس نام ثابت های این دو کلاس یعنی NAME را نوشته ایم و این بدین معنی است که می خواهیم از این ثابت ها استفاده کنیم. در خط 16 برای اینکه از تمام کدهای سازنده کلاس پدر استفاده کنیم، به راحتی کلمه parent و بعد دو نقطه و در نهایت نام سازنده یعنی ()constract__ را می نویسیم. این کار باعث می شود تمام کدهای موجود در سازنده کلاس پدر در داخل کلاس فرزند اجرا شوند. برای همین است که وقتی یک شیء از کلاس فرزند ایجاد می کنیم کدهای سازنده کلاس پدر (خط 7) اجرا می شوند.  ",
            "url": "/documentation/object-oriented-programming-in-php/inheritance"
          }
          ,
        
          "documentation-object-oriented-programming-in-php-magic-methods" :{
            "title": "متدهای جادوئی در شی گرایی php",
            "content": "متدهای جادوئی در شی گرایی phpphp برای ساده تر کردن بعضی از کارها در کلاس ها یک سری متدهای خاص و ویژه در شی گرایی قرار داده که این موضوع به توسعه دهندگان اجازه میده تا تعدادی از کارهای مفید رو به سهولت انجام بدن .استفاده از Constructors , Destructorsبزارید اینطور براتون توضیح بدم. زمانی که شما یک object رو از کلاسی میسازید در همون ابتدای ساختن بطور اتوماتیک می خواید یک سری اعمال انجام بشه . شما اینکار رو به سادگی با متد ()construct__  می تونید انجام بدید. یه ویژگی در مورد متدهای جادوئی که یادم رفت در بالا بگم اینکه تمام متدهای جادوئی دارای دو Underscore یا ( __ ) در قبل اسم متد هستن که به این صورت میشه فهمید که اون متد یک متد جادوئیه .حالا اگه شما بخواین راحت تر با کار ()construct__ آشنا بشین در زیر یک مثال از این متد میزنم که در هنگام ایجاد شدن obj یک مقداری رو بطور اتوماتیک چاپ کنه .class MyClass{  public $prop1 = \"I'm a class property!\";  public function __construct()  {      echo 'The class \"', __CLASS__, '\" was initiated!';  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1 . \"\";  }}// Create a new object$obj = new MyClass;// Get the value of $prop1echo $obj-&gt;getProperty();// Output a message at the end of the fileecho \"End of file.\";در بالا شما در یک قسمت با __CLASS__ مواجه شدید که این یک ثابت جادوئیه ( magic constant ) که دقیقا مثل متدهای جادوئی یک سری اعمال رو انجام میده مثلا در این جا __CLASS__ اسم کلاسی که توش قرار داره رو بر میگردونه . شما با مراجعه به این صفحه میتونید مابقی magic constant رو ببینید .در زیر میتونید نتیجه کد بالا رو مشاهده کنید .The class \"MyClass\" was initiated!I'm a class property!End of file.خب حالا میرسیم به متد ()destruct__ . زمانی که یک Object نابود میشه این متد فراخونی و اجرا میشه یکی از مثال های این مورد میتونه زمانی که ارتباط با دیتابیس بسته میشه باشه که این متد اجرا بشه و یه سری کارها رو انجام بده .در زیر با استفاده از این متد زمانی که یک obj نابود میشه یک پیام چاپ میشه . به مثال زیر دقت کنید .class MyClass{  public $prop1 = \"I'm a class property!\";  public function __construct()  {      echo 'The class \"', __CLASS__, '\" was initiated!';  }  public function __destruct()  {      echo 'The class \"', __CLASS__, '\" was destroyed.';  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1 . \"\";  }}// Create a new object$obj = new MyClass;// Get the value of $prop1echo $obj-&gt;getProperty();// Output a message at the end of the fileecho \"End of file.\";با تعریف یک destruct خروجی کد بالا به صورت زیر میشه .The class \"MyClass\" was initiated!I'm a class property!End of file.The class \"MyClass\" was destroyed.شما با یک تابع به اسم unset می تونید یک Obj رو زودتر از زمانی که قراره نابود بشه نابود کنید. در زیر یک مثال با این تابع میزنم تا بهتر بتونید این مسئله و درک کنید .class MyClass{  public $prop1 = \"I'm a class property!\";  public function __construct()  {      echo 'The class \"', __CLASS__, '\" was initiated!';  }  public function __destruct()  {      echo 'The class \"', __CLASS__, '\" was destroyed.';  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1 . \"\";  }}// Create a new object$obj = new MyClass;// Get the value of $prop1echo $obj-&gt;getProperty();// Destroy the objectunset($obj);// Output a message at the end of the fileecho \"End of file.\";خب حالا به نتیجه کد بالا دقت کنید .The class \"MyClass\" was initiated!I'm a class property!The class \"MyClass\" was destroyed.End of file.تبدیل به یک رشته (Converting to a String)اگر شما یک obj رو بخواین بطور مستقیم به عنوان رشته چاپ کنید قطعا با ارور مواجه میشید . اما با استفاده از متد جادوئی ()toString__ میتونید یک obj رو بصورت یک رشته چاپ کنید .در زیر مثالی می زنم که قصد دارم obj رو بصورت یک رشته با echo چاپ کنم اما با ارور مواجه میشم .class MyClass{  public $prop1 = \"I'm a class property!\";  public function __construct()  {      echo 'The class \"', __CLASS__, '\" was initiated!';  }  public function __destruct()  {      echo 'The class \"', __CLASS__, '\" was destroyed.';  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1 . \"\";  }}// Create a new object$obj = new MyClass;// Output the object as a stringecho $obj;// Destroy the objectunset($obj);// Output a message at the end of the fileecho \"End of file.\";خروجی کد بالا بصورت زیره که ارور رو هم میتونید ببینید :The class \"MyClass\" was initiated!Catchable fatal error: Object of class MyClass could not be converted to string in /Applications/XAMPP/xamppfiles/htdocs/testing/test.php on line 40برای رفع ارور ما میتونیم از متد ()toString__ استفاده کنیمclass MyClass{  public $prop1 = \"I'm a class property!\";  public function __construct()  {      echo 'The class \"', __CLASS__, '\" was initiated!';  }  public function __destruct()  {      echo 'The class \"', __CLASS__, '\" was destroyed.';  }  public function __toString()  {      echo \"Using the toString method: \";      return $this-&gt;getProperty();  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1 . \"\";  }}// Create a new object$obj = new MyClass;// Output the object as a stringecho $obj;// Destroy the objectunset($obj);// Output a message at the end of the fileecho \"End of file.\";در مثال بالا ما با استفاده از ()toString__ به علاوه اینکه یک رشته رو چاپ میکنیم ، یک متد از کلاس به اسم getProperty رو هم بر میگردونیم که شما برای واضح تر شدن و درک این موضوع به نتیجه کد بالا دقت کنید .The class \"MyClass\" was initiated!Using the toString method: I'm a class property!The class \"MyClass\" was destroyed.End of file.خب در این پست من چند تا از متدهای جادوئی رو معرفی کردم که امیدوارم باهشون آشنا شده باشید اگر میخواید با متدهای بیشتری از متدهای جادوئی آشنا بشین به این صفحه مراجعه کنید . \"Magic Methods\"",
            "url": "/documentation/object-oriented-programming-in-php/magic-methods"
          }
          ,
        
          "documentation-object-oriented-programming-in-php-abstract-class" :{
            "title": "کلاس های Abstract (انتزاعی)",
            "content": "مفهوم Abstract  (انتزاع)انتزاع در لغت به معنای جدا کردن، گرفتن، درآوردن جزئی از یک کل  می باشد.تجرید در برنامه‌نویسی شی‌گرا به همراه مفهوم چندریختی می‌آید و توسط دو مفهوم «کلاس‌های مجرد» (Abstract Classes) و «متدهای مجرد» (Abstract Methods) ارایه می‌گردد.«کلاس مجرد» کلاسی است که شامل یک یا چند «متد مجرد» باشد و «متد مجرد» متدی است که اعلان (Declare) شده ولی بدنه آن ‌تعریف (Define) نشده است. کلاس‌های مجرد قابلیت نمونه‌سازی ندارند و نمی‌توان از آن‌ها شی ایجاد نمود؛ چرا که هدف از توسعه آن‌ها قرار گرفتن در بالاترین سطح (یا چند سطح بالایی) درخت وراثت، به عنوان کلاس پایه برای ارث‌بری کلاس‌های پایین‌تر می‌باشد. ایده طراحی کلاس مجرد در تعیین یک نقشه توسعه برای کلاس‌های فرزند آن است؛ تعیین صفات و متدهای لازم ولی واگذاردن تعریف متدها بر عهده کلاس‌های فرزند.به عنوان نمونه سه کلاس «ماهی»، «گربه» و «کبوتر» را در نظر بگیرید. این کلاس‌ها جدا از رفتارهای خاص خود (مانند: «پرواز کردن» در کبوتر یا «شنا کردن» در ماهی)، در یک سری رفتار به مانند «نفس کشیدن»، «غذا خوردن» و... مشترک هستند. راه درستِ توسعه این کلاس‌ها تعیین یک «کلاس پایه» برای رفتارهای مشترک و ارث‌بری هر سه آن‌ها می‌باشد. ولی از آنجا که هر یک، این رفتارهای مشترک را به گونه‌ای دیگر انجام می‌دهد؛ راه درست‌تر آن است که یک «کلاس مجرد» به عنوان «کلاس پایه» آن‌ها در نظر بگیریم؛ در این حالت هر کدام از کلاس‌ها ضمن دانستن رفتارهای لازم می‌تواند آن‌‌ها را متناسب با خواست خود تعریف نماید. کلاس های Abstract (انتزاعی)توجه کنید که کلاس هایی که از نوع abstract تعریف بشن ، نمیشه ازشون شی ای ساخت و تنها می توان از آنها مشتق گرفت.یکی از مزایای کلاس abstract این است که می توان در داخل آنها تابع هایی (متد) تعریف کرد که بدنه نداشته باشن.برای این منظور باید نوع اون تابع هم abstract باشد و  زمانی که که یک کلاس از کلاس abstract مشتق بشه اون توابع رو باید پیاده کنه یعنی بدنه ی اون تابع رو تکمیل کند.پس در داخل کلاس هایی از نوع abstract هم میتوان تابع های معمولی نوشت هم تابع هایی از نوع abstract که بدنه نداشته باشن.کاربرد دیگه ی کلاسهای abstract این هست که شما با این نوع کلاسها میتونید نویسنده های کلاسهای فرزند رو وادار کنید که برخی توابع رو بازنویسی کنند( در ادامه بیشتر متوجه این موضوع میشید).نحوه ی تعریف یک کلاس abstractبرای تعریف یک کلاس انتزاعی از کلمه کلیدی abstract  قبل از class  استفاده میکنیم :abstract class Animal{    public $name;    public $age;    public function Describe()    {        return $this-&gt;name . \", \" . $this-&gt;age . \" years old\";    }    abstract public function Greet();}الان اگه شما از کلاس بالا نمونه بگیرید با اررور مواجه میشید. طبیعی هم هست دیگه 🙂یادتون باشه درون کلاس abstractتون میتونید متد هایی رو تعریف کنید و از اونها استفاده کنید و اون متد ها میتونن abstract باشن یا نه…اگه متدی رو از نوع abstract تعریف کردید ، توسعه دهنده های دیگه رو مجبور میکنید : در صورتی که از کلاس شما کلاسی رو به ارث بردن ، حتما نابع رو دوباره بنویسن. مثلا هر کلاسی که از کلاس بالا مشتق بشه ، باید متد Greet رو دوباره بنویسه.کلاس زیر از کلاس بالا مشتق شده :class Dog extends Animal{    public function Greet()    {        return \"Woof!\";    }    public function Describe()    {        return parent::Describe() . \", and I'm a dog!\";    }}همونطور که میبینید ما مجبور بودیم که متد  ()Greet  رو بازنویسی کنیم. حالا میتونیم از کلاس Dog بصورت زیر نمونه بگیریم :$animal = new Dog();$animal-&gt;name = \"Bob\";$animal-&gt;age = 7;echo $animal-&gt;Describe();echo $animal-&gt;Greet();به عنوان مثال دیگر اگر بخواهیم چندین کلاس مختلف برای کار با دیتابیس های مختلف در برنامه تعریف کنیم که در آن برخی کارها یکسان می باشد؛ میتوانیم یک کلاس abstract برای تعریف اولیه و توابع یکسان آنها تعریف کنیم و سپس به نسبت هر دیتابیس توابع مخصوص آن را فراخوانی کرد&lt;?phpabstract class Base_DB{    private $id;    abstract function update($data,$id);    abstract function insert($data);    function save($data){        if(is_null($this-&gt;id)){            $this-&gt;insert($data);        }else{            $this-&gt;update($data,$this-&gt;id);        }    }}class MySQL_DB extends Base_DB{    function update($data,$id)    {        // کدهای مربوط به ویرایش    }    function insert($data)    {        // کدهای مربوط به درج کردن    }}class Oracle_DB extends Base_DB{    function update($data,$id)    {        // کدهای مربوط به ویرایش    }    function insert($data)    {        // کدهای مربوط به درج کردن    }}در خط 2 کلاسی از نوع abstract تعریف شده.در خط 4 و 5 تابع های Insert , Update از نوع &nbsp;abstract تعریف شده اند و می بینید که این توابع بدنه ندارند.در خط 6 هم یک تابع معمولی تعریف شده.در خط 14 و 24 یک کلاس معمولی ایجاد شده که از کلاس abstract مشتق شده است.پس بنابراین باید توابعی که به صورت abstract تعریف شده بودند راتکمیل کند و بدنه ی آنها را تشکیل دهد که این کار در خط های (15 و 19) &nbsp;&nbsp;(25و29) اینجام شده است.با کمک کلاس های MySQL_DB و Oracle_DB که در بالا تعریف شد می توان با تابع save و یا هر تابع دیگری کارهای مربوطه را انجام داد؛ توجه داشته باشید که توابع update و insert که در کلاس Base_DB به صورت abstract تعریف شده اند باید در کلاسهایی که از آن سرچشمه می گیرند تعریف شده باشند.",
            "url": "/documentation/object-oriented-programming-in-php/abstract-class"
          }
          ,
        
          "documentation-object-oriented-programming-in-php-interface" :{
            "title": "interface در PHP",
            "content": " مفهوم و کاربرد اینترفیس – interface در PHPقبلا در مورد کلاسهای abstract در PHP مطلبی نوشتم ، کلاسهای انتزاعی یا abstract کلاسهایی هستند که قابل نمونه گیری نیستند و میتونیم درون کلاسهای انتزاعی متد هایی بنویسیم و در کلاسهایی که از اون مشتق شدن ازش استفاده کنیم. اینترفیس ها دقیقا مثل کلاسهای انتزاعی هستند ، با این تفاوت که در اینترفیس ها هیچ متدی نمیتونه دارای بدنه باشه. اولش خیلی عجیب به نظر میرسه… وقتی متدها بدنه نداشته باشن ، به چه دردی میخودن؟به خاطر داشته باشید که شما با تعریف یک متد در کلاس abstract نویسنده کلاسهای دیگه (که از این کلاس مشتق شدن) رو وادار نمیکردید که متدهای کلاس پدر رو بازنویسی کنه. ولی در اینترفیس ها اینطور هست ، یعنی هر کلاسی که یک اینرفیس رو implement کنه ، باید تمام متدهای کلاس پدر رو بازنویسی کنه.interface ها نباید  شامل هیچ بدنه یک تابع باشند و تابع های درون آن باید بدون بدنه باشند همگی. در صورتی که  abstract می توانستند ادغامی از توابع معمولی و توابع abstract (بدون بدنه) شوند.از interface ها مانند  abstract نمیتوان نمونه یا شی ای ایجاد کرد.interface به کلمه ی کلیدی extends از کلاس interface دیگری مشتق میگیرد.کلاس معمولی با کلمه ی implements  از interface دیگری مشتق میگیرد.نحوه ی تعریف interface ها در PHPبرای تعریف اینترفیس ها از کلمه کلیدی interface استفاده میکنیم :interface abc{public function xyz($b);}در مثال بالا کلاسها رو مجبور میکنیم که متد xyz رو بنویسن. برای ارث بردن یا به اصطلاح تکمیل کردن یک اینترفیس از کلمه کلیدی implements استفاده میکنیم :class test implements abc{public function xyz($b){//your function body}}نکته قابل توجه اینه که تمام متد ها و پراپرتی هایی که درون یک اینترفیس تعریف میشن باید بصورت عمومی یا public تعریف بشن ، در غیر اینصورت با اررور مواجه میشیم.یک نکته دیگه اینکه یک کلاس میتونه بیش از یک اینترفیس رو implement کنه و همچنین یک اینترفیس میتونه از چند اینترفیس دیگه مشتق بشه.مثال :&lt;?phpinterface a{    public function foo();}interface b extends a{    public function baz(Baz $baz);}// This will workclass c implements b{    public function foo()    {    }    public function baz(Baz $baz)    {    }}&nbsp;در خط 2 یک&nbsp;interface تعریف شده است.در خط 4 متدی تعریف شده به نام&nbsp;foo . چون داخل کلاسی از نوع Interface است پس نباید بدنه داشته باشد.در خط 7&nbsp;یک&nbsp;Interface تعریف شده و طبق قانون گفته شده با کلمه ی کلیدی extends از a مشتق شده است.دز خط 13 کلاس معمولی c طبق قانون گفته شده &nbsp;با کلمه کلیدی&nbsp;implements از b&nbsp;مشتق شده است.در خط 15 و 19 توابعی تعریف شدن به همراه بدنه. زیرا کلاس c از دو interface مشتق شده است و باید بدنه های اون کلاس رو تکمیل کنه حتما.مثال :&lt;?phpinterface a{    public function foo();}interface b{    public function bar();}interface c extends a, b{    public function baz();}class d implements c{    public function foo()    {    }    public function bar()    {    }    public function baz()    {    }}     نکته مهم اش اینه که در خط 12 کلاس c تعریف شده که از دو اینترفیس مشتق شده و درون اون 3 متد تعریف شده ، برای اینکه کلاس هایی که ازشون متشق گرفته دارای این 3 متد بودن.",
            "url": "/documentation/object-oriented-programming-in-php/interface"
          }
          ,
        
          "documentation-object-oriented-programming-in-php-polymorphism" :{
            "title": "چندریختی (Polymorphism)",
            "content": "مفهوم چند ریختی (Polymorphism)مفهوم چندریختی بیانگر توانایی کلاس فرزند در تعریف متدهایی است که در کلاس پایه موجود می‌باشند. برای نمونه دو کلاس «ماهی» و «گربه» را که هر دو آن‌ها از کلاسی به نام «حیوانات» ارث‌بری دارند را در نظر بگیرید؛ در کلاس حیوانات متدی با عنوان «غذا خوردن» که عملی مشترک در میان تمام حیوانات است وجود دارد ولی از آنجا که چگونگی انجام آن در ماهی و گربه متفاوت است، بنابراین هر دو این کلاس‌ها نیاز دارند تا متد «غذا خوردن» مخصوص خود را داشته باشند - در این جاست که این متد در کلاس‌های فرزند بازتعریف می‌شود، به این عمل ”Method Overriding“ گفته می‌شود. با Override کردن یک متد، متد کلاس پایه زیر سایه متد مشابه در کلاس فرزند قرار می‌گیرد و از نظر اشیا کلاس فرزند پنهان می‌شود.چندریختی (Polymorphism) در PHPبر اساس اصل چندریختی، متدهایی که در کلاس های مختلف عملیات یکسانی را انجام می دهند، باید نام یکسانی هم داشته باشند. توسعه دهنده می تواند با بهره گیری از این اصل کد اپلیکیشن خود را به صورت منسجم و با قابلیت استفاده ی آسان تعریف کند.یک مثال کاربردی کلاس هایی است که نمایانگر اشکال مختلف هندسی (نظیر مستطتیل، دایره و هشت گوشی) مختلف بوده که از نظر ظاهر، تعداد ضلع و همچنین فرمولی که مساحت بر اساس آن محاسبه می شود با یکدیگر فرق دارند. با این وجود تمامی این کلاس ها دارای یک ویژگی مشترک به نام مساحت هستند که باید محاسبه شود. اصل چندریختی بیان می دارد که در چنین شرایطی تمامی متدهایی که عملیات (یکسان) محاسبه ی مساحت شکل هندسی را انجام می دهند (مهم نیست برای کدام کلاس یا شکل هندسی) می بایست دارای اسمی یکسان باشند.به طور مثال، می توانیم متدی که مساحت را محاسبه می کند calcArea() نام گذاری کرده و سپس در هر کلاسی که نمایانگر یک شکل هندسی است، متدی با همین اسم که عملیات محاسبه ی مساحت را با توجه به ظاهر شکل هندسی انجام می دهد پیاده سازی یا فراخوانی کنیم. حال هر زمان که می خواهیم مساحت اشکال هندسی مختلف را محاسبه کنیم، متدی به نام calcArea() را فراخوانی می کنیم. بدین وسیله دیگر لازم نیست نگران جزئیات فنی و پیاده سازی عملیات محاسبه ی مساحت اشکال هندسی مختلف باشیم. به عبارت ساده تر کافی است برای محاسبه ی مساحت شکل هندسی مورد نظر (خواه مستطیل باشد خواه دایره) یک متد واحد به نام calcArea() را صدا بزنیم.نحوه ی پیاده سازی اصل چندریختی (polymorphism)به منظور پیاده سازی اصل چندریختی، می توانیم از کلاس های انتزاعی (abstract) یا interface ها یکی را انتخاب کنیم. به عبارت دیگر، برای اینکه مطمئن شویم کلاس های مشتق (فرزند) اصل چندریختی را پیاده سازی می کنند، می بایست بین کلاس های abstract یا interface ها یکی را انتخاب کنیم. در مثال زیر، interface هایی که shape نام گذاری شده اند، کلیه ی کلاس هایی که این interface را پیاده سازی می کنند مجاب به تعریف بدنه ی متدی به نام calcArea() می نمایند.interface Shape {  public function calcArea();}در مثال زیر، کلاس circle با تعریف بدنه و قرار دادن فرمول محسابه ی مساحت داخل ساختمان متد ()calcArea، مساحت شکل هندسی دایره را محاسبه کرده و در خروجی برمی گرداند.class Circle implements Shape {  private $radius;  public function __construct($radius)  {    $this -&gt; radius = $radius;  }  // calcArea calculates the area of circles  public function calcArea()  {    return $this -&gt; radius * $this -&gt; radius * pi();  }}کلاس Rectangle در مثال زیر نیز اینترفیس Shape را پیاده سازی کرده و متد calcArea() را فراخوانی می کند، اما این بار منطق متد نام برده را طوری می نویسد که مساحت شکل هندسی مستطیل را محسابه نموده و در خروجی برگرداند.class Rectangle implements Shape {  private $width;  private $height;  public function __construct($width, $height)  {    $this -&gt; width = $width;    $this -&gt; height = $height;  }  // calcArea calculates the area of rectangles    public function calcArea()  {    return $this -&gt; width * $this -&gt; height;  }}اکنون می توانیم از روی کلاس های غیر انتزاعی نام برده، به صورت زیر نمونه سازی کنیم:$circ = new Circle(3);$rect = new Rectangle(3,4);بنابراین تا زمانی که کلاس های ما اینترفیس Shape را پیاده سازی می کنند، دو آبجکت فوق مساحت را با فراخوانی متدی که هم نام با caclArea() (اعلان شده در اینترفیس Shape) است، محاسبه نموده و در خروجی برمی گردانند، خواه این شکل هندسی مستطیل باشد و خواه دایره.حال با فراخوانی متد calcArea() از آبجکت های $circ و $rect مساحت مستطیل و دایره محاسبه می شوند.echo $circ -&gt; calcArea();echo $rect -&gt; calcArea();خروجی:28.27433388230812",
            "url": "/documentation/object-oriented-programming-in-php/polymorphism"
          }
          ,
        
          "documentation-php7-performance" :{
            "title": "کارایی php7",
            "content": "کارایی php7 عکس های زیر در رابطه با مقایسه کارایی PHP 7 در برابر PHP 5.6 و HHVM 3.7 در برنامه های مبتنی بر PHP را نشان میدهدمقایسه عملکرد در Magento 1.9هنگام اجرای برنامه مگنتو متوجه می شوید که سرعت عملکرد PHP 7 نسبت به PHP 5.6 دو برابر بیشتر شده است.مقایسه عملکرد در Drupal 7هنگام اجرای فرآیندهای مختلف در دروپال  PHP 7  باز هم ثابت میکند که  دو برابر سریع تر از PHP 5.6 است.مقایسه عملکرد در Wordpress 3.6در وردپرس هم سرعت عملکرد PHP 7 دو برابر بیشتر از PHP 5.6 است .مقایسه زبان های پویا (daynamic)در وردپرس هم سرعت عملکرد PHP 7 دو برابر بیشتر از PHP 5.6 است .",
            "url": "/documentation/PHP7/performance"
          }
          ,
        
          "documentation-php7-scalar-type" :{
            "title": "Scalar type های جدید در php7",
            "content": "Scalar type های جدید در php7در نسخه 7 (php) ، یک قابلیت جدید به نام اعلان های نوع عددی (Scalar Type Declarations) ، معرفی شده است . اعلان های نوع عددی دو گزینه دارند :اجباری – حالت پیش فرض است و نیازی به مشخص کردن نیستسخت گیرانه – باید با صراحت تمام اشاره شودانواع داده شده برای پارامتر های عملکرد می تواند با حالت های بالا ، اجرا شود .intfloatboolstringinterfacesarraycallableمثال برای حالت اجباری :// Coercive mode   function sum(int ...$ints) {      return array_sum($ints);   }   print(sum(2, '3', 4.1));خروجی :9مثال برای حالت سخت گیرانه :// Strict mode   declare(strict_types=1);   function sum(int ...$ints) {      return array_sum($ints);   }   print(sum(2, '3', 4.1));خروجی :Fatal error: Uncaught TypeError: Return value of returnIntValue() must be of the type integer, float returned...",
            "url": "/documentation/PHP7/scalar-type"
          }
          ,
        
          "documentation-php7-return-type-declarations" :{
            "title": "مشخص کردن نوع داده بازگشتی",
            "content": "مشخص کردن نوع داده بازگشتیدر php 7 یک قابلیت بسیارخوب اضافه شده که میتوانیم نوع داده های برگشتی از متدهامون رو مشخص کنیم . نوع داده های برگشتی که می توانیم مشخص کنیم به شرح زیر است :intfloatboolstringinterfacesarraycallableمثال برای نوع بازگشتی معتبر :   declare(strict_types = 1);   function returnIntValue(int $value): int {      return $value;   }   print(returnIntValue(5));خروجی :5مثال برای نوع بازگشتی نامعتبر :   declare(strict_types = 1);   function returnIntValue(int $value): int {      return $value + 1.0;   }   print(returnIntValue(5));خروجی :Fatal error: Uncaught TypeError: Return value of returnIntValue() must be of the type integer, float returned...",
            "url": "/documentation/PHP7/return-type-declarations"
          }
          ,
        
          "documentation-php7-null-coalescing" :{
            "title": "عملگر Null coalescing",
            "content": "عملگر Null coalescing در 7 php  یک قابلیت جدید به نام  Null coalescing operator  (??) اضافه شده  که  برای جایگزینی عملیات سه گانه در ارتباط با عملکرد ()isset استفاده می شود. Null coalescing operator به این صورت عمل می کند که در عمق اول اگر متغیر وجود داشت و پوچ نبود خود را return می کند  درغیر این صورت مقدار عمق دوم خود را return می کند .برای مثال :// fetch the value of $_GET['user'] and returns 'not passed'   // if username is not passed   $username = $_GET['username'] ?? 'not passed';   print($username);   print(\"\");   // Equivalent code using ternary operator   $username = isset($_GET['username']) ? $_GET['username'] : 'not passed';   print($username);   print(\"\");   // Chaining ?? operation   $username = $_GET['username'] ?? $_POST['username'] ?? 'not passed';   print($username);خروجی :\tnot passed    not passed    not passed",
            "url": "/documentation/PHP7/null-coalescing"
          }
          ,
        
          "documentation-php7-spaceship" :{
            "title": "عملگر spaceship",
            "content": "عملگر spaceship در php 7 عملگر جدیدی به نام &nbsp;(&lt;=&gt;) Spaceship &nbsp;اضافه شده که برای مقایسه دو عبارت استفاده می شود , نتایج آن به این صورت است که اگر عبارت کوچکتر باشد 1-&nbsp;&nbsp;بر میگرداند , اگر برابر باشند 0 بر می گرداند و اگر بزرگتر باشد 1&nbsp;را بر میگرداند . برای مثال :    //integer comparison   print( 1 &lt;=&gt; 1);print(\"\");   print( 1 &lt;=&gt; 2);print(\"\");   print( 2 &lt;=&gt; 1);print(\"\");   print(\"\");   //float comparison   print( 1.5 &lt;=&gt; 1.5);print(\"\");   print( 1.5 &lt;=&gt; 2.5);print(\"\");   print( 2.5 &lt;=&gt; 1.5);print(\"\");   print(\"\");   //string comparison   print( \"a\" &lt;=&gt; \"a\");print(\"\");   print( \"a\" &lt;=&gt; \"b\");print(\"\");   print( \"b\" &lt;=&gt; \"a\");print(\"\");خروجی :        0       -1        1        0       -1        1        0       -1        1",
            "url": "/documentation/PHP7/spaceship"
          }
          ,
        
          "documentation-php7-constant-arrays" :{
            "title": "آرایه های ثابت",
            "content": "آرایه های ثابت آرایه های ثابت می توانند با استفاده از تابع ()define تعریف شوند .این کار در php 5.6  فقط با استفاده از const قابل انجام بود . برای مثال :   //define a array using define function   define('animals', [      'dog',      'cat',      'bird'   ]);   print(animals[1]);خروجی :cat",
            "url": "/documentation/PHP7/constant-arrays"
          }
          ,
        
          "documentation-php7-anonymous" :{
            "title": "کلاس های anonymous",
            "content": "کلاس های anonymousحالا کلاس های بی نام می توانند با استفاده از کلاس های جدید ، تعریف شوند . کلاس های بی نام می توانند در مکانی که پر از تعاریف کلاس است ، استفاده شوند .برای مثال :   interface Logger {      public function log(string $msg);   }   class Application {      private $logger;      public function getLogger(): Logger {         return $this-&gt;logger;      }      public function setLogger(Logger $logger) {         $this-&gt;logger = $logger;      }     }   $app = new Application;   $app-&gt;setLogger(new class implements Logger {      public function log(string $msg) {         print($msg);      }   });   $app-&gt;getLogger()-&gt;log(\"My first Log Message\");خروجی :My first Log Message",
            "url": "/documentation/PHP7/anonymous"
          }
          ,
        
          "documentation-php7-use-statement" :{
            "title": "گروه بندی use ها",
            "content": "گروه بندی use هادر PHP 7  می توان use  ها را گروهبندی نمود :برای مثال :   // Before PHP 7   use com\\tutorialspoint\\ClassA;   use com\\tutorialspoint\\ClassB;   use com\\tutorialspoint\\ClassC as C;   use function com\\tutorialspoint\\fn_a;   use function com\\tutorialspoint\\fn_b;   use function com\\tutorialspoint\\fn_c;   use const com\\tutorialspoint\\ConstA;   use const com\\tutorialspoint\\ConstB;   use const com\\tutorialspoint\\ConstC;   // PHP 7+ code   use com\\tutorialspoint\\{ClassA, ClassB, ClassC as C};   use function com\\tutorialspoint\\{fn_a, fn_b, fn_c};   use const com\\tutorialspoint\\{ConstA, ConstB, ConstC};",
            "url": "/documentation/PHP7/use-statement"
          }
          ,
        
          "documentation-solid-object-oriented-design-single-responsibility-principle" :{
            "title": "Single Responsibility Principle",
            "content": "مفهوم Single Responsibility PrincipleSRP  به طور خلاصه این مفهوم را می رساند :یک کلاس باید یک و تنها یک دلیل برای تغییر داشته باشد، به این معنی که یک کلاس فقط باید یک مسئولیت داشته باشدوقتی دو دلیل مختلف برای تغییر یک کلاس وجود داشته باشد بنابراین ممکن است دو تیم مختلف این کار را انجام دهند. در نهایت یک کلاس توسط دو تیم مختلف ویرایش می شود و این سبب می شود تا پروسه سوال و جواب برای هماهنگی و … طولانی شود.برای مثال ما تعدادی اشکال هندسی داریم (مربع و دایره و …) و می خواهیم مجموع محیط های این اشکال را حساب نماییم .class Circle {    public $radius;    public function __construct($radius) {        $this-&gt;radius = $radius;    }}class Square {    public $length;    public function __construct($length) {        $this-&gt;length = $length;    }}در کد بالا کلاس های اشکال مورد نظر خود را ایجاد کردیم و سپس  کلاس AreaCalculator را مطابق زیر جهت محاسبه مجموع محیط اشکال می نویسیم :class AreaCalculator {    protected $shapes;    public function __construct($shapes = array()) {        $this-&gt;shapes = $shapes;    }    public function sum() {        foreach($this-&gt;shapes as $shape) {            if(is_a($shape, 'Square')) {                $area[] = pow($shape-&gt;length, 2);            } else if(is_a($shape, 'Circle')) {                $area[] = pi() * pow($shape-&gt;radius, 2);            }        }        return array_sum($area);    }    public function output() {        return implode('', array(            \"\",                \"Sum of the areas of provided shapes: \",                $this-&gt;sum(),            \"\"        ));    }}برای استفاده از کلاس AreaCalculator، ما به سادگی نمونه ای از آن ایجاد و سپس آرایه ای از اشکال  را به آن منتقل می کنیم و سپس با استفاده از متد sum مجموع آنها را حساب می کنیم و در نهایت با استفاده از متد output نتیجه را در قالب HTML چاپ می کنیم .$shapes = array(    new Circle(2),    new Square(5),    new Square(6));$areas = new AreaCalculator($shapes);echo $areas-&gt;output();خب حالا مشکل چی هست ؟ مشکل اینجاست که اگر بخواهیم به جای خروجی HTML به ما json بدهد چیکار باید بکنیم ؟طبق اصل Single responsiblity principle که هر کلاس فقط باید یک کار انجام دهد عمل می کنیم .کلاس AreaCalculator فقط باید مجموعهای از اشکال ارائه شده را جمع کند و نباید نگرانی داشت که آیا کاربر میخواهد خروجی json یا HTML داشته باشد .بنابراین، برای رفع این مشکل شما می توانید یک کلاس به نام SumCalculatorOutputter ایجاد کنید و از این کلاس برای رسیدگی به هر منطقی جهت نمایش داده ها استفاده کنید:class SumCalculatorOutputter {    protected $calculator;    public function __constructor(AreaCalculator $calculator) {        $this-&gt;calculator = $calculator;    }    public function JSON() {        // logic to show json data    }     public function HTML() {            // logic to show html data     }}بنابراین تابع output() را از کلاس AreaCalculator حدف می نمائیم :class AreaCalculator {    protected $shapes;    public function __construct($shapes = array()) {        $this-&gt;shapes = $shapes;    }    public function sum() {        foreach($this-&gt;shapes as $shape) {            if(is_a($shape, 'Square')) {                $area[] = pow($shape-&gt;length, 2);            } else if(is_a($shape, 'Circle')) {                $area[] = pi() * pow($shape-&gt;radius, 2);            }        }        return array_sum($area);    }}بنابراین جهت محاسبه و سپس نمایش نتیجه بدین صورت عمل می کنیم :$shapes = array(    new Circle(2),    new Square(5),    new Square(6));$areas = new AreaCalculator($shapes);$output = new SumCalculatorOutputter($areas);echo $output-&gt;JSON();echo $output-&gt;HTML();",
            "url": "/documentation/solid-object-oriented-design/single-responsibility-principle"
          }
          ,
        
          "documentation-solid-object-oriented-design-open-closed-principle" :{
            "title": "Open Closed Principle",
            "content": "مفهوم Open Closed PrincipleOCP  به طور خلاصه این مفهوم را می رساند :اشیاء یا کلاس ها باید برای گسترش پیدا کردن باز ، اما برای ویرایش و تغییرات بسته شده باشند.جهت مفهوم این مطلب به متد ()sum کلاس AreaCalculator از مثال قبل توجه کنید :class AreaCalculator {    protected $shapes;    public function __construct($shapes = array()) {        $this-&gt;shapes = $shapes;    }    public function sum() {        foreach($this-&gt;shapes as $shape) {            if(is_a($shape, 'Square')) {                $area[] = pow($shape-&gt;length, 2);            } else if(is_a($shape, 'Circle')) {                $area[] = pi() * pow($shape-&gt;radius, 2);            }        }        return array_sum($area);    }}مشکل اینجاست که اگر ما بخواهیم اشکال دیگری اضافه کنیم  و  یا حتی  حدف کنیم باید  بلاک شرطی “if”  واقع در متد \"sum\" را ویرایش نمائیم.بنابراین با هر بار تغییر در کلاس \"AreaCalculator\"  مجبوریم  بررسی کنیم که آیا کد قبلی با تغییری که داده شد باز هم درست کار می کند و یا خیر ؟!!!.خب در اینجا ما باید Open closed principle  را اعمال کنیم، در حقیقت این قاعده به ما می گوید که یک کلاس برای تغییرات باید بسته باشد، یعنی ما اجازه تغییر کلاس برای افزودن امکانات جدید را نداریم، اما راه برای ایجاد Extension یا افزونه جدیدی برای کلاس باز است.برای برطرف کردن این مشکل فقط کافی است یک interface بسازیم و کلاس های مورد نظر که اشکال ما هستند را از این interface در واقع implements نموده و وظیفه محاسبه  محیط اشکال را به کلاس های خودشان انتقال دهیم.interface ShapeInterface {    public function area();}class Circle implements ShapeInterface{    public $radius;    public function __construct($radius) {        $this-&gt;radius = $radius;    }    public function area() {        return pi() * pow($this-&gt;radius, 2);    }}class Square implements ShapeInterface{    public $length;    public function __construct($length) {        $this-&gt;length = $length;    }    public function area() {        return pow($shape-&gt;length, 2);    }}در خط 1 اینترفیس ShapeInterface را تعریف کردیم و در ادامه کلاس هایمان را از این اینترفیس implements کردیم تا مجبور شود متد area را داشته باشد .سپس متد ()sum را مطالق زیر تغییر می دهیم :class AreaCalculator {    protected $shapes;    public function __construct($shapes = array()) {        $this-&gt;shapes = $shapes;    }    public function sum() {        foreach($this-&gt;shapes as $shape) {            if(is_a($shape, 'ShapeInterface')) {                $area[] = $shape-&gt;area();                continue;            }            throw new AreaCalculatorInvalidShapeException;        }        return array_sum($area);    }}دراینجا توانستیم اصل Open Close Principle را در کلاسمان ایجاد نماییم تا وابستگی کلاس AreaCalculator به اضافه و یا کم شدن اشکال مختلف را از بین ببریم .",
            "url": "/documentation/solid-object-oriented-design/open-closed-principle"
          }
          ,
        
          "documentation-solid-object-oriented-design-liskov-substitution-principle" :{
            "title": "Liskov Substitution Principle",
            "content": "مفهوم Liskov Substitution Principlelsp  به طور خلاصه این مفهوم را می رساند :به این معنی که هیچ کلاسی نباید رفتار کلاس والد را تغییر دهد. برای رعایت این اصل باید در نظر داشته باشیم که هر کلاسی میتواند از کلاس دیگر ارث بری کند به شرطی که رفتار کلاس والد را تغییر ندهند. (کلاسهای به ارث رفته (مشتق شده) باید بتوانند جایگزین کلاسهای اصلی شوند.)تعویض پذیری یک اصل در برنامه نویسی شی گرا است که در یک برنامه کامپیوتری ، اگر S یک زیرمجموعه از T باشد، پس از آن اشیاء نوع T ممکن است با اشیاء نوع S جایگزین شوند (یعنی یک شی از نوع T می تواند جایگزین هر هدف از یک زیر نوع S) بدون تغییر هیچ کدام از خواص مطلوب T . به طور رسمی، اصل تعویض لیسکوف ( LSP ) یک تعریف خاص از رابطه زیر مجموعه است ( زیرمجموعه قوی) که در ابتدا توسط باربارا لیسکوف در سخنرانی یک کنفرانس در سال 1987 با نام انتزاع داده ها و سلسله مراتب معرفی شد . این یک رابطه معنایی است و نه صرفا نحوی ، زیرا در نظر دارد قابلیت همکاری معنایی انواع در یک سلسله مراتب را تضمین کند.  باربارا لیسکوف و ژنیت وینگ این اصل را به صورت خلاصه در مقاله ای در سال 1994 فرموله کردند:Subtype Requirement: Let                     &#x03D5;        (        x        )              {\\displaystyle \\phi (x)}   be a property provable about objects                     x              {\\displaystyle x}   of type T. Then                     &#x03D5;        (        y        )              {\\displaystyle \\phi (y)}   should be true for objects                     y              {\\displaystyle y}   of type S where S is a subtype of T.جهت مفهوم این مطلب به مثال زیر توجه کنید :class Rectangle{    protected $width;    protected $height;    public function setHeight($height)    {        $this-&gt;height = $height;    }    public function getHeight()    {        return $this-&gt;height;    }    public function setWidth($width)    {        $this-&gt;width = $width;    }    public function getWidth()    {        return $this-&gt;width;    }    public function area()    {        return $this-&gt;width * $this-&gt;height;    }}کلاس Rectangle (مستطیل) را به عنوان یک کلاس پایه در نظر بگیرید. در دنیای واقعی شکل مربع هم نوعی مستطیل است. اما آیا در دنیای برنامه نویسی هم این موضوع صحیح است؟class Square extends Rectangle{    public function setHeight($value)    {        $this-&gt;width = $value;        $this-&gt;height = $value;    }    public function setWidth($value)    {        $this-&gt;width = $value;        $this-&gt;height = $value;    }}کلاس Square (مربع) از کلاس پایه ارث بری میکند. اما تفاوت این کلاس با کلاس پایه در این است که اگر هر یک از ابعاد طول و عرض مقدار دریافت کنند بعد دیگر نیز همان مقدار را خواهد داشت. یعنی اگر مقدار طول را 4 در نظر بگیریم, قطعا مقدار عرض نیز 4 خواهد بود.(خاصیت مربع)حالا قطعه کد زیر را در نظر بگیرید:function areaVerifier(Rectangle $obj){    echo 'area = '.$obj-&gt;area();}$obj1 = new Rectangle();$obj1-&gt;setWidth(5);$obj1-&gt;setHeight(4);areaVerifier($obj1);echo '---------------------------';$obj2 = new Square();$obj2-&gt;setWidth(5);$obj2-&gt;setHeight(4);areaVerifier($obj2);تابع areaVerifier ورودی از نوع Rectangle را دریافت کرده و طول و عرض آنرا مقدار دهی میکند. و در نهایت بررسی میکند که آیا مساحت درست حساب شده است یا خیر. در ظاهر همه چیز خیلی خوب کار خواهد کرد. اما وقتی کلاس Square که نوعی از Rectangle هست را به عنوان ورودی به تابع areaVerifier بدهیم پاسخ کمی تغییر می کند. وقتی به متد setHeight واقع در خط 15 می رسیم بر اساس کاری که Square انجام میدهد مقدار Width را نیز برابر ۴ قرار میدهد. بنابراین مساحت ۱۶ خواهد شد نه 20 (دقت کنید تابع areaVerifier شی از نوع Square دریافت کرده است اما رفتار از نوع شی Rectangle  انتظار می رود اما مشاهده می کنیم رفتار توابع setWidth و setHeight کلاس والد خود را تغییر داده است).// resultarea is correct ---- area = 20---------------------------Bad area! ---- area = 16خوب این به چه معنی است؟ به این معنی که ما نمیتوانیم کلاس پایه را با کلاس مشتق شده جایگزین کنیم و باز هم این معنی را میدهد که ما داریم اصل LSP را نقض میکنیم.این موضوع هدف اصلی LSP است و به ما آموزش میدهد که هنگام ارث بری از یک کلاس نباید رفتار کلاس والد را تغییر دهیم.اما راه حل چیست؟یک کلاس انتزاعی (abstract) را به شکل زیر ایجاد و سپس دوکلاس Square و Rectangle  را از آن مشتق میکنیم :&lt;?phpabstract class Shape{    protected $width;    protected $height;    abstract public function setHeight($height);    abstract public function setWidth($width);    public function getHeight()    {        return $this-&gt;height;    }    public function getWidth()    {        return $this-&gt;width;    }    public function area()    {        return $this-&gt;width * $this-&gt;height;    }}class Rectangle extends Shape{    public function setWidth($width)    {        $this-&gt;width = $width;    }    public function setHeight($height)    {        $this-&gt;height = $height;    }}class Square extends Shape{    public function setHeight($value)    {        $this-&gt;width = $value;        $this-&gt;height = $value;    }    public function setWidth($value)    {        $this-&gt;width = $value;        $this-&gt;height = $value;    }}همچنین تابع areaVerifier را مطابق زیر تغییر می دهیم :&lt;?phpfunction areaVerifier(Shape $obj){    echo 'area = '.$obj-&gt;area();}$obj1 = new Rectangle();$obj1-&gt;setWidth(5);$obj1-&gt;setHeight(4);areaVerifier($obj1);echo '---------------------------';$obj2 = new Square();$obj2-&gt;setWidth(5);$obj2-&gt;setHeight(4);areaVerifier($obj2);مشاهده می کنیم اشیا کلاس های Square و Rectangle مطابق رفتار مورد انتظارشان عمل می کنند.area = 20---------------------------area = 16",
            "url": "/documentation/solid-object-oriented-design/liskov-substitution-principle"
          }
          ,
        
          "documentation-solid-object-oriented-design-interface-segregation-principle" :{
            "title": "Interface Segregation Principle",
            "content": "مفهوم Interface Segregation Principlelsp  به طور خلاصه این مفهوم را می رساند :کلاینت‌ها نباید وابسته به متدهایی باشند که آنها را پیاده سازی نمی کنند و یا نباید به روش هایی که از آن ها استفاده نمی کنند وابسته باشند.مفهوم جدایی واسط ها در مهندسی نرم افزار بدین معنی است که هیچ شخص یا کدی نباید به ماژولی وابسته باشد که به آن احتیاج ندارد.برای استفاده از اینترفیس ها آنها را باید به اجزای کوچکتری تقسیم کرد. وقتی یک کلاس از یک اینترفیس بزرگ استفاده میکند ممکن است برخی از این متد ها در کلاس مورد نظر قابل استفاده نباشند. اما وقتی یک اینترفیس بزرگ به چند اینترفیس کوچک تقسیم می شود هر کلاس میتواند در صورتی که به اینترفیس خاصی نیاز داشت از آن استفاده نماید. با این امکان اگرچه تعداد اینترفیس ها بیشتر می شوند و ممکن است تکرار رخ دهد اما به دلیل اینکه منطق برنامه ما در اینترفیس ها اجرا نمی شود میتوان این مسئله را نادیده گرفت. در نهایت با رعایت این اصل امکان دیباگ و بررسی کد ها سرعت بیشتری خواهد داشت.تصویر زیر را در نظر بگیرید :‌اینترفیس VEHICLE برای کلاس های مرتبط با حمل و نقل ایجاد شده است. این در صورتی است که کلاس هایی مانند HighWay و BusStation که از این اینترفیس استفاده میکنند نیازی به متد هایی مانند stopRadio و یا brake ندارند. اصل چهارم SOLID تاکید بر این موضوع دارد که اینترفیس های بزرگ به اینترفیس های کوچک تر تبدیل شوند. تصویر زیر را در نظر بگیرید :در تصویر بالا به جای یک اینترفیس بزرگ دو اینترفیس کوچک ایجاد کردیم. گرچه برخی از متد ها تکرار شده اند اما همانطور که در ابتدای موضوع مطرح شد این اینترفیس ها قرار نیست منطق برنامه ما را تشکیل دهند لذا اصل اول SOLID را نقض نمی کند. استفاده از اینترفیس های کوچک به ما کمک میکند تا مشکلات را سریع تر شناسایی کنیم. راحت تر تست بگیریم و راحت تر کد های نوشته شده را درک کنیم.جهت مفهوم این مطلب به مثال زیر توجه کنید :interface Workable{    public function code();    public function test();}class Programmer implements Workable{    public function canCode()    {        return true;    }    public function code()    {        return 'coding';    }    public function test()    {        return 'testing in localhost';    }}class Tester implements Workable{    public function canCode()    {        return false;    }    public function code()    {         throw new Exception('Opps! I can not code');    }    public function test()    {        return 'testing in test server';    }}public function processCode(Workable $member){    if ($member-&gt;canCode()) {        $member-&gt;code();    }}در کد بالا اینترفیسی به نام Workable تعریف کردیم که دو کلاس Programmer و Tester  ملزم به پیاده سازی متدهای code و test  درون خود می باشند.به کلاس Tester  دقت کنید که این کلاس نیازی به پیاده سازی متد code ندارد اما به دلیل implements شدن از اینترفیس Workable مجبور به پیاده سازی آن شده است و در نتیجه در  تابع processCode واقع در خط 39 ابتدا بررسی می گردد که شی دریافت شده توانایی اجرای متد code  را دارد و یا خیر .اصل Interface segregation principle مخالف این قضیه هست و می گوید اگر متدهایی دارین که در برخی از کلاس ها لازم است و در برخی خیر , پس آنها را داخل interface های مختلفی بگذارید و هر موقع لازم شد آنها را implement کنید .بنابراین به جای اینترفیس Workable از دو اینترفیس Codeable و Testableاستفاده می کنیم و کلاس Programmer چون هر دو متد code و test بهره می برد از اینترفیس های  Codeable و Testable و کلاس Tester تنها از اینترفیس Testable پیاده سازی می گردند :interface Codeable{    public function code();}interface Testable{    public function test();}class Programmer implements Codeable, Testable{    public function code()    {        return 'coding';    }    public function test()    {        return 'testing in localhost';    }}class Tester implements Testable{    public function test()    {        return 'testing in test server';    }}public function processCode(Codeable $member){    $member-&gt;code();}",
            "url": "/documentation/solid-object-oriented-design/interface-segregation-principle"
          }
          ,
        
          "documentation-solid-object-oriented-design-dependency-inversion-principle" :{
            "title": "Dependency Inversion Principle",
            "content": "مفهوم Dependency Inversion Principle (اصل معکوس سازی وابستگی‌ها)DIP  به طور خلاصه این مفهوم را می رساند :ماژول های سطح بالا نباید به ماژول های سطح پایین وابسته باشند. بلکه باید هر دو به یک رابط (Abstraction) وابسته شوند.انتزاع‌ (Abstraction) نباید به جزئیات وابسته باشند. جزئیات باید به انتزاع وابسته باشند. (منظور از انتزاع دید کلی نسبت به یک شیء است مثلا وقتی ما می‌گوییم میز چیزی که در ذهن ما نقش می‌بندد یک شکل کلی است ولی وقتی می‌گوییم میز ناهارخوری دقیقا مشخص می‌کنیم که چه نوع میزی است. در نتیجه انتزاع یک دید کلی از یک شیء بحساب می‌آید)Dependency Inversion Principle (اصل معکوس سازی وابستگی‌ها) مفهومی است که وابستگی مستقیم کلاس های سطح بالا را به کلاس های سطح پایین منع میکند. به این منظور که اگر کلاس خاصی(high-level) که از کلاس های دیگر(low-level) استفاده می کند وابستگی مستقیمی با کلاس های low-level داشته باشد سبب بروز این مشکل خواهد شد که اگر کلاس low-level دیگری به مجموعه افزوده شود اجبارا کلاس high-level نیز بایستی تغییر کند. DIP برای حل این مشکل به وجود آمده است و این وابستگی باید معکوس شده و همچنین بر اساس Abstraction یا برای مثال استفاده از اینترفیس‌ها صورت گیرد.جهت مفهوم این مطلب به مثال زیر توجه کنید :&lt;?phpclass Mailer{    public function send($string)    {        // sending mail    }}class SendWelcomeMessage{    private $mailer;    public function __construct(Mailer $mailer)    {        $this-&gt;mailer = $mailer;    }    public function send_string($user_id)    {        $string = 'welcome user ' . $user_id;        $this-&gt;mailer-&gt;send($string);    }}در تکه کد بالا یک کلاس SendWelcomeMessage داریم و در آن یک تابع send_string که توسط آن پیغام خوش آمد گویی را برای کاربری با شماره $user_id میفرستد. این کلاس از یک کلاس Mailer استفاده میکند تا بتواند از تابع send آن ایمیل خود را بفرستد. پس الان یک کلاس SendWelcomeMessage داریم که به وسیله آن میتوانیم یک پیغام خوش آمد گویی را برای کاربران ایمیل کنیم.حال فرض کنید نیازمندی های پروژه عوض می شود و میخواهیم به جای ایمیل کردن این پیام، این پیام را SMS کنیم. قاعدتا بایستی بسیار از قسمت های کد بالا را تغییر داده و کد را دوباره بازنویسی کنیم.معکوس سازی وابستگی یا همان Dependency Inversion اینجا به کمک ما می آید. توجه کنید که کلاس SendWelcomeMessage به کلاس Mailer وابسته است. که این کار در معکوس سازی وابستگی ها خلاف قانون ماست. پس به تکه کد زیر نگاهی بیندازید:&lt;?phpInterface Sender{    public function send($string);}class Mailer implements Sender{    public function send($string)    {        // sending mail    }}class SMSer implements Sender{    public function send($string)    {        // sending SMS    }}class SendWelcomeMessage{    private $sender;    public function __construct(Sender $sender)    {        $this-&gt;sender = $sender;    }    public function send_string($user_id)    {        $string = 'welcome user ' . $user_id;        $this-&gt;sender-&gt;send($string);    }}در اینجا عملیات Refactoring انجام داده ایم. یعنی کد را به حالتی بازنویسی کرده ایم که از لحاظ مهندسی نرم افزار بهتر باشد. همان طور که میبینید کلاس SendWelcomeMessage دیگر به کلاس Mailer وابسته نیست در عوض به یک واسط(Interface) به اسم Sender وابسته است. دو کلاس دیگر هم داریم Mailer و SMSer که هر دوی آن ها از نوع Sender هستند. حال هر موقع که بخواهیم میتوانیم به کلاس SendWelcomeMessage بگوییم که از کدام کلاس استفاده کند.",
            "url": "/documentation/solid-object-oriented-design/dependency-inversion-principle"
          }
          ,
        
          "documentation-tdd-phpunit" :{
            "title": "ابزار PHP Unit",
            "content": " با استغاده از برنامه PHPUnit امکانات لازم جهت انجام مراحل تست واحد برای برنامه های PHP فراهم می گردد.نصب PHPUnitجهت نصب PHP unit  می توان از برنامه composer استفاده نمائیم . بنابراین دستور زیر را در ترمینال وارد نمائید تا مراحل نصب تکمیل گردد :$ composer global require phpunit/phpunitبرنامه بصورت global  نصب گرددید به این معنا که در تمامی پروژه ها و دایرکتوری ها می توان از این برنامه استفاده کرد. جهت اطمینان از صحت نصب، دستور زیر را در ترمینال وارد تا ورژن نصب شده نمایش داده شود :$ phpunit --vبسیار خب... می خواهیم از این قسمت به بعد مراحل تنظیمات و نوشتن تست را بصورت یک پروژه بیان کنیم. بنابراین دایرکتوری به نام myproject ایجاد و درون آن دایرکتوری دیگری به نام test  ایجادمی کنیم.همچنین چون ما از روش PSR-4  جهت لودینگ کلاس ها استفاده می کنیم بنابراین فایلی به نام composer.json  را در مسیر اصلی پروژه ایجاد و کد زیر را درون آن قرار دهید :{}سپس درون ترمینال دستور زیر را وارد تا پوشه vendor  ایجاد گردد :composer dumpتنظیمات PHP Unit  در پروژهجهت تنظیمات مورد نظرمان  از فایل phpunit.xml در شاخه اصلی پروژه استفاده می نمائیم. همانند کد زیر :&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?در کد بالا دو تنظیم انجام داده ایم که عبارتند از :با استفاده از ویژگی colors=\"true\" تعیین کردیم که نتایج آزمایش بصورت رنگی در ترمینال نمایش داده شودبا استفاده از تگ directory تعیین کردیم که مسیر فایل های تست ما درون پوشه test  در شاخه اصلی قرار دارند.ساختار و نام فایل تست در PHP Unitتمامی فایل های تست حتما باید با کلمه Test  به پایان برسد. همچنین جهت آشکار سازی فایل تست که متعلق به کدام قسمت از برنامه است بهتر است فایل ها و مسیرهای همنام در دایرکتوری تست ایجاد گردند. برای مثال چنانچه در پروژه داشته باشیم :foo.phpbar.phpController/baz.phpنام و مسیر فایل های تست ما بدینگونه خواهد بود :fooTest.phpbarTest.phpController/bazTest.phpنام کلاس درون فایل تست بهتر است همنام با نام فایل باشد.نام آزمون حتما باید با کلمه test بصورت حروف کوچک آغاز گردد.اسامی آزمون ها باید توصیفی از عملی باشد که مورد آزمایش قرار می گیرد و بهتر است بصورت اختصار و کوتاه نباشد تا بیانگر آزمایشی باشد که انجام می دهد. برای مثال چنانچه تابعی به نام ()verifyAccount داشته باشیم که عمل مطابقت رمز عبور را برای یک حساب کاربری انجام می دهد آنگاه می توانیم نام آزمون را اینطور انتخاب کنیم :()testVerifyAccountMatchesPasswordGivenسطح دسترسی متدهای آزمون باید از نوع public  باشند.کلاس آزمون باید گسترش یافته از PHPUnit_Framework_TestCase و یا هرکلاس دیگری که این وظیفه را برعهده دارد باشد.در کد زیر نمونه ای از یک آزمون را مشاهده می کنید :&lt;?phpnamespace Test;class StringUtils extends \\PHPUnit_Framework_TestCase{    public function testVerifyAccountMatchesPasswordGiven()    {    }}در کد بالا  آزمونی ایجاد کرده ایم که با توجه به نام آن به راحتی می توان فهمید که قرار است آزمونی درخصوص بررسی صحت درستی عملکرد متدی که تعداد حروف خاصی را در یک رشته شمارش می نماید را انجام دهد.",
            "url": "/documentation/TDD/phpunit"
          }
          ,
        
          "documentation-tdd-first-test" :{
            "title": "نوشتن اولین آزمون",
            "content": "  در این قسمت می خواهیم روند توسعه نرم افزار براساس TDD  را در قالب یک مثال بیان کنیم.می خواهیم قطعه کدی نوشته شود که با دریافت یک جمله تعداد کاراکتر مشخص شده ای را شمارش نماید.مفهوم Arrange, Act Assertالگوها در توسعه نرم افزار بسیار مفید هستند. آنها یک راه برای برداشتن یک مشکل پیچیده دارند و آن را به چند مرحله (کوچکتر و  ساده تر) تبدیل می کنند. بهترین الگوها، الگوهایی هستند که به آنها عادت و احساس راحتی کنید، به طوری که «شما به دنبال الگوی دیگری نیستید». در مورد نوشتن آزمونهای واحد ،الگوی Arrange, Act, Assert الگویی استاندارد و منطقی می باشد.AAA بیانگر سه مرحله برای ایجاد تست واحد می باشد:کلمه Arrange اشاره دارد به تنظیم تست شما با تعریف ورودی ها و خروجی های مورد انتظار .برای مثال مفهوم Arrange  را می توان در این تست با تعریف یک جمله انتخابی، کاراکتری که به دنبال آن هستیم و نتیجه مورد انتظار بصورت زیر پیاده سازی کرد :&lt;?phpnamespace Test;class StringUtils extends \\PHPUnit_Framework_TestCase{    public function testShouldBeAbleToCountNumberOfLettersInSimpleSentence()    {        $sentenceToScan = \"TDD is awesome!\";\t\t$characterToScanFor = 'e';\t\t$expectedResult = 2;    }}گام بعد در الگوی AAA عملیلت Act  می باشد. در این مرحله کلاس و متدی که قرار است بر روی آن تست شود را فراخوانی و نتیجه آن را دریافت می کنیم.برای مثال بالا نام کلاس را StringUtils انتخاب می کنیم همچنین به نظر نام findNumberOfOccurences نام توصیفی خوبی برای متدی که قرار است مورد آزمون قرار گیرد باشد. بنابراین در کد زیر در خط 12 نمونه ای از کلاس ایجاد و در خط 13 متد مورد نظر را فراخوانی و نتیجه آن را دریافت می کنیم (توجه کنید در عمل هنوز کلاس و متدهای مربوطه را ایجاد نکرده ایم):&lt;?phpnamespace Test;class StringUtils extends \\PHPUnit_Framework_TestCase{    public function testShouldBeAbleToCountNumberOfLettersInSimpleSentence()    {        $sentenceToScan = \"TDD is awesome!\";\t\t$characterToScanFor = 'e';\t\t$expectedResult = 2;\t\t$stringUtils = new StringUtils();\t\t$result = $stringUtils-&gt;findNumberOfOccurences($sentenceToScan, $characterToScanFor);    }} سرانجام به مرحله Assert می رسیم. در این مرحله ما تائید می کنیم که نتیجه دریافتی از متد مربوطه (result$) منطبق با مقدار مورد انتظار (expectedResult$) می باشد یا خیر. ما این کار را با استفاده از متدهای Assert انجام می دهیم. کلاس Assert یک کلاس استاتیک است که بخشی از چارچوب برنامه PHPUnit می باشد و مجموعه ای از روش های ارزیابی داده ها را فراهم می کند و سیگنال هایی را نشان می دهد که یک آزمون شکست خورده است و یا نتیجه غیرقابل حل بوده است.برای این مثال از متد assertEquals استفاده می کنیم که تساوی دو مقدار را بررسی می کند. چنانچه دو مقدار برابر نباشند برنامه PHPUnit  به ما می گوید که تست شکست خورده است واجرای آزمون با علت شکست گزارش داده شده و متوقف می گردد، در غیر اینصورت اجرای آزمون ادامه پیدا می کند. این به شما این امکان را می دهد تا چند آزمون را در یک آزمون انجام دهید :&lt;?phpnamespace Test;class StringUtils extends \\PHPUnit_Framework_TestCase{    public function testShouldBeAbleToCountNumberOfLettersInSimpleSentence()    {        $sentenceToScan = \"TDD is awesome!\";        $characterToScanFor = 'e';        $expectedResult = 2;        $stringUtils = new StringUtils();        $result = $stringUtils-&gt;findNumberOfOccurences($sentenceToScan, $characterToScanFor);        $this-&gt;assertEquals($expectedResult, $result);    }}مرحله اجرای تستتست آماده است، بنابراین اولین چیزی که می خواهیم انجام شود این است که سعی کنیم تستم را اجرا کنیم. این یک بخش کلیدی از گردش کار TDD است؛ یک تست را بنویسید و بلافاصله آن تست را اجرا کنید تا مشاهده کنیم تست شکست خورده است (و باید شکست بخورد). حقیقت یک تست شکست است، به خصوص شکستی که برای عملکردی نوشته شده است که هنوز کد نویسی نوشته نشده ،می تواند به ما اطلاعات فراوانی دهد.اگر من یک تست را برای یک عملکردی که هنوز وجود ندارد (کدنویسی نشده است) بنویسم و آن تست شکست بخورد، به من چند چیز را نشان می دهد :اول از همه می تواند به من این تائید (نه به معنای تضمین) را برساند که من آزمون را درست نوشته ام. زیرا اگر تست بلافاصله pass شود، به من این نتیجه را می رساند که قطعه عملکرد صحیح مورد نظر را تست نکرده ام (قطعه کد دیگری به اشتباه تست شده)، به دلیل اینکه عملکردی هنوز وجود ندارد و آزمون نباید pass شود.با مشاهده شکست بعد از اولین آزمون می توانم این اطمینان را حاصل کنم که کار من تکرار کار دیگری نیست. در بعضی موارد، به ویژه در پروژه های بزرگتر، ممکن است برای ایجاد قطعه ای از برنامه به اشتباه دوبار برنامه ریزی صورت گرفته باشد. در این مورد زمانیکه تست pass شود می تواند نشاندهنده این باشد که من دارم کاری که دیگری انجام داده را دوباره انجام می دهم.بسیار خب، تست مثال بالا را با اجرای دستور phpunit  در ترمینال اجرا می کنیم:همانطور که مشاهده می کنید دلیل شکست خوردن تست ما این است که کلاس StringUtils و متد findNumberOfOccurences یافت نشده است.بنابراین در این مرحله اقدام به ایجاد کلاس StringUtils و متد findNumberOfOccurences در پروژه خود می کنیم: با فرض اینکه بخواهیم کلاس هایمان درون دایرکتوری به نام classes  قرار گیرند این دایرکتوری را ایجاد و جهت شناسایی آن توسط composer با استفاده از روش PSR-4 فایل composer.json را همانند زیر تغییر داده سپس در ترمینال دستور composer dumpautoload را وارد می کنیم :{\t\"autoload\" : {\t\t\"psr-4\": {\t\t\t\"Classes\\\\\" : \"classes/\"\t\t}\t}}به دلیل اینکه کلاس StringUtils را در فضای نام Classes قرار داده ایم بنابراین جهت استفاده در تست خود خط 11 را مانند زیر تغییر دهید :&lt;?phpnamespace Test;class StringUtils extends \\PHPUnit_Framework_TestCase{    public function testShouldBeAbleToCountNumberOfLettersInSimpleSentence()    {        $sentenceToScan = \"TDD is awesome!\";        $characterToScanFor = 'e';        $expectedResult = 2;        $stringUtils = new \\Classes\\StringUtils();        $result = $stringUtils-&gt;findNumberOfOccurences($sentenceToScan, $characterToScanFor);        $this-&gt;assertEquals($expectedResult, $result);    }}جهت پیاده سازی کلاس StringUtils فایلی به نام stringUtils.php ایجاد و کدهای زیر را درون آن قرار دهید :   &lt;?phpnamespace Classes;class StringUtils{    public function __construct()    {    }    public function findNumberOfOccurences($sentenceToScan, $characterToScanFor)    {        return 2;    }}دستور phpunit را در ترمینال وارد کرده و نتیجه زیر را مشاهده می کنیم :همانطور که در کد بالا مشاهده می کنید ما ساده ترین پیاده سازی را جهت pass شدن آزمون انجام دادیم. بگذارید دوباره موضوع تست را بررسی کنیم:می خواهیم جمله \"!TDD is awesome\" بررسی و نتیجه شمارش تعداد کاراکتر \"e\" که برابر دو می باشد را برگرداند.بنابراین ساده ترین راه برای pass  شدن آزمون این بوده که عدد 2 برگشت داده شودبرای مثال بالا می توانیم بگوئیم مورد آزمون ما جهت صحت درستی برنامه ناکافی باشد. برای بهبود کیفیت کد، تست دیگری اضافه خواهیم کرد.می خواهیم صحت درستی شمارش تعداد کاراکتر n  در جمله  \"Once is unique, twice is a coincidence, three times is a pattern.\" که برابر 5 می باشد را بررسی کنیم. بنابراین تست دیگری اضافه می کنیم و خواهیم داشت :&lt;?phpnamespace Test;class StringUtils extends \\PHPUnit_Framework_TestCase{    public function testShouldBeAbleToCountNumberOfLettersInSimpleSentence()    {        $sentenceToScan = \"TDD is awesome!\";        $characterToScanFor = 'e';        $expectedResult = 2;        $stringUtils = new \\Classes\\StringUtils();        $result = $stringUtils-&gt;findNumberOfOccurences($sentenceToScan, $characterToScanFor);        $this-&gt;assertEquals($expectedResult, $result);    }    public function testShouldBeAbleToCountNumberOfLettersInAComplexSentence()    {        $sentenceToScan = \"Once is unique, twice is a coincidence, three times is a pattern.\";        $characterToScanFor = 'n';        $expectedResult = 5;        $stringUtils = new \\Classes\\StringUtils();        $result = $stringUtils-&gt;findNumberOfOccurences($sentenceToScan, $characterToScanFor);        $this-&gt;assertEquals($expectedResult, $result);    }}بعد از اجرای تست نتیجه زیر مشاهده می گردد :همانطور که در توضیحات دلیل شکست مشاهده می کنید، نتیجه مورد انتظار عدد 5 بوده درحالیکه عدد 2 برگردانده شده است.بنابراین ساده ترین کار برای pass  شدن آزمون این است که الگوریتمی برای شمارش تعداد کاراکتر یک جمله نوشته شود. بنابراین متد findNumberOfOccurences بصورت زیر تغییر می دهیم :&lt;?phpnamespace Classes;class StringUtils{    public function __construct()    {    }    public function findNumberOfOccurences($sentenceToScan, $characterToScanFor)    {        $numberOfOccurenes = 0;        for ($charIdx= 0; $charIdx &lt; strlen($sentenceToScan); $charIdx++) {            if ($sentenceToScan[$charIdx] == $characterToScanFor) {                $numberOfOccurenes++;            }        }        return $numberOfOccurenes;    }}این کد ممکن است بهینه ترین یا حتی بهترین راه برای حل این مشکل نباشد. اما در حال حاضر مهم نیست؛ این ساده ترین روش ممکنه است و ما به دنبال ساده ترین الگوریتم هایی هستیم که آزمون ها را انجام دهد. اگر دوباره تست های خود را اجرا کنیم می بینیم که این الگوریتم این نیاز را برآورده می کند:در ادامه مباحث پیشرفته تر TDD، با عملیات Refactoring این مثال را بازبینی خواهیم کرد.",
            "url": "/documentation/TDD/first-test"
          }
          ,
        
          "documentation-tdd-make-your-code-solid" :{
            "title": "نوشتن کد به سبک S.O.L.I.D",
            "content": "پیش از این ، با مطلبی تحت عنوان اصول S.O.L.I.D در طراحی شی گرا (OOD) با این مبحث آشنا شدیم و به تفکیک به بررسی 5 اصل اساسی آن پرداختیم.در این قسمت بررسی خواهیم کرد که چگونه کدهای S.O.L.I.D به ما در TDD کمک خواهد کرد. این اصول بطور خلاصه عبارتند از :SRP) Single responsibility principle)OCP) Open closed principle)LSP) Liskov substitution principle)ISP) Interface segregation principle)DIP) Dependency inversion principle)نقش SRP) Single responsibility principle) در TDDیک کلاس باید یک و تنها یک دلیل برای تغییر داشته باشد، به این معنی که یک کلاس فقط باید یک مسئولیت داشته باشد متدهایی که بیش از یک وظیفه را برعهده دارند، نیاز به آزمون هایی با پیچیدگی و دقت بیشتری دارند همچنین باید دقت شود به تنوع وظایف، ترتیب اجرای وظایف در آزمون حفظ گردد،  که آزمون را طولانی تر می کنند و برای درک و حفظ آن با مشکلات بیشتری مواجه خواهیم شد.به دلیل اینکه در SRP تنها یک وظیفه انجام می شود بنابراین نوشتن و درک آزمون ساده تر و همچنین درصورتیکه آزمون با شکست مواجه شد تنها نیاز به بررسی یک مکان برای بررسی عدم صحیح اجرا خواهد بود. نقش OCP) Open closed principle) در TDDنقش LSP) Liskov substitution principle) در TDDکلاسهای به ارث رفته (مشتق شده) باید بتوانند جایگزین کلاسهای اصلی شوند.LSP به ما کمک می کند که کدمان را با ایجاد جایگزین تست کنیم.نقش ISP) Interface segregation principle) در TDDتعداد بیشتری اینترفیس کوچک و خاص، بهتر از یک اینترفیس بزرگ (چاق) با متدهای بیشتر است.ISP  سبب می شود اینترفیس ها و کلاس ها کوچکتر شوند بنابراین تست های نوشته نیز ساده تر و دارای پیچیدگی کمتری باشند.نقش DIP) Dependency inversion principle) در TDDdependency-injection",
            "url": "/documentation/TDD/make-your-code-solid"
          }
          ,
        
          "documentation-tdd-dealing-with-defects" :{
            "title": "مفهوم Defects (نقص ها)",
            "content": " نقص ها (defects)نوع دیگری از نیازها (requerment) می باشند.یک نیاز توصیف می کند که نرم افزار شما چگونه باید کار کند، در حالی که یک نقص توصیف می کند که نرم افزار شما چگونه کار کرده است.A requirement describes how your software should work whereas a defect describes how your software should have workedهنگامی که از TDD استفاده می کنید و نرم افزار خود را براساس  تست هایی که خود بر اساس نیازها ساخته شده اند ایجاد می کنید، باید به تمامی آن نیازها در کد خود مراجعه کنید. اگر آن نیازها درست طراحی شده باشند،بنابراین وجود نقص به معنای وجود چیزی بیشتر از یک نیاز جدید نیست که یا شما از وجود این نیازها آگاه نبودید و یا نیازی بابت اصلاح نیازهای موجود می باشند.برای تشریح مفهوم نواقص به مثال بخش اولین آزمون خود برمی گردیم :دو آزمون ایجاد کرده بودیم که عبارت از :&lt;?phpnamespace Test;class StringUtils extends \\PHPUnit_Framework_TestCase{    public function testShouldBeAbleToCountNumberOfLettersInSimpleSentence()    {        $sentenceToScan = \"TDD is awesome!\";        $characterToScanFor = 'e';        $expectedResult = 2;        $stringUtils = new \\Classes\\StringUtils();        $result = $stringUtils-&gt;findNumberOfOccurences($sentenceToScan, $characterToScanFor);        $this-&gt;assertEquals($expectedResult, $result);    }    public function testShouldBeAbleToCountNumberOfLettersInAComplexSentence()    {        $sentenceToScan = \"Once is unique, twice is a coincidence, three times is a pattern.\";        $characterToScanFor = 'n';        $expectedResult = 5;        $stringUtils = new \\Classes\\StringUtils();        $result = $stringUtils-&gt;findNumberOfOccurences($sentenceToScan, $characterToScanFor);        $this-&gt;assertEquals($expectedResult, $result);    }}همچنین برنامه ای بر پایه الگوریتمی نوشتیم که با گرفتن یک جمله و کاراکتر، تعداد کاراکتر موجود در آن جمله را بر می گرداند :&lt;?phpnamespace Classes;class StringUtils{    public function __construct()    {    }    public function findNumberOfOccurences($sentenceToScan, $characterToScanFor)    {        $numberOfOccurenes = 0;        for ($charIdx= 0; $charIdx &lt; strlen($sentenceToScan); $charIdx++) {            if ($sentenceToScan[$charIdx] == $characterToScanFor) {                $numberOfOccurenes++;            }        }        return $numberOfOccurenes;    }}بعد از اینکه این کد برای مدت کوتاهی اجرایی شد، نقصی از سوی یکی از کاربران گزارش شد:کاربر به جای ارسال یک کاراکتر، عدد 0 را ارسال کرده بود که نتیجه 65 بر گردانده شدصرف نظر از اینکه چه نوع نیاز جدیدی داریم، گردش کار یکسان است، ابتدا یک تست بنویسید. در این مورد، من می خواهم یک تست بنویسیم که نشان دهد که رفتار فعلی که توسط نقص توصیف شده است، در حقیقت یک خطا است :public function testShouldShowZeroWhenZeroSend(){    $sentenceToScan = \"This test should return 0\";    $characterToScanFor = 0;    $expectedResult = 0;    $stringUtils = new \\Classes\\StringUtils();    $result = $stringUtils-&gt;findNumberOfOccurences($sentenceToScan, $characterToScanFor);    $this-&gt;assertEquals($expectedResult, $result);}همچنین جهت pass شدن این آزمون خط 12 را به کلاس StringUtils اضافه می کنیم :  &lt;?phpnamespace Classes;class StringUtils{    public function __construct()    {    }    public function findNumberOfOccurences($sentenceToScan, $characterToScanFor)    {        return 0;        $numberOfOccurenes = 0;        for ($charIdx= 0; $charIdx &lt; strlen($sentenceToScan); $charIdx++) {            if ($sentenceToScan[$charIdx] == $characterToScanFor) {                $numberOfOccurenes++;            }        }        return $numberOfOccurenes;    }}در حالی که ما این نقص را در تست درست کرده ایم، اما باعث شکسته شدن آزمون های قبل شدیم. اما باید توجه داشت بدون تست واحد فعلی من هیچ راهی آسان برای اثبات اینکه عملکرد فعلی  با تغییر من انجام شده ، وجود ندارد.",
            "url": "/documentation/TDD/dealing-with-defects"
          }
          ,
        
          "documentation-tdd-refactoring-basics" :{
            "title": "مفهوم Refactoring (بازسازی)",
            "content": "بازسازی یک گام مهم در TDD می باشد. شما اغلب عبارت \"Red، Green، Refactor\" را می شنوید. \"قرمز\" به این ایده اشاره دارد که ما یک تست را نوشتیم و ابتدا آن را شکست دادیم. هنگامی که کد برای گذراندن آزمون نوشته شده است، ما به قسمت \"سبز\" گردش کارمان رسیده ایم؛ کد ما کار می کند و نتایج با توجه به داده های داده شده و نتایج مورد انتظار باهم مطابقت مطابقت دارد. Refactoring گام نهایی است. به طور منظم، کد ما را بهبود می بخشد و آن را قابل خواندن، بهینه سازی، کار را ساده تر و انعطاف پذیر تر می کند.در بخش نقص ها باتوجه به نقصی که گذارش شده بود جهت رفع آن تغییری در کد برنامه داده بودیم تا این مورد رفع گردد. در این قسمت به مرحله بازنگری و بازسازی کد می رسیم . تغییراتی که داده می شود ممکن است بهترین راه حل نباشند اما باعث اجرای تمام آزمون ها می گردد :&lt;?phpnamespace Classes;class StringUtils{    public function __construct()    {    }    public function findNumberOfOccurences($sentenceToScan, $characterToScanFor)    {        $numberOfOccurenes = 0;        for ($charIdx= 0; $charIdx &lt; strlen($sentenceToScan); $charIdx++) {            if ($sentenceToScan[$charIdx] === $characterToScanFor) {                $numberOfOccurenes++;            }        }        return $numberOfOccurenes;    }}تغییری که داده شده بدین صورت است که دستور return 0 حذف، همچنین از عملگر === به جای == استفاده است.عملگر == مقدار دو متغیر را برای مساوی (معادل) بودن بررسی می‌کند و در صورت لزوم casting نیز صورت می‌دهد. === بررسی می‌کند که آیا مقدار دو متغیر دقیقا از یک type باشد و مقدار آن‌ها نیز دقیقا یکسان باشد.هم اینک با اجرای آزمون ها مشاهده می کنیم تمامی آزمون ها pass خواهند شد.",
            "url": "/documentation/TDD/refactoring-basics"
          }
          ,
        
          "documentation-tdd-mocking" :{
            "title": "Mock Objects و Stub Methods",
            "content": "اغلب نرم‌افزارهایی که شما توسعه می‌دهید، از کلاس‌ها و اجزا (component) مختلفی تشکیل می‌شوند. در حالت ایده‌آل، هر کلاس یا جزء برای اجرای وظایف خاصی طراحی می‌شوند که این همان Single Responsibility Principle است. این کلاس‌ها و اجزا در کنار هم یک برنامه (Application) را تشکیل می‌دهند. طبیعت خاص کلاس‌های و اجزای واحد، وابستگی را غیرقابل اجتناب می‌کند. رابط کاربر (User Interface) شما به کلاس‌های business domain وابسته است و خود کلاس‌های business domain به چیزهایی مثل انبارهای خارجی داده (دیتابیس، فایل سیستم)، وب سرویس یا منابع و سیستم‌های خارجی دیگر وابسته هستند.وقتی ما تستهای واحد را می نویسیم، لازم است به یاد داشته باشیم که این آزمون باید بر روی کد خاصی که ما می خواهیم آن را تست کنیم متمرکز شده باشد. به کد زیر توجه کنید:&lt;?phpnamespace Classes;class Payment{    const API_ID = 123456;    const TRANS_KEY = 'TRANSACTION KEY';    public function processPayment(array $paymentDetails)    {        $transaction = new \\AuthorizeNetAIM(self::API_ID, self::TRANS_KEY);        $transaction-&gt;amount = $paymentDetails['amount'];        $transaction-&gt;card_num = $paymentDetails['card_num'];        $transaction-&gt;exp_date = $paymentDetails['exp_date'];        $response = $transaction-&gt;authorizeAndCapture();        if ($response-&gt;approved) {            return $this-&gt;savePayment($response-&gt;transaction_id);        } else {            throw new \\Exception($response-&gt;error_message);        }    }    public function savePayment($transactionId)    {        // Logic for saving transaction ID to database or anywhere else would go in here        return true;    }}باتوجه به کد بالا متد processPayment  حاوی منطقی  برای پرداخت اینترنتی با اتصال به یک وب سرویس می باشد. همچنین متد savePayment (خط 25) وظیفه ذخیره سازی برخی از داده ها در  پایگاه داده را برعهده دارد.دلایل زیادی وجود دارد که نمی خواهیم از  کلاس واقعی و اجزای وابسته به آن در نوشتن تست استفاده کنیم :همانطور که ذکر شد، می خواهیم تست خود را بر روی قطعه کدی خاص (متدها و کلاس) متمرکز کنیم. این امر سبب می شود پیدا کردن نقص بسیار آسان تر و سریع تر گردددلیل دیگری که نمی خواهیم از کلاس های واقعی برای آزمون ها استفاده کنیم این است که آنها می توانند آزمون های غیر قابل پیش بینی را انجام دهند. اگر تست واحد من یک پایگاه داده را هر بار که اجرا می کنیم بخواند، انتظار می رود مقدار خاصی در پایگاه داده وجود داشته باشد که در رنج آن پایگاه داده باشیم. همین امر سبب می شود آزمون ما غیر قابل پیش بینی گردد.سرعت مسئله دیگر است. می خواهیم تست هایم سریع باشند. کدهایی که با یک منبع خارجی مانند یک پایگاه داده یا یک سرویس وب ارتباط برقرار می کنند با توجه به تاخیر در برقراری ارتباط با این منابع خارجی، سرعت اجرای آن  کاهش می یابد و زمانی که صدها آزمایش قرار است انجام شود سرعت اجرای تست نیز بسیار آهسته تر اجرا خواهند شد. Dependency Injection گام نخست برای راه حل این مشکل است. بنابراین شی transaction$ که از کلاس AuthorizeNetAIM  ایجاد شده در خارج از متد processPayment ایجاد و به عنوان آرگومان تزریق می گردد :&lt;?phpnamespace Classes;class Payment{    const API_ID = 123456;    const TRANS_KEY = 'TRANSACTION KEY';    public function processPayment(\\AuthorizeNetAIM $transaction , array $paymentDetails)    {        $transaction-&gt;amount = $paymentDetails['amount'];        $transaction-&gt;card_num = $paymentDetails['card_num'];        $transaction-&gt;exp_date = $paymentDetails['exp_date'];        $response = $transaction-&gt;authorizeAndCapture();        if ($response-&gt;approved) {            return $this-&gt;savePayment($response-&gt;transaction_id);        } else {            throw new \\Exception($response-&gt;error_message);        }    }    public function savePayment($transactionId)    {        // Logic for saving transaction ID to database or anywhere else would go in here        return true;    }}مفهوم Mocks و Stubs و Fakesاکنون به مبحث Mocking  می‌پردازیم. اگر واژه Mock را در فرهنگ لغت انگلیسی جستجو کنید, مفهوم “something made as an imitation” را مشاهده خواهید کرد. در واقع می‌توان اینطور تعریف کرد که Mocking به عملی تلقی می‌شود که یک چیز را به عنوان بدل ایجاد کنیم. Mocking در Unit Testing استفاده می‌شود. در هنگام  Test یک Object, ممکن است این Object به Object های دیگری وابسته و برای پردازش به مقادیری که این Object ها بر می‌گردانند, نیاز داشته باشد. در واقع هدف از Mocking این است که می‌خواهیم کد ها را بدون دخالت Dependency های آنها اجرا کنیم. هدف این است که Mocked Object ها, نقش Object های واقعی را ایفا کنند. متد و یا متد هایی در این Object با متغیر های معینی فراخوانی می‌شود و نتیجه مورد نظر را بر می‌گرداند.برای مثال فرض کنید به یک متد که برای احراز هویت کاربر است, مقادیر نام کاربری و رمز عبور را ارسال می‌کنیم و سپس مشخص می‌کنیم که اگر مقادیر وارد شده, با مقادیر مورد نظر برابر بودند,  سطح دسترسی خاصی را برگرداند. واضح است که این پردازش نیاز به ارتباط با پایگاه داده دارد. اما در اینجا تنها ورودی و خروجی متد را مشخص کرده‌ایم و پردازش متد مد نظر ما نیست. همین امر باعث می‌شود که حتی اگر متد دارای Dependency های خاصی است, در Testing مشکلی ایجاد نکند.روش دیگری نیز به نام Stubbing وجود دارد که در کنار Mocking قرار می‌گیرد. استفاده از Stubbing بسیار آسان است و هیچ Extra Dependency را در زمان Testing, دخالت نمی‌دهد. در واقع بخشی از کلاسی که مورد نیاز است را پیاده سازی می‌کنیم تا در زمان Testing بتوان از آن استفاده کرد. چه زمانی mock یک mock نیست؟ چه زمانی stub یا fake است؟ تفاوت این‌ها چیست؟ تفسیر Martin Fowler:Fakes: یک Fake شی‌ای است که یک مکانیزم داخلی دارد که نتایج قابل پیش‌بینی برمی‌گرداند، اما منطق کاری واقعی را پیاده‌سازی نکرده است.Stubs: یک Stub شی‌ای است که یک نتیجه مشخص را بر اساس یک سری ورودی مشخص برمی‌گرداند. اگر من به stub بگویم که هر وقت شخصی با شناسه 42 را خواستم عبارت John Doe را برگردان، stub همین کار را خواهد کرد. با این حال اگر من از stub بخواهم که شخصی با شناسه 41 را برگرداند، نمی‌داند چه کار باید بکند. بر حسب اینکه از کدام mocking framework استفاده کنم، stub یا exception ایجاد می‌کند یا یک شی null برمی‌گرداند. stub می‌تواند بعضی اطلاعات مربوط به نحوه فراخوانی مثل تعداد فراخوانی یا اینکه با چه داده‌هایی فراخوانی شده است را به یاد داشته باشد.Mocks: یک Mock یک نسخه پیچیده‌تر از stub است. همچنان مانند stub مقادیر را برمی‌گرداند، اما همچنین می‌تواند طوری برنامه‌ریزی شود که باید چند بار فراخوانی شود، به چه ترتیب یا به چه داده‌هایی.Spy: یک Spy نوعی mock است که یک شی را می‌گیرد و به جای ایجاد یک شی mock متدهایی که tester می‌خواهد mock کند را جایگزین می‌کند. Spy ها برای کدهای غیر TDD عالی هستند، اما باید خیلی مراقب باشید چرا که فراموش کردن چیزی که می‌بایست mock شود ممکن است نتایج فاجعه‌باری داشته باشد.Dummy: یک Dummy شی‌ای است که می‌تواند به عنوان جایگزین یک شی دیگر پاس داده شود اما استفاده نمی‌شود. Dummy ها در واقع placeholder محسوب می‌شوند.بر اساس تعاریف بالا، بعضی انواع mock ها هستند که خودمان می‌توانیم آن‌ها را ایجاد کنیم مثل Fake ها و Dummy ها. همچنین می‌توان یک stub ساده نوشت، اما زمان انجام این کار بر روی بهره‌وری من تاثیر خواهد داشت. خوشبختانه راه بهتری وجود دارد: استفاده از فریمورک‌های mocking. در ادامه از ابزار mock موجود در PHPunit استفاده خواهیم کرد.برای مثال بالا می خواهیم یک تست واحد نوشته شود. با توجه به کد بالا متد authorizeAndCapture در خط 15  عملیات اجرای تراکنش را برعهده داده دارد و نتیجه را بصورت یک شی در متغیر response$ ذخیره می نماید. چنانچه مقدار response-&gt;approved$ برابر true  باشد به معنای موفقیت آمیز بودن تراکنش بوده و مقدار transaction_id را در پایگاه داده ذخیره می نماید. بنابراین از متد assertTrue جهت بررسی نتایج استفاده می شود و کدی مانند زیر خواهیم داشت :&lt;?phpnamespace Test;class PaymentTest  extends \\PHPUnit_Framework_TestCase{    public function testProcessPaymentReturnsTrueOnSuccessfulPayment()    {        //Arrange        $paymentDetails = array(            'amount'   =&gt; 123.99,            'card_num' =&gt; '4111-1111-1111-1111',            'exp_date' =&gt; '03/2013'        );        $payment = new \\Classes\\Payment();        $authorizeNet = new \\AuthorizeNetAIM($payment::API_ID, $payment::TRANS_KEY);        //Act        $result = $payment-&gt;processPayment($authorizeNet, $paymentDetails);        //Assert        $this-&gt;assertTrue($result);    }}فهمیدن کد این تست باید خیلی ساده باشد. در قسمت Arrange  مبلغ و یک کارت پرداخت اینترنتی فرضی ایجاد کردیم و در قسمت Act , Assert  مراحل پرداخت مورد آزمون قرار می گیرد. زمانیکه آزمون را اجرا می کنیم به دلیل اینکه یا کلاس AuthorizeNetAIM پیاده سازی نشده است و یا نمی توان به دلایلی نظیر قطعی اینترنت و ... با این وب سرویس ارتباط برقرار کرد بنابراین مشاهده می کنیم که آزمون fail  می شود.بنابراین در اینجا از mock  جهت ایجاد یک شی غیر واقعی از کلاس AuthorizeNetAIM استفاده می نمائیم :&lt;?phpnamespace Test;class PaymentTest  extends \\PHPUnit_Framework_TestCase{    public function testProcessPaymentReturnsTrueOnSuccessfulPayment()    {        //Arrange        $paymentDetails = array(            'amount'   =&gt; 123.99,            'card_num' =&gt; '4111-1111-1111-1111',            'exp_date' =&gt; '03/2013'        );        $payment = new \\Classes\\Payment();        $authorizeNet = $this-&gt;getMock('\\AuthorizeNetAIM', array('__construct','authorizeAndCapture'), array($payment::API_ID, $payment::TRANS_KEY));        //Act        $result = $payment-&gt;processPayment($authorizeNet, $paymentDetails);        //Assert        $this-&gt;assertTrue($result);    }}همانطور که مشاهده می کنید در خط 17  با استفاده از متد getMock کلاسی به نام AuthorizeNetAIM ایجاد کردیم که دارای دو متد  construct__ و authorizeAndCapture می باشد. سپس نمونه ای از این کلاس را ایجاد کرده است. ساختار این متد بدین صورت است :public function getMock($originalClassName, $methods = array(), array $arguments = array(), $mockClassName = '', $callOriginalConstructor = TRUE, $callOriginalClone = TRUE, $callAutoload = TRUE, $cloneArguments = TRUE)همچنین می توان از متد getMockBuilder نیز استفاده کرد که بدین صورت پیاده سازی می شود :$authorizeNet = $this-&gt;getMockBuilder('\\AuthorizeNetAIM')                     -&gt;setMethods(array('__construct','authorizeAndCapture'))                     -&gt;setConstructorArgs(array($payment::API_ID, $payment::TRANS_KEY))                     -&gt;getMock();هم اکنون تست را بار دیگر اجرا می کنیم و نتیجه زیر مشاهده می گردد :این پیغام به این دلیل است که متدهایی که در کلاس های mock ایجاد می گردند همگی مقدار NULL  را برگشت می دهند. برای مثال چنانچه دستور زیر را اجرا کنید مشاهده می کنید که مقدار NULL  نمایش داده می شود :var_dump($authorizeNet-&gt;authorizeAndCapture()); بنابراین در اینجا از stub  جهت override کردن متد مورد نظر و تعیین  مقدار بازگشتی  خود استفاده می کنیم . بنابراین کدی مانند زیر خواهیم داشت :&lt;?phpnamespace Test;class PaymentTest  extends \\PHPUnit_Framework_TestCase{    public function testProcessPaymentReturnsTrueOnSuccessfulPayment()    {        //Arrange        $paymentDetails = array(            'amount'   =&gt; 123.99,            'card_num' =&gt; '4111-1111-1111-1111',            'exp_date' =&gt; '03/2013'        );        $payment = new \\Classes\\Payment();        $authorizeNet = $this-&gt;getMock('\\AuthorizeNetAIM', array('__construct','authorizeAndCapture'), array($payment::API_ID, $payment::TRANS_KEY));        $response = new \\stdClass();        $response-&gt;approved = true;        $response-&gt;transaction_id = 123;        $authorizeNet-&gt;expects($this-&gt;once())            -&gt;method('authorizeAndCapture')            -&gt;will($this-&gt;returnValue($response));        //Act        $result = $payment-&gt;processPayment($authorizeNet, $paymentDetails);        //Assert        $this-&gt;assertTrue($result);    }}می دانیم نوع بازگشتی authorizeAndCapture یک شی می باشد که دارای دو عنصر approved که حاوی مقدار boolean  و transaction_id که حاوی نوع داده int  می باشد. بنابراین ابتدا مقدار بازگشتی را در خطوط 19 الی 21 ایجاد کردیم.سپس در خطوط 23 الی 25 مقدار بازگشتی مورد نظر خود به متد authorizeAndCapture نسبت داده ایم.با استفاده از متد expects تعداد دفعاتی که انتظار می رود متد مورد نظر ما در کد اجرا شود را تعیین می کنیم که می تواند شامل once, any, never  باشد.با استفاده از متد method متد مورد نظر خود را تعیین می کنیم.و در آخر با استفاده از متدهای will , returnValue مقدار بازگشتی متد را مشخص می کنیم.هم اکنون با اجرای دوباره آزمون مشاهده خواهیم کرد که آزمون pass شده است.",
            "url": "/documentation/TDD/mocking"
          }
          ,
        
          "documentation-phpunit-writing-tests-for-phpunit" :{
            "title": "تست نویسی در PHPUnit",
            "content": "ساختار و نام فایل تست در PHP Unitتمامی فایل های تست حتما باید با کلمه Test  به پایان برسد. همچنین جهت آشکار سازی فایل تست که متعلق به کدام قسمت از برنامه است بهتر است فایل ها و مسیرهای همنام در دایرکتوری تست ایجاد گردند. برای مثال چنانچه در پروژه داشته باشیم :foo.phpbar.phpController/baz.phpنام و مسیر فایل های تست ما بدینگونه خواهد بود :fooTest.phpbarTest.phpController/bazTest.phpنام کلاس درون فایل تست بهتر است همنام با نام فایل باشد.نام آزمون حتما باید با کلمه test بصورت حروف کوچک آغاز گردد.اسامی آزمون ها باید توصیفی از عملی باشد که مورد آزمایش قرار می گیرد و بهتر است بصورت اختصار و کوتاه نباشد تا بیانگر آزمایشی باشد که انجام می دهد. برای مثال چنانچه تابعی به نام ()verifyAccount داشته باشیم که عمل مطابقت رمز عبور را برای یک حساب کاربری انجام می دهد آنگاه می توانیم نام آزمون را اینطور انتخاب کنیم :()testVerifyAccountMatchesPasswordGivenسطح دسترسی متدهای آزمون باید از نوع public  باشند.کلاس آزمون باید گسترش یافته از PHPUnit\\Framework\\TestCase و یا هرکلاس دیگری که این وظیفه را برعهده دارد باشد.در کد زیر نمونه ای از یک آزمون را مشاهده می کنید :&lt;?phpnamespace Test;use PHPUnit\\Framework\\TestCase;class StackTest extends TestCase{    public function testVerifyAccountMatchesPasswordGiven()    {    }}در کد بالا  آزمونی ایجاد کرده ایم که با توجه به نام آن به راحتی می توان فهمید که قرار است آزمونی درخصوص بررسی صحت درستی عملکرد متدی که تعداد حروف خاصی را در یک رشته شمارش می نماید را انجام دهد.مثال 1: تست عملیات آرایه با PHPUnit &lt;?phpnamespace Test;use PHPUnit\\Framework\\TestCase;class StackTest extends TestCase{    public function testPushAndPop()    {        $stack = [];        $this-&gt;assertEquals(0, count($stack));        array_push($stack, 'foo');        $this-&gt;assertEquals('foo', $stack[count($stack)-1]);        $this-&gt;assertEquals(1, count($stack));        $this-&gt;assertEquals('foo', array_pop($stack));        $this-&gt;assertEquals(0, count($stack));    }}نوشتن Test Dependencies (آزمون های وابسته به یکدیگر)آزمایشات واحد عمدتا به عنوان یک تمرین خوب برای کمک به توسعه دهندگان جهت شناسایی و رفع اشکالات، اصلاح کد و به عنوان مستند سازی برای یک واحد نرم افزار تحت آزمون نوشته می شود. برای دستیابی به این مزایا، تست واحد به طور ایده آل باید تمام مسیرهای ممکن در یک برنامه را پوشش دهد. اغلب وابستگی های ضمنی بین روش های تست وجود دارد، که در سناریوی اجرای آزمون مخفی شده است.مثال 2.2 نشان می دهد که چگونه از استفاده از متن @depends تعریف می کند تا وابستگی بین روش های تست را بیان کند.مثال 2 : استفاده از depends@ در حاشیه نویسی جهت بیان وابستگی ها&lt;?phpnamespace Test;use PHPUnit\\Framework\\TestCase;class Examples extends TestCase{    public function testEmpty()    {        $stack = [];        $this-&gt;assertEmpty($stack);        return $stack;    }    /**     * @depends testEmpty     */    public function testPush(array $stack)    {        array_push($stack, 'foo');        $this-&gt;assertEquals('foo', $stack[count($stack)-1]);        $this-&gt;assertNotEmpty($stack);        return $stack;    }    /**     * @depends testPush     */    public function testPop(array $stack)    {        $this-&gt;assertEquals('foo', array_pop($stack));        $this-&gt;assertEmpty($stack);    }}در مثال بالا، اولین تست، ()testEmpty یک آرایه جدید ایجاد می کند و با استفاده از متد assertEmpty اظهار می کند که آن خالی است و سپس به عنوان نتیجه آن را برگرداند. تست دوم، ()testPush به ()testEmpty بستگی دارد و نتیجه آن آزمون وابسته را به عنوان آرگومان دریافت می کند. همچنین در نهایت ()testPop به ()testPush وابستگی دارد.مثال 3: بهره گیری از وابستگی بین آزمایش ها &lt;?phpnamespace Test;use PHPUnit\\Framework\\TestCase;class DependencyFailureTest extends TestCase{    public function testOne()    {        $this-&gt;assertTrue(false);    }    /**     * @depends testOne     */    public function testTwo()    {    }}نتیجه خروجی :phpunit --verbose DependencyFailureTestPHPUnit 6.5.0 by Sebastian Bergmann and contributors.Time: 0 seconds, Memory: 5.00MbThere was 1 failure:1) DependencyFailureTest::testOneFailed asserting that false is true./home/sb/DependencyFailureTest.php:6There was 1 skipped test:1) DependencyFailureTest::testTwoThis test depends on \"DependencyFailureTest::testOne\" to pass.FAILURES!Tests: 1, Assertions: 1, Failures: 1, Skipped: 1.مثال 4: تست با چندین وابستگی &lt;?phpnamespace Test;use PHPUnit\\Framework\\TestCase;class Examples extends TestCase{    public function testProducerFirst()    {        $this-&gt;assertTrue(true);        return 'first';    }    public function testProducerSecond()    {        $this-&gt;assertTrue(true);        return 'second';    }    /**     * @depends testProducerFirst     * @depends testProducerSecond     */    public function testConsumer()    {        $this-&gt;assertEquals(            ['first', 'second'],            func_get_args()        );    }}نتیجه خروجی :phpunit --verbose MultipleDependenciesTestPHPUnit 6.5.0 by Sebastian Bergmann and contributors....Time: 0 seconds, Memory: 3.25MbOK (3 tests, 3 assertions)مفهوم Data Providersیک روش آزمون می تواند آرگومان های دلخواه را قبول کند. این آرگومان ها توسط dataProvider با استفاده از حاشیه نویسی dataProvider@ مشخص می شود.مثال 5: با استفاده از یک dataProvider که آرایه ای از آرایه ها را باز می گرداند&lt;?phpnamespace Test;use PHPUnit\\Framework\\TestCase;class Examples extends TestCase{    /**     * @dataProvider additionProvider     */    public function testAdd($a, $b, $expected)    {        $this-&gt;assertEquals($expected, $a + $b);    }    public function additionProvider()    {        return [            [0, 0, 0],            [0, 1, 1],            [1, 0, 1],            [1, 1, 2]        ];    }}نتیجه خروجی :phpunit DataTestPHPUnit 6.5.0 by Sebastian Bergmann and contributors....FTime: 0 seconds, Memory: 5.75MbThere was 1 failure:1) DataTest::testAdd with data set #3 (1, 1, 3)Failed asserting that 2 matches expected 3./home/sb/DataTest.php:9FAILURES!Tests: 4, Assertions: 4, Failures: 1.هنگام استفاده از تعداد زیادی از مجموعه داده ها مفید است که هر یک را با کلید رشته به جای پیش فرض عددی نامگذاری کنید.مثال 6: استفاده از dataProvider با مجموعه داده های نامگذاری شده&lt;?phpnamespace Test;use PHPUnit\\Framework\\TestCase;class Examples extends TestCase{    /**     * @dataProvider additionProvider     */    public function testAdd($a, $b, $expected)    {        $this-&gt;assertEquals($expected, $a + $b);    }    public function additionProvider()    {        return [            'adding zeros'  =&gt; [0, 0, 0],            'zero plus one' =&gt; [0, 1, 1],            'one plus zero' =&gt; [1, 0, 1],            'one plus one'  =&gt; [1, 1, 3]        ];    }}نتیجه خروجی :phpunit DataTestPHPUnit 6.5.0 by Sebastian Bergmann and contributors....FTime: 0 seconds, Memory: 5.75MbThere was 1 failure:1) DataTest::testAdd with data set \"one plus one\" (1, 1, 3)Failed asserting that 2 matches expected 3./home/sb/DataTest.php:9FAILURES!Tests: 4, Assertions: 4, Failures: 1.مثال 7: ترکیب depends وdataProvider در تست&lt;?phpnamespace Test;use PHPUnit\\Framework\\TestCase;class Examples extends TestCase{    public function provider()    {        return [['provider1'], ['provider2']];    }    public function testProducerFirst()    {        $this-&gt;assertTrue(true);        return 'first';    }    public function testProducerSecond()    {        $this-&gt;assertTrue(true);        return 'second';    }    /**     * @depends testProducerFirst     * @depends testProducerSecond     * @dataProvider provider     */    public function testConsumer()    {        $this-&gt;assertEquals(            ['provider1', 'first', 'second'],            func_get_args()        );    }}نتیجه خروجی :phpunit --verbose DependencyAndDataProviderComboTestPHPUnit 6.5.0 by Sebastian Bergmann and contributors....FTime: 0 seconds, Memory: 3.50MbThere was 1 failure:1) DependencyAndDataProviderComboTest::testConsumer with data set #1 ('provider2')Failed asserting that two arrays are equal.--- Expected+++ Actual@@ @@Array (-    0 =&gt; 'provider1'+    0 =&gt; 'provider2'1 =&gt; 'first'2 =&gt; 'second')/home/sb/DependencyAndDataProviderComboTest.php:31FAILURES!Tests: 4, Assertions: 4, Failures: 1.تست Testing Exceptionsمثال زیر نشان می دهد که چگونه از ()expectException در تست برای اینکه کدام استثنا رخ داده است استفاده می شود.مثال 8: نحوه استفاده از متد expectException&lt;?phpuse PHPUnit\\Framework\\TestCase;class ExceptionTest extends TestCase{    public function testException()    {        $this-&gt;expectException(InvalidArgumentException::class);    }}نتیجه خروجی :phpunit ExceptionTestPHPUnit 6.5.0 by Sebastian Bergmann and contributors.FTime: 0 seconds, Memory: 4.75MbThere was 1 failure:1) ExceptionTest::testExceptionExpected exception InvalidArgumentExceptionFAILURES!Tests: 1, Assertions: 1, Failures: 1.در ادامه متد ()expectException، متدهای ()expectExceptionCode و ()expectExceptionMessage و  ()expectExceptionMessageRegExp نیز جهت بررسی استثنائات مطرح شده توسط کد تحت آزمون مورد استفاده قرار می گیرند.مثال 9: نحوه استفاده از حاشیه نویسی  expectException@&lt;?php    /**     * @expectedException InvalidArgumentException     */    public function testException()    {    }نتیجه خروجی :phpunit ExceptionTestPHPUnit 6.5.0 by Sebastian Bergmann and contributors.FTime: 0 seconds, Memory: 4.75MbThere was 1 failure:1) ExceptionTest::testExceptionExpected exception InvalidArgumentExceptionFAILURES!Tests: 1, Assertions: 1, Failures: 1. تست PHP Errorsبه طور پیش فرض، PHPUnit اعلان های  errors, warnings,  notices که در هنگام اجرای یک آزمون ایجاد می شوند را به به یک استثنا تبدیل می کند.مثال 10:انتظار برای نمایش PHP error با استفاده از expectedException@&lt;?phpuse PHPUnit\\Framework\\TestCase;class ExpectedErrorTest extends TestCase{    /**     * @expectedException PHPUnit\\Framework\\Error     */    public function testFailingInclude()    {        include 'not_existing_file.php';    }}نتیجه خروجی :phpunit -d error_reporting=2 ExpectedErrorTestPHPUnit 6.5.0 by Sebastian Bergmann and contributors..Time: 0 seconds, Memory: 5.25MbOK (1 test, 1 assertion)مثال 11:تست مقدار بازگشتی کد که از خطاهای PHP استفاده می کند&lt;?phpnamespace Test;use PHPUnit\\Framework\\TestCase;class Examples extends TestCase{    public function testFileWriting() {        $writer = new FileWriter;        $this-&gt;assertFalse(@$writer-&gt;write('/is-not-writeable/file', 'stuff'));    }}class FileWriter{    public function write($file, $content) {        $file = fopen($file, 'w');        if($file == false) {            return false;        }        // ...    }}نتیجه خروجی :phpunit ErrorSuppressionTestPHPUnit 6.5.0 by Sebastian Bergmann and contributors..Time: 1 seconds, Memory: 5.25MbOK (1 test, 1 assertion)تست Outputگاهی اوقات شما می خواهید صحت اجرای یک روش، به عنوان مثال، یک خروجی مورد انتظار را بررسی کنید (به عنوان مثال از طریق echo یا print)مثال 12:تست خروجی یک تابع یا متد&lt;?phpnamespace Test;use PHPUnit\\Framework\\TestCase;class Examples extends TestCase{    public function testExpectFooActualFoo()    {        $this-&gt;expectOutputString('foo');        print 'foo';    }    public function testExpectBarActualBaz()    {        $this-&gt;expectOutputString('bar');        print 'baz';    }}نتیجه خروجی :phpunit OutputTestPHPUnit 6.5.0 by Sebastian Bergmann and contributors..FTime: 0 seconds, Memory: 5.75MbThere was 1 failure:1) OutputTest::testExpectBarActualBazFailed asserting that two strings are equal.--- Expected+++ Actual@@ @@-'bar'+'baz'FAILURES!Tests: 2, Assertions: 2, Failures: 1.جدول زیر لیست متدهای برای تست خروجی را نمایش می دهد:MethodMeaningvoid expectOutputRegex(string $regularExpression)Set up the expectation that the output matches a $regularExpression.void expectOutputString(string $expectedString)Set up the expectation that the output is equal to an $expectedString.bool setOutputCallback(callable $callback)Sets up a callback that is used to, for instance, normalize the actual output.string getActualOutput()Get the actual output.",
            "url": "/documentation/PHPUnit/writing-tests-for-phpunit"
          }
          ,
        
          "documentation-laravel-digging-deeper-collections" :{
            "title": "معرفی collections",
            "content": "کلاس Illuminate\\Support\\Collection یک بسته مناسب و راحت برای کار با آرایه های داده فراهم می کند. به عنوان مثال، کد زیر را بررسی کنید. از collect helper برای ایجاد نمونه جدید از آرایه استفاده می کنیم، عملگر strtoupper را بر روی هر عنصر اجرا می کنیم و سپس تمام عناصر خالی را حذف می کنیم:$collection = collect(['taylor', 'abigail', null])-&gt;map(function ($name) {    return strtoupper($name);})-&gt;reject(function ($name) {    return empty($name);});همانطور که می بینید، کلاس Collection به شما اجازه می دهد تا روش های زنجیره ای خود را برای انجام نقشه های روان  به کار ببرید. به طور كلي مجموعه ها تغيير نمي كنند، به اين معني كه هر متد Collection نمونه كاملا جديدي از کلاس Collection را باز مي گرداند.متد Creating Collectionsهمانطور که در بالا ذکر شد، collect helper نمونه جدید Illuminate\\Support\\Collection را برای آرایه دریافت شده بر می گرداند. بنابراین ایجاد یک collection  ساده است:$collection = collect([1, 2, 3]);نکته :نتایج کوئری های Eloquent همیشه نمونه ای از کلاس Collection را بر می گرداندتوسعه CollectionsCollection ها \"macroable\" هستند، به این معنی که می توان متد هایی را به کلاس Collection در زمان اجرا می توان اضافه نمود. برای مثال در کد زیر متدی به نام toUpper را به این مجموعه اضافه نمودیم :use Illuminate\\Support\\Str;Collection::macro('toUpper', function () {    return $this-&gt;map(function ($value) {        return Str::upper($value);    });});$collection = collect(['first', 'second']);$upper = $collection-&gt;toUpper();// ['FIRST', 'SECOND']به طور معمول جهت معرفی نمودن متد ایجاد شده از service provider استفاده شده تا در تمامی قسمت های برنامه قابل دسترس باشد.متد های موجود در کلاس Collectionمتدهای از پیش تعریف شده این کلاس عبارتند از :allaverageavgchunkcollapsecombineconcatcontainscontainsStrictcountcrossJoindddiffdiffAssocdiffKeysdumpeacheachSpreadeveryexceptfilterfirstfirstWhereflatMapflattenflipforgetforPagegetgroupByhasimplodeintersectintersectByKeysisEmptyisNotEmptykeyBykeyslastmacromakemapmapIntomapSpreadmapToGroupsmapWithKeysmaxmedianmergeminmodenthonlypadpartitionpipepluckpopprependpullpushputrandomreducerejectreversesearchshiftshuffleslicesortsortBysortByDescsplicesplitsumtaketaptimestoArraytoJsontransformunionuniqueuniqueStrictunlessunwrapvalueswhenwherewhereStrictwhereInwhereInStrictwhereNotInwhereNotInStrictwrapzipمتد allاین متد تمامی زیر آرایه های تعریف شده موجود در این مجموعه را بر می گرداند :collect([1, 2, 3])-&gt;all();// [1, 2, 3]متد avgاین متد معدل مقادیر را بر اساس کلید دریافتی بر می گرداند :$average = collect([['foo' =&gt; 10], ['foo' =&gt; 10], ['foo' =&gt; 20], ['foo' =&gt; 40]])-&gt;avg('foo');// 20$average = collect([1, 1, 2, 4])-&gt;avg();// 2متد chunkبا استفاده از این متد می توان مجموعه را به چند زیر مجموعه کوچکتر با سایز مشخص شده تقسیم کرد :$collection = collect([1, 2, 3, 4, 5, 6, 7]);$chunks = $collection-&gt;chunk(4);$chunks-&gt;toArray();// [[1, 2, 3, 4], [5, 6, 7]]از این روش می توان در view  ها زمان نمایش اطلاعات مانند زیر استفاده کرد :@foreach ($products-&gt;chunk(3) as $chunk)            @foreach ($chunk as $product)            {{ $product-&gt;name }}        @endforeach    @endforeachمتد collapseاین متد ، زیر آرایه های موجود را بصورت یک آرایه تبدیل می کند :$collection = collect([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);$collapsed = $collection-&gt;collapse();$collapsed-&gt;all();// [1, 2, 3, 4, 5, 6, 7, 8, 9]متد combineاین متد کلید آرایه یک مجموعه با مقدار آرایه مجموعه ای دیگر را ترکیب می کند :$collection = collect(['name', 'age']);$combined = $collection-&gt;combine(['George', 29]);$combined-&gt;all();// ['name' =&gt; 'George', 'age' =&gt; 29]متد concatاین متد آرایه دریافتی را به انتهای آرایه مجموعه اضافه می کند :$collection = collect(['John Doe']);$concatenated = $collection-&gt;concat(['Jane Doe'])-&gt;concat(['name' =&gt; 'Johnny Doe']);$concatenated-&gt;all();// ['John Doe', 'Jane Doe', 'Johnny Doe']متد containsاین متد وجود یک آیتم مشخص را در مجموعه بررسی می کند :$collection = collect(['name' =&gt; 'Desk', 'price' =&gt; 100]);$collection-&gt;contains('Desk');// true$collection-&gt;contains('New York');// falseشما همچنین می توانید یک key / value را همانند زیر ارسال نمایید :$collection = collect([    ['product' =&gt; 'Desk', 'price' =&gt; 200],    ['product' =&gt; 'Chair', 'price' =&gt; 100],]);$collection-&gt;contains('product', 'Bookcase');// falseهمچنین می توانید یک متد callback  را جهت بررسی داده های خود اجرا کنید :$collection = collect([1, 2, 3, 4, 5]);$collection-&gt;contains(function ($value, $key) {    return $value &gt; 5;});// falseمتد containsStrictاین متد همانند contains  می باشد و از \"strict\" comparisons جهت بررسی داده ها استفاده می کند.متد countتعداد آیتم های یک مجموعه را شمارش می کند :$collection = collect([1, 2, 3, 4]);$collection-&gt;count();// 4متد crossJoin این متد یک ماتریس را ایجاد می کند :$collection = collect([1, 2]);$matrix = $collection-&gt;crossJoin(['a', 'b']);$matrix-&gt;all();/*    [        [1, 'a'],        [1, 'b'],        [2, 'a'],        [2, 'b'],    ]*/$collection = collect([1, 2]);$matrix = $collection-&gt;crossJoin(['a', 'b'], ['I', 'II']);$matrix-&gt;all();/*    [        [1, 'a', 'I'],        [1, 'a', 'II'],        [1, 'b', 'I'],        [1, 'b', 'II'],        [2, 'a', 'I'],        [2, 'a', 'II'],        [2, 'b', 'I'],        [2, 'b', 'II'],    ]*/متد ddاین متد محتوای مجموعه را نمایش و روند اجرای برنامه را قطع میکند :$collection = collect(['John Doe', 'Jane Doe']);$collection-&gt;dd();/*    Collection {        #items: array:2 [            0 =&gt; \"John Doe\"            1 =&gt; \"Jane Doe\"        ]    }*/چنانچه بخواهیم روند اجرای برنامه متوقف نشود از متد dump  می توان استفاده کرد.متد diffاین متد مقدار آیتم های یک مجموعه را با مجموعه دیگر مقایسه و در صورت عدم وجود،  برگشت داده خواهند شد :$collection = collect([1, 2, 3, 4, 5]);$diff = $collection-&gt;diff([2, 4, 6, 8]);$diff-&gt;all();// [1, 3, 5]متد diffAssocاین متد همانند متد diff  می باشد با این تفاوت که براساس key / value عمل می کند :$collection = collect([    'color' =&gt; 'orange',    'type' =&gt; 'fruit',    'remain' =&gt; 6]);$diff = $collection-&gt;diffAssoc([    'color' =&gt; 'yellow',    'type' =&gt; 'fruit',    'remain' =&gt; 3,    'used' =&gt; 6]);$diff-&gt;all();// ['color' =&gt; 'orange', 'remain' =&gt; 6]متد diffKeysاین متد همانند متد diff  بوده با این تفاوت که براساس  کلید عمل می کند :$collection = collect([    'one' =&gt; 10,    'two' =&gt; 20,    'three' =&gt; 30,    'four' =&gt; 40,    'five' =&gt; 50,]);$diff = $collection-&gt;diffKeys([    'two' =&gt; 2,    'four' =&gt; 4,    'six' =&gt; 6,    'eight' =&gt; 8,]);$diff-&gt;all();// ['one' =&gt; 10, 'three' =&gt; 30, 'five' =&gt; 50]متد dumpاین متد محتویات مجموعه را بدون متوقف کردن اجرای برنامه متوقف می کند:$collection = collect(['John Doe', 'Jane Doe']);$collection-&gt;dump();/*    Collection {        #items: array:2 [            0 =&gt; \"John Doe\"            1 =&gt; \"Jane Doe\"        ]    }*/متد each  این متد هر بار یک آیتم از مجموعه دریافت و به متد callback جهت اجرای عملیات بر روی آن ارسال می کند :$collection = $collection-&gt;each(function ($item, $key) {    //});با برگشت مقدار false  می توان روند اجرای each  را متوقف کرد :$collection = $collection-&gt;each(function ($item, $key) {    if (/* some condition */) {        return false;    }});متد eachSpreadهمانند متد each  بوده و آیتم های تودرتو را به callback  ارسال می کند:$collection = collect([['John Doe', 35], ['Jane Doe', 33]]);$collection-&gt;eachSpread(function ($name, $age) {    //});متد everyاز این متد جهت تایید آزمون مشخص روی تمامی عناصر استفاده می شود :collect([1, 2, 3, 4])-&gt;every(function ($value, $key) {    return $value &gt; 2;});// falseمتد exceptاین متد تمامی عناصر به غیر از آیتم های مشخص شده را بر می گرداند :$collection = collect(['product_id' =&gt; 1, 'price' =&gt; 100, 'discount' =&gt; false]);$filtered = $collection-&gt;except(['price', 'discount']);$filtered-&gt;all();// ['product_id' =&gt; 1]متد filterاز این متد جهت فیلتر کردن عناصر با یک شرط معین استفاده می شود :$collection = collect([1, 2, 3, 4]);$filtered = $collection-&gt;filter(function ($value, $key) {    return $value &gt; 2;});$filtered-&gt;all();// [3, 4]اگر شرطی تعیین نشود تمامی عناصر معادل false حذف خواهند شد :$collection = collect([1, 2, 3, null, false, '', 0, []]);$collection-&gt;filter()-&gt;all();// [1, 2, 3]متد firstاولین آیتم که با گذر از شرط تعیین شده تایید شود برگشت داده خواهد شد :collect([1, 2, 3, 4])-&gt;first(function ($value, $key) {    return $value &gt; 2;});// 3چنانچه شرطی تعیین نگردد اولین آیتم برگشت داده خواهد شد :collect([1, 2, 3, 4])-&gt;first();// 1متد firstWhereمتد firstWhere اولین عنصر مجموعه که با کلید / ارزش معادل باشد باز می گرداند:$collection = collect([    ['name' =&gt; 'Regena', 'age' =&gt; 12],    ['name' =&gt; 'Linda', 'age' =&gt; 14],    ['name' =&gt; 'Diego', 'age' =&gt; 23],    ['name' =&gt; 'Linda', 'age' =&gt; 84],]);$collection-&gt;firstWhere('name', 'Linda');// ['name' =&gt; 'Linda', 'age' =&gt; 14]همچنین می توانید این متد را با یک اپراتور فراخوانی کنید :$collection-&gt;firstWhere('age', '&gt;=', 18);// ['name' =&gt; 'Diego', 'age' =&gt; 23]متد flatMapمتد flatmap داخل یک collection حلقه زده و سپس تک تک المان های آن را به تابع callback ارسال می کند. تابع بازفراخوان (callback) می تواند آیتم های ارسالی را ویرایش کرده و برگرداند. بدین وسیله مجموعه ای جدید از آیتم های ویرایش شده به عنوان خروجی برگردانده می شود. در نهایت آرایه ها flatten شده و در قالب یک آرایه ی واحد و تک بعدی در خروجی به نمایش در می آید:$collection = collect([    ['name' =&gt; 'Sally'],    ['school' =&gt; 'Arkansas'],    ['age' =&gt; 28]]);$flattened = $collection-&gt;flatMap(function ($values) {    return array_map('strtoupper', $values);});$flattened-&gt;all();// ['name' =&gt; 'SALLY', 'school' =&gt; 'ARKANSAS', 'age' =&gt; '28'];متد flattenاین متد یک مجموعه ی چند بعدی را به یک collection تک بعدی تبدیل می کند:$collection = collect(['name' =&gt; 'taylor', 'languages' =&gt; ['php', 'javascript']]);$flattened = $collection-&gt;flatten();$flattened-&gt;all();// ['taylor', 'php', 'javascript'];می توانید میزان \"depth\"  را به عنوان آرگومان ارسال کنیم :$collection = collect([    'Apple' =&gt; [        ['name' =&gt; 'iPhone 6S', 'brand' =&gt; 'Apple'],    ],    'Samsung' =&gt; [        ['name' =&gt; 'Galaxy S7', 'brand' =&gt; 'Samsung']    ],]);$products = $collection-&gt;flatten(1);$products-&gt;values()-&gt;all();/*    [        ['name' =&gt; 'iPhone 6S', 'brand' =&gt; 'Apple'],        ['name' =&gt; 'Galaxy S7', 'brand' =&gt; 'Samsung'],    ]*/متد flipاین متد کلید و مقدار را جا به جا می کند :$collection = collect(['name' =&gt; 'taylor', 'framework' =&gt; 'laravel']);$flipped = $collection-&gt;flip();$flipped-&gt;all();// ['taylor' =&gt; 'name', 'laravel' =&gt; 'framework']متد forgetاین متد آیتم را با استفاده از کلید مشخص شده حذف می کند :$collection = collect(['name' =&gt; 'taylor', 'framework' =&gt; 'laravel']);$collection-&gt;forget('name');$collection-&gt;all();// ['framework' =&gt; 'laravel']متد forPageروش forPage یک مجموعه جدید را که حاوی آیتم هایی است که در یک شماره صفحه مشخص وجود دارد، بازمی گرداند. این روش شماره صفحه را به عنوان اولین آرگومان و تعداد آیتم هایی که در هر صفحه نشان می دهد را  به عنوان آرگومان دوم می پذیرد :$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9]);$chunk = $collection-&gt;forPage(2, 3);$chunk-&gt;all();// [4, 5, 6]متد getاین متد یک آیتم را با استفاده از کلید آن باز می گرداند :$collection = collect(['name' =&gt; 'taylor', 'framework' =&gt; 'laravel']);$value = $collection-&gt;get('name');// taylorچنانچه کلیدی یافت نشود مقدار پیش فرض null  برگشت داده خواهد شد . می توان مقدار پیش فرض را مانند زیر تعیین کرد :$collection = collect(['name' =&gt; 'taylor', 'framework' =&gt; 'laravel']);$value = $collection-&gt;get('foo', 'default-value');// default-valueهمچنین می توانید مقدار پیش فرض را با استفاده از روش callback  همانند زیر تعیین کنید :$collection-&gt;get('email', function () {    return 'default-value';});// default-valueمتد groupByاین متد آیتم های مجموعه را با استفاده از کلید گروه بندی می کند :$collection = collect([    ['account_id' =&gt; 'account-x10', 'product' =&gt; 'Chair'],    ['account_id' =&gt; 'account-x10', 'product' =&gt; 'Bookcase'],    ['account_id' =&gt; 'account-x11', 'product' =&gt; 'Desk'],]);$grouped = $collection-&gt;groupBy('account_id');$grouped-&gt;toArray();/*    [        'account-x10' =&gt; [            ['account_id' =&gt; 'account-x10', 'product' =&gt; 'Chair'],            ['account_id' =&gt; 'account-x10', 'product' =&gt; 'Bookcase'],        ],        'account-x11' =&gt; [            ['account_id' =&gt; 'account-x11', 'product' =&gt; 'Desk'],        ],    ]*/همچنین می توانید از روش callback  در این متد همانند زیر استفاده نمایید :$grouped = $collection-&gt;groupBy(function ($item, $key) {    return substr($item['account_id'], -3);});$grouped-&gt;toArray();/*    [        'x10' =&gt; [            ['account_id' =&gt; 'account-x10', 'product' =&gt; 'Chair'],            ['account_id' =&gt; 'account-x10', 'product' =&gt; 'Bookcase'],        ],        'x11' =&gt; [            ['account_id' =&gt; 'account-x11', 'product' =&gt; 'Desk'],        ],    ]*/متد hasاین متد بررسی می کند که آیا کلید مورد نظر وجود دارد یا خیر :$collection = collect(['account_id' =&gt; 1, 'product' =&gt; 'Desk']);$collection-&gt;has('product');// trueمتد implodeمتد implode عناصر موجود را به هم اتصال می دهد. اگر مجموعه شامل آرایه ها یا اشیاء باشد، باید کلید عناصر و رشته \"اتصال\" که می خواهید بین مقادیر قرار دهید را تعیین نمایید:$collection = collect([    ['account_id' =&gt; 1, 'product' =&gt; 'Desk'],    ['account_id' =&gt; 2, 'product' =&gt; 'Chair'],]);$collection-&gt;implode('product', ', ');// Desk, Chairآگر مجموعه شامل یک آرایه ساده باشد فقط کافی است رشته \"اتصال\" را مشخص نمایید :collect([1, 2, 3, 4, 5])-&gt;implode('-');// '1-2-3-4-5'متد intersectاین متد هر آیتمی را از مجموعه اصلی که در آرایه یا مجموعه داده شده موجود نباشد حذف می کند. مجموعه نتیجه، کلیدهای اصلی مجموعه را حفظ خواهد کرد:$collection = collect(['Desk', 'Sofa', 'Chair']);$intersect = $collection-&gt;intersect(['Desk', 'Chair', 'Bookcase']);$intersect-&gt;all();// [0 =&gt; 'Desk', 2 =&gt; 'Chair']متد intersectByKeysمتد intersectByKeys هر کلید از مجموعه اصلی که در آرایه یا مجموعه داده شده موجود نباشد را حذف می کند:$collection = collect([    'serial' =&gt; 'UX301', 'type' =&gt; 'screen', 'year' =&gt; 2009]);$intersect = $collection-&gt;intersectByKeys([    'reference' =&gt; 'UX404', 'type' =&gt; 'tab', 'year' =&gt; 2011]);$intersect-&gt;all();// ['type' =&gt; 'screen', 'year' =&gt; 2009]متد isEmptyاین متد چنانچه مجموعه خالی باشد مقدار true در غیر اینصورت مقدار false  بر می گرداند:collect([])-&gt;isEmpty();// trueمتد isNotEmptyچنانچه مجموعه خالی نباشد مقدار true  در غیر اینصورت مقدار false  بر می گرداند :collect([])-&gt;isNotEmpty();// falseمتد keyByمتد keyBy مجموعه را با کلید داده شده کلید می کند. اگر چندین عنصر همان کلید را داشته باشند، تنها آخرین در مجموعه جدید ظاهر می شود:$collection = collect([    ['product_id' =&gt; 'prod-100', 'name' =&gt; 'Desk'],    ['product_id' =&gt; 'prod-200', 'name' =&gt; 'Chair'],]);$keyed = $collection-&gt;keyBy('product_id');$keyed-&gt;all();/*    [        'prod-100' =&gt; ['product_id' =&gt; 'prod-100', 'name' =&gt; 'Desk'],        'prod-200' =&gt; ['product_id' =&gt; 'prod-200', 'name' =&gt; 'Chair'],    ]*/همچنین می توانید از روش callback  در این متد استفاده نمایید :$keyed = $collection-&gt;keyBy(function ($item) {    return strtoupper($item['product_id']);});$keyed-&gt;all();/*    [        'PROD-100' =&gt; ['product_id' =&gt; 'prod-100', 'name' =&gt; 'Desk'],        'PROD-200' =&gt; ['product_id' =&gt; 'prod-200', 'name' =&gt; 'Chair'],    ]*/متد keysاین متد کلیه کلیدها را بر می گرداند:$collection = collect([    'prod-100' =&gt; ['product_id' =&gt; 'prod-100', 'name' =&gt; 'Desk'],    'prod-200' =&gt; ['product_id' =&gt; 'prod-200', 'name' =&gt; 'Chair'],]);$keys = $collection-&gt;keys();$keys-&gt;all();// ['prod-100', 'prod-200']متد lastآخرین آیتم که مصداق یک شرط مشخص باشد را برمی گرداند :collect([1, 2, 3, 4])-&gt;last(function ($value, $key) {    return $value &lt; 3;});// 2اگر شرطی تعیین نشود آخرین عنصر برگشت داده خواهد شد.collect([1, 2, 3, 4])-&gt;last();// 4متد macroبا استفتده از این متد می توان متدهای مورد نظر خود را به این کلاس اضافه نماییم.متد makeاین متد نمونه ای از کلاس collection  را ایجاد می کند.متد mapمتد map داخل مجموعه حلقه زده و سپس هر مقدار را به تابع callback پاس می دهد. callback می تواند آیتم را ویرایش نموده و آن را در خروجی برگرداند. بدین وسیله یک نمونه ی جدید از مجموعه، متشکل از آیتم های ویرایش شده ی collection اصلی در خروجی ارائه می شود:$collection = collect([1, 2, 3, 4, 5]);$multiplied = $collection-&gt;map(function ($item, $key) {    return $item * 2;});$multiplied-&gt;all();// [2, 4, 6, 8, 10]متد mapIntoروش mapInto  بر روی مجموعه حلقه می زند، و  یک نمونه جدید از کلاس داده شده با گذراندن مقدار به سازنده ایجاد می کند:class Currency{    /**     * Create a new currency instance.     *     * @param  string  $code     * @return void     */    function __construct(string $code)    {        $this-&gt;code = $code;    }}$collection = collect(['USD', 'EUR', 'GBP']);$currencies = $collection-&gt;mapInto(Currency::class);$currencies-&gt;all();// [Currency('USD'), Currency('EUR'), Currency('GBP')]متد mapSpreadThe mapSpread method iterates over the collection's items, passing each nested item value into the given callback. The callback is free to modify the item and return it, thus forming a new collection of modified items:$collection = collect([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);$chunks = $collection-&gt;chunk(2);$sequence = $chunks-&gt;mapSpread(function ($odd, $even) {    return $odd + $even;});$sequence-&gt;all();// [1, 5, 9, 13, 17]متد mapToGroupsThe mapToGroups method groups the collection's items by the given callback. The callback should return an associative array containing a single key / value pair, thus forming a new collection of grouped values:$collection = collect([    [        'name' =&gt; 'John Doe',        'department' =&gt; 'Sales',    ],    [        'name' =&gt; 'Jane Doe',        'department' =&gt; 'Sales',    ],    [        'name' =&gt; 'Johnny Doe',        'department' =&gt; 'Marketing',    ]]);$grouped = $collection-&gt;mapToGroups(function ($item, $key) {    return [$item['department'] =&gt; $item['name']];});$grouped-&gt;toArray();/*    [        'Sales' =&gt; ['John Doe', 'Jane Doe'],        'Marketing' =&gt; ['Johhny Doe'],    ]*/$grouped-&gt;get('Sales')-&gt;all();// ['John Doe', 'Jane Doe']متد mapWithKeysThe mapWithKeys method iterates through the collection and passes each value to the given callback. The callback should return an associative array containing a single key / value pair:$collection = collect([    [        'name' =&gt; 'John',        'department' =&gt; 'Sales',        'email' =&gt; 'john@example.com'    ],    [        'name' =&gt; 'Jane',        'department' =&gt; 'Marketing',        'email' =&gt; 'jane@example.com'    ]]);$keyed = $collection-&gt;mapWithKeys(function ($item) {    return [$item['email'] =&gt; $item['name']];});$keyed-&gt;all();/*    [        'john@example.com' =&gt; 'John',        'jane@example.com' =&gt; 'Jane',    ]*/متد maxمقدار max  را براساس کلید بر می گرداند :$max = collect([['foo' =&gt; 10], ['foo' =&gt; 20]])-&gt;max('foo');// 20$max = collect([1, 2, 3, 4, 5])-&gt;max();// 5متد medianاین متد مقدار متوسط مجموعه را بر می گرداند :$median = collect([['foo' =&gt; 10], ['foo' =&gt; 10], ['foo' =&gt; 20], ['foo' =&gt; 40]])-&gt;median('foo');// 15$median = collect([1, 1, 2, 4])-&gt;median();// 1.5متد mergeاین متد عناصر یک مجموعه را با مجموعه دیگر ادغام می کند :$collection = collect(['product_id' =&gt; 1, 'price' =&gt; 100]);$merged = $collection-&gt;merge(['price' =&gt; 200, 'discount' =&gt; false]);$merged-&gt;all();// ['product_id' =&gt; 1, 'price' =&gt; 200, 'discount' =&gt; false]مثال :$collection = collect(['Desk', 'Chair']);$merged = $collection-&gt;merge(['Bookcase', 'Door']);$merged-&gt;all();// ['Desk', 'Chair', 'Bookcase', 'Door']متد minمقدار min  را براساس کلید بر می گرداند :$min = collect([['foo' =&gt; 10], ['foo' =&gt; 20]])-&gt;min('foo');// 10$min = collect([1, 2, 3, 4, 5])-&gt;min();// 1متد modeمقدار mode  را براساس کلید بر می گرداند :$mode = collect([['foo' =&gt; 10], ['foo' =&gt; 10], ['foo' =&gt; 20], ['foo' =&gt; 40]])-&gt;mode('foo');// [10]$mode = collect([1, 1, 2, 4])-&gt;mode();// [1]متد nthThe nth method creates a new collection consisting of every n-th element:$collection = collect(['a', 'b', 'c', 'd', 'e', 'f']);$collection-&gt;nth(4);// ['a', 'e']You may optionally pass an offset as the second argument:$collection-&gt;nth(4, 1);// ['b', 'f']متد onlyآیتم های موجود در مجموعه را با کلیدهای مشخصی باز می گرداند:$collection = collect(['product_id' =&gt; 1, 'name' =&gt; 'Desk', 'price' =&gt; 100, 'discount' =&gt; false]);$filtered = $collection-&gt;only(['product_id', 'name']);$filtered-&gt;all();// ['product_id' =&gt; 1, 'name' =&gt; 'Desk']متد padروش pad آرایه را با مقدار داده شده پر می کند تا آرایه به اندازه مشخصی برسد. این روش مانند تابع array_pad PHP عمل می کند.برای قرار دادن به سمت چپ، شما باید اندازه منفی را مشخص کنید. در صورتی که مقدار مطلق اندازه داده شده کمتر یا برابر طول آرایه باشد، هیچ مکانی وجود نخواهد داشت:$collection = collect(['A', 'B', 'C']);$filtered = $collection-&gt;pad(5, 0);$filtered-&gt;all();// ['A', 'B', 'C', 0, 0]$filtered = $collection-&gt;pad(-5, 0);$filtered-&gt;all();// [0, 0, 'A', 'B', 'C']متد partitionاز این متد جهت جدا کردن آیتم هایی که مورد تایید شرط مورد نظر هستند و آیتم هایی که مورد تایید شرط نیستند استفاده می گردد:$collection = collect([1, 2, 3, 4, 5, 6]);list($underThree, $aboveThree) = $collection-&gt;partition(function ($i) {    return $i &lt; 3;});متد pipeاین متد نوع داده collection را به callback ارسال می کند و نتیجه آنرا بر می گرداند  :$collection = collect([1, 2, 3]);$piped = $collection-&gt;pipe(function ($collection) {    return $collection-&gt;sum();});// 6متد pluckاین متد تمام مقادیر به ازای کلید معین شده بر می گرداند :$collection = collect([    ['product_id' =&gt; 'prod-100', 'name' =&gt; 'Desk'],    ['product_id' =&gt; 'prod-200', 'name' =&gt; 'Chair'],]);$plucked = $collection-&gt;pluck('name');$plucked-&gt;all();// ['Desk', 'Chair']همچنین می توانید کلید خروجی را برای نتایج تعیین کنید :$plucked = $collection-&gt;pluck('name', 'product_id');$plucked-&gt;all();// ['prod-100' =&gt; 'Desk', 'prod-200' =&gt; 'Chair']متد popاین متد آخرین عنصر مجموعه را بر می گرداند:$collection = collect([1, 2, 3, 4, 5]);$collection-&gt;pop();// 5$collection-&gt;all();// [1, 2, 3, 4]متد prependاین متد یک آیتم را به ابتدای مجموعه اضافه می کند :$collection = collect([1, 2, 3, 4, 5]);$collection-&gt;prepend(0);$collection-&gt;all();// [0, 1, 2, 3, 4, 5]همچنین از آرگومان دوم به عنوان کلید استفاده نمایید :$collection = collect(['one' =&gt; 1, 'two' =&gt; 2]);$collection-&gt;prepend(0, 'zero');$collection-&gt;all();// ['zero' =&gt; 0, 'one' =&gt; 1, 'two' =&gt; 2]متد pullاین متد یک آیتم را با کلید تعیین شده بر می گرداند :$collection = collect(['product_id' =&gt; 'prod-100', 'name' =&gt; 'Desk']);$collection-&gt;pull('name');// 'Desk'$collection-&gt;all();// ['product_id' =&gt; 'prod-100']متد pushاین متد آیتم را به انتهای مجموعه اضافه می کند :$collection = collect([1, 2, 3, 4]);$collection-&gt;push(5);$collection-&gt;all();// [1, 2, 3, 4, 5]متد putاین متد یک عنصر را با کلید و مقدار مشخص در مجموعه قرار می دهد :$collection = collect(['product_id' =&gt; 1, 'name' =&gt; 'Desk']);$collection-&gt;put('price', 100);$collection-&gt;all();// ['product_id' =&gt; 1, 'name' =&gt; 'Desk', 'price' =&gt; 100]متد randomیک آیتم را بصورت تصادفی از مجموعه بر می گرداند :$collection = collect([1, 2, 3, 4, 5]);$collection-&gt;random();// 4 - (retrieved randomly)همچنین می توانید تعداد آیتم هایی که بصورت تصادفی برگشت دا می شوند را تعیین کنید :$random = $collection-&gt;random(3);$random-&gt;all();// [2, 4, 5] - (retrieved randomly)متد reduceاین متد مجموعه را به یک مقدار کاهش می دهد ، و نتیجه هر تکرار را به تکرار بعدی انتقال می دهد :$collection = collect([1, 2, 3]);$total = $collection-&gt;reduce(function ($carry, $item) {    return $carry + $item;});// 6مقدار  carry$ در تکرار اول null است؛ با این وجود، شما می توانید مقدار اولیه آن را تعیین نمایید:$collection-&gt;reduce(function ($carry, $item) {    return $carry + $item;}, 4);// 10متد rejectاین متد آیتم که مصداق شرط تعیین شده نباشند را بر می گرداند و برعکس متد filter  عمل می کند :$collection = collect([1, 2, 3, 4]);$filtered = $collection-&gt;reject(function ($value, $key) {    return $value &gt; 2;});$filtered-&gt;all();// [1, 2]متد reverseاین متد ترتیب عناصر مجموعه را با حفظ کلید آن معکوس می کند :$collection = collect(['a', 'b', 'c', 'd', 'e']);$reversed = $collection-&gt;reverse();$reversed-&gt;all();/*    [        4 =&gt; 'e',        3 =&gt; 'd',        2 =&gt; 'c',        1 =&gt; 'b',        0 =&gt; 'a',    ]*/متد searchمجموعه ای را برای مقدار داده شده جستجو می کند و کلید آن را در صورت وجود بر می گرداند. اگر مورد یافت نشد، مقدار false  را بر می گرداند :$collection = collect([2, 4, 6, 8]);$collection-&gt;search(4);// 1در حالت پیش فرض از روش \"loose\" جهت مقایسه و جستجو استفاده می شود برای جستجو با استفاده از روش \"strict مقدار true  را به عنوان آرگومان دوم ارسال می کنیم :$collection-&gt;search('4', true);// falseهمچنین می توانید از callback  در این متد استفاده نمایید :$collection-&gt;search(function ($item, $key) {    return $item &gt; 5;});// 2متد shiftعملیات shift  به راست را در مجموعه انجام می دهد و اولین عنصر را بر می گرداند :$collection = collect([1, 2, 3, 4, 5]);$collection-&gt;shift();// 1$collection-&gt;all();// [2, 3, 4, 5]متد shuffleعناصر موجود در مجموعه را بصورت تصادفی جا به جا می کند :$collection = collect([1, 2, 3, 4, 5]);$shuffled = $collection-&gt;shuffle();$shuffled-&gt;all();// [3, 2, 5, 1, 4] - (generated randomly)متد sliceتکه ای از مجموعه را با شروع از index معین شده بر می گرداند :$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);$slice = $collection-&gt;slice(4);$slice-&gt;all();// [5, 6, 7, 8, 9, 10]چنانچه بخواهیم تعداد نیز مشخص شود آن را به عنوان آرگومان دوم در متد مشخص می نماییم :$slice = $collection-&gt;slice(4, 2);$slice-&gt;all();// [5, 6]تکه بازگشتی به طور پیش فرض کلید را حفظ می کند. اگر نمی خواهید کلیدهای اصلی را حفظ کنید، میتوانید از متد values برای reindex استفاده کنید :متد sortاز این متد جهت مرتب سازی مجموعه استفاده می شود. مجموعه مرتب شده،  کلیدهای آرایه را حفظ می کند، بنابراین در این مثال از متد values برای reindex کلیدها استفاده کردیم :$collection = collect([5, 3, 1, 2, 4]);$sorted = $collection-&gt;sort();$sorted-&gt;values()-&gt;all();// [1, 2, 3, 4, 5]متد sortByاز این متد جهت مرتب سازی بر اساس کلید معین شده استفاده می گردد :$collection = collect([    ['name' =&gt; 'Desk', 'price' =&gt; 200],    ['name' =&gt; 'Chair', 'price' =&gt; 100],    ['name' =&gt; 'Bookcase', 'price' =&gt; 150],]);$sorted = $collection-&gt;sortBy('price');$sorted-&gt;values()-&gt;all();/*    [        ['name' =&gt; 'Chair', 'price' =&gt; 100],        ['name' =&gt; 'Bookcase', 'price' =&gt; 150],        ['name' =&gt; 'Desk', 'price' =&gt; 200],    ]*/همچنین می توان از روش callback در این متد استفاده نمایید :$collection = collect([    ['name' =&gt; 'Desk', 'colors' =&gt; ['Black', 'Mahogany']],    ['name' =&gt; 'Chair', 'colors' =&gt; ['Black']],    ['name' =&gt; 'Bookcase', 'colors' =&gt; ['Red', 'Beige', 'Brown']],]);$sorted = $collection-&gt;sortBy(function ($product, $key) {    return count($product['colors']);});$sorted-&gt;values()-&gt;all();/*    [        ['name' =&gt; 'Chair', 'colors' =&gt; ['Black']],        ['name' =&gt; 'Desk', 'colors' =&gt; ['Black', 'Mahogany']],        ['name' =&gt; 'Bookcase', 'colors' =&gt; ['Red', 'Beige', 'Brown']],    ]*/متد sortByDescهمانند متد sort می باشد با این تفاوت که بصورت نزولی مرتب می کند :متد spliceاین متد تکه ای از مجموعه را با شروع از index  مشخص  حذف و آن را بر می گرداند :$collection = collect([1, 2, 3, 4, 5]);$chunk = $collection-&gt;splice(2);$chunk-&gt;all();// [3, 4, 5]$collection-&gt;all();// [1, 2]همچنین می توانید تعداد آیتم ها را در آرگومان دوم مشخص نمایید :$collection = collect([1, 2, 3, 4, 5]);$chunk = $collection-&gt;splice(2, 1);$chunk-&gt;all();// [3]$collection-&gt;all();// [1, 2, 4, 5]در ادامه می توان در آرگومان سوم آیتم هایی را به عنوان جایگزین مشخص نمود :$collection = collect([1, 2, 3, 4, 5]);$chunk = $collection-&gt;splice(2, 1, [10, 11]);$chunk-&gt;all();// [3]$collection-&gt;all();// [1, 2, 10, 11, 4, 5]متد splitاز این متد جهت گروه بندی کردن مجموعه به تعداد مشخص استفاده می شود :$collection = collect([1, 2, 3, 4, 5]);$groups = $collection-&gt;split(3);$groups-&gt;toArray();// [[1, 2], [3, 4], [5]]متد sumاین متد مقادیر آیتم ها را جمع و باز می گرداند :collect([1, 2, 3, 4, 5])-&gt;sum();// 15همچنین می توانید کلید معینی جهت جمع کردن مقادیر آیتم ها مشخص نمایید :$collection = collect([    ['name' =&gt; 'JavaScript: The Good Parts', 'pages' =&gt; 176],    ['name' =&gt; 'JavaScript: The Definitive Guide', 'pages' =&gt; 1096],]);$collection-&gt;sum('pages');// 1272همچنین می توانید از روش callback در این متد استفاده نمایید :$collection = collect([    ['name' =&gt; 'Chair', 'colors' =&gt; ['Black']],    ['name' =&gt; 'Desk', 'colors' =&gt; ['Black', 'Mahogany']],    ['name' =&gt; 'Bookcase', 'colors' =&gt; ['Red', 'Beige', 'Brown']],]);$collection-&gt;sum(function ($product) {    return count($product['colors']);});// 6متد takeیک مجموعه جدید با تعداد مشخص آیتم را برمی گرداند :$collection = collect([0, 1, 2, 3, 4, 5]);$chunk = $collection-&gt;take(3);$chunk-&gt;all();// [0, 1, 2]همچنین می توانید از یک عدد منفی به عنوان آرگومان استفاده نمایید که در اینصورت از انتهای مجموعه آیتم ها برگردانده می شوند :$collection = collect([0, 1, 2, 3, 4, 5]);$chunk = $collection-&gt;take(-2);$chunk-&gt;all();// [4, 5]متد tapThe tap method passes the collection to the given callback, allowing you to \"tap\" into the collection at a specific point and do something with the items while not affecting the collection itself:collect([2, 4, 3, 1, 5])    -&gt;sort()    -&gt;tap(function ($collection) {        Log::debug('Values after sorting', $collection-&gt;values()-&gt;toArray());    })    -&gt;shift();// 1متد timesاین متد تعداد دفعات اجرای متد callback  تعیین شده را تعیین می کند و مقدار آن را در هر بار اجرا بر می گرداند :$collection = Collection::times(10, function ($number) {    return $number * 9;});$collection-&gt;all();// [9, 18, 27, 36, 45, 54, 63, 72, 81, 90]این متد می تواند در Eloquent models مانند زیر مفید باشد :$categories = Collection::times(3, function ($number) {    return factory(Category::class)-&gt;create(['name' =&gt; 'Category #'.$number]);});$categories-&gt;all();/*    [        ['id' =&gt; 1, 'name' =&gt; 'Category #1'],        ['id' =&gt; 2, 'name' =&gt; 'Category #2'],        ['id' =&gt; 3, 'name' =&gt; 'Category #3'],    ]*/متد toArrayعناصر موجود در مجموعه را بصورت آرایه بر می گرداند:$collection = collect(['name' =&gt; 'Desk', 'price' =&gt; 200]);$collection-&gt;toArray();/*    [        ['name' =&gt; 'Desk', 'price' =&gt; 200],    ]*/متد toJsonعناصر موجود در مجموعه را بصورت JSON  بر می گرداند :$collection = collect(['name' =&gt; 'Desk', 'price' =&gt; 200]);$collection-&gt;toJson();// '{\"name\":\"Desk\", \"price\":200}'متد transformاین متد مقادیر تغییر یافته بعد از عملیات صورت گرفته بر روی عناصر مجموعه در  callback را جایگزین عناصر اصلی مجموعه می کند :$collection = collect([1, 2, 3, 4, 5]);$collection-&gt;transform(function ($item, $key) {    return $item * 2;});$collection-&gt;all();// [2, 4, 6, 8, 10]اگر بخواهیم بر روی مجموعه اصلی تغییری حاصل نشود از متد map  استفاده نمایید.متد unionاین متد آرایه داده شده را به مجموعه اضافه می کند. اگر آرایه داده شده شامل کلید هایی است که قبلا در مجموعه اصلی هستند، مقادیر اصلی مجموعه ترجیح داده می شود:$collection = collect([1 =&gt; ['a'], 2 =&gt; ['b']]);$union = $collection-&gt;union([3 =&gt; ['c'], 1 =&gt; ['b']]);$union-&gt;all();// [1 =&gt; ['a'], 2 =&gt; ['b'], 3 =&gt; ['c']]متد uniqueاین متد تمام اقلام منحصر به فرد در مجموعه را باز می گرداند. مجموعه بازگشتی،  کلیدهای آرایه را نگه می دارد، بنابراین در این مثال از متد values برای بازنشانی کلید استفاده می کنیم:$collection = collect([1, 1, 2, 2, 3, 4, 2]);$unique = $collection-&gt;unique();$unique-&gt;values()-&gt;all();// [1, 2, 3, 4]هنگام استفاده با آرایه های تودرتو و یا اشیاء ، می توانید کلید مورد استفاده برای تعیین منحصر به فرد بودن را تعیین کنید:$collection = collect([    ['name' =&gt; 'iPhone 6', 'brand' =&gt; 'Apple', 'type' =&gt; 'phone'],    ['name' =&gt; 'iPhone 5', 'brand' =&gt; 'Apple', 'type' =&gt; 'phone'],    ['name' =&gt; 'Apple Watch', 'brand' =&gt; 'Apple', 'type' =&gt; 'watch'],    ['name' =&gt; 'Galaxy S6', 'brand' =&gt; 'Samsung', 'type' =&gt; 'phone'],    ['name' =&gt; 'Galaxy Gear', 'brand' =&gt; 'Samsung', 'type' =&gt; 'watch'],]);$unique = $collection-&gt;unique('brand');$unique-&gt;values()-&gt;all();/*    [        ['name' =&gt; 'iPhone 6', 'brand' =&gt; 'Apple', 'type' =&gt; 'phone'],        ['name' =&gt; 'Galaxy S6', 'brand' =&gt; 'Samsung', 'type' =&gt; 'phone'],    ]*/همچنین می توانید از callback  در این متد استفاده نمایید :$unique = $collection-&gt;unique(function ($item) {    return $item['brand'].$item['type'];});$unique-&gt;values()-&gt;all();/*    [        ['name' =&gt; 'iPhone 6', 'brand' =&gt; 'Apple', 'type' =&gt; 'phone'],        ['name' =&gt; 'Apple Watch', 'brand' =&gt; 'Apple', 'type' =&gt; 'watch'],        ['name' =&gt; 'Galaxy S6', 'brand' =&gt; 'Samsung', 'type' =&gt; 'phone'],        ['name' =&gt; 'Galaxy Gear', 'brand' =&gt; 'Samsung', 'type' =&gt; 'watch'],    ]*/متد uniqueStrictهمانند متد unique  عمل می کند با این تفاوت که از روش  \"strict\"  در مقایسه های خود استفاده می کند.متد unlessاین متد callback  مشخص شده را اجرا می کند مگر اینگه آرگومان اول true  باشد.$collection = collect([1, 2, 3]);$collection-&gt;unless(true, function ($collection) {    return $collection-&gt;push(4);});$collection-&gt;unless(false, function ($collection) {    return $collection-&gt;push(5);});$collection-&gt;all();// [1, 2, 3, 5]این متد عکس متد when  عمل می کند.متد unwrapThe static unwrap method returns the collection's underlying items from the given value when applicable:Collection::unwrap(collect('John Doe'));// ['John Doe']Collection::unwrap(['John Doe']);// ['John Doe']Collection::unwrap('John Doe');// 'John Doe'متد valuesاین متد کلیدها را بصورت اعداد صحیح متوالی باز نشانی می کند :$collection = collect([    10 =&gt; ['product' =&gt; 'Desk', 'price' =&gt; 200],    11 =&gt; ['product' =&gt; 'Desk', 'price' =&gt; 200]]);$values = $collection-&gt;values();$values-&gt;all();/*    [        0 =&gt; ['product' =&gt; 'Desk', 'price' =&gt; 200],        1 =&gt; ['product' =&gt; 'Desk', 'price' =&gt; 200],    ]*/متد whenاین متد callback  مورد نظر را زمانیکه آرگومان اول برابر true  باشد را اجرا می کند :$collection = collect([1, 2, 3]);$collection-&gt;when(true, function ($collection) {    return $collection-&gt;push(4);});$collection-&gt;when(false, function ($collection) {    return $collection-&gt;push(5);});$collection-&gt;all();// [1, 2, 3, 4]این متد عکس متد unless  عمل می کند.متد whereاین متد عملیات filter  را براساس key /value  اعمال می کند :$collection = collect([    ['product' =&gt; 'Desk', 'price' =&gt; 200],    ['product' =&gt; 'Chair', 'price' =&gt; 100],    ['product' =&gt; 'Bookcase', 'price' =&gt; 150],    ['product' =&gt; 'Door', 'price' =&gt; 100],]);$filtered = $collection-&gt;where('price', 100);$filtered-&gt;all();/*    [        ['product' =&gt; 'Chair', 'price' =&gt; 100],        ['product' =&gt; 'Door', 'price' =&gt; 100],    ]*/متد whereStrictاین متد همانند متد where  بوده با این تفاوت که از روش مقایسه \"strict\" استفاده می کند :متد whereInاین متد همانند متد where  بوده با این تفاوت که مقادیر را می تواند بصورت آرایه دریافت کند :$collection = collect([    ['product' =&gt; 'Desk', 'price' =&gt; 200],    ['product' =&gt; 'Chair', 'price' =&gt; 100],    ['product' =&gt; 'Bookcase', 'price' =&gt; 150],    ['product' =&gt; 'Door', 'price' =&gt; 100],]);$filtered = $collection-&gt;whereIn('price', [150, 200]);$filtered-&gt;all();/*    [        ['product' =&gt; 'Bookcase', 'price' =&gt; 150],        ['product' =&gt; 'Desk', 'price' =&gt; 200],    ]*/متد whereInStrictاین متد همانند متد where  بوده با این تفاوت که از روش مقایسه \"strict\" استفاده می کند :متد whereNotInاین متد عکس متد where  عمل می کند و مقادیری که در آرایه تعیین شده نباشند را بر می گرداند :$collection = collect([    ['product' =&gt; 'Desk', 'price' =&gt; 200],    ['product' =&gt; 'Chair', 'price' =&gt; 100],    ['product' =&gt; 'Bookcase', 'price' =&gt; 150],    ['product' =&gt; 'Door', 'price' =&gt; 100],]);$filtered = $collection-&gt;whereNotIn('price', [150, 200]);$filtered-&gt;all();/*    [        ['product' =&gt; 'Chair', 'price' =&gt; 100],        ['product' =&gt; 'Door', 'price' =&gt; 100],    ]*/متد whereNotInStrictاین متد همانند متد whereNotIn  بوده با این تفاوت که از روش مقایسه \"strict\" استفاده می کند :متد wrapThe static wrap method wraps the given value in a collection when applicable:$collection = Collection::wrap('John Doe');$collection-&gt;all();// ['John Doe']$collection = Collection::wrap(['John Doe']);$collection-&gt;all();// ['John Doe']$collection = Collection::wrap(collect('John Doe'));$collection-&gt;all();// ['John Doe']متد zipمتد zip() مقادیر آرایه ی ورودی را با مقادیر موجود در مجموعه در اندیس منطبق (که دارای شماره ی مکان قرارگیری یکسان است) ترکیب می کند:$collection = collect(['Chair', 'Desk']);$zipped = $collection-&gt;zip([100, 200]);$zipped-&gt;all();// [['Chair', 100], ['Desk', 200]]",
            "url": "/documentation/laravel/Digging-Deeper/collections"
          }
          ,
        
          "documentation-laravel-database-database" :{
            "title": "پایگاه داده ها",
            "content": "لاراول ارتباط با پایگاه داده ها را با استفاده از raw SQL, the fluent query builder و  the Eloquent ORM  بسیار ساده ساخته است. در حال حاضر، Laravel از چهار پایگاه داده پشتیبانی می کند:MySQLPostgreSQLSQLiteSQL Serverتنظیمات (Configuration)پیکربندی پایگاه داده برای برنامه شما در config/database.php قرار دارد. در این فایل شما می توانید تمام اتصالات پایگاه داده خود را تعریف کنید. تنظیمات Read &amp; Write Connections گاهی اوقات شما ممکن است مایل به استفاده از یک کانکشن پایگاه داده برای دستورات SELECT، و کانکشن دیگر برای INSERT، UPDATE و DELETE statements. لاراول این امکان را ایجاد می کند تا کانکشن های مناسب مورد استفاده قرار می گیرد.'mysql' =&gt; [    'read' =&gt; [        'host' =&gt; '192.168.1.1',    ],    'write' =&gt; [        'host' =&gt; '196.168.1.2'    ],    'sticky'    =&gt; true,    'driver'    =&gt; 'mysql',    'database'  =&gt; 'database',    'username'  =&gt; 'root',    'password'  =&gt; '',    'charset' =&gt; 'utf8mb4',    'collation' =&gt; 'utf8mb4_unicode_ci',    'prefix'    =&gt; '',],گزینه sticky  یک مقدار اختیاری است  تا عملیات خواندن فوری از دیتابیس  در زمانیکه عملیات نوشتن اطلاعات در دیتابیس در حال انجام است  صورت گیرد  و تضمین می کند که هر گونه اطلاعاتی که در طول چرخه درخواست نوشته شده است، بتواند بلافاصله پس از همان درخواست از پایگاه داده خوانده شود.استفاده همزمان از چندین connection در پروژههنگامی که چندین connection (برای انجام عملیات مختلف) در پروژه خود تعریف شده دارید، می توانید از طریق متد connection در façade DB به هر یک از connection ها دسترسی داشته باشید. name ای که به متد connection ارسال می کنید باید با یکی از connection های لیست شده در فایل تنظیمات config/database.php منطبق باشد:$users = DB::connection('foo')-&gt;select(...);همچنین می توانید به نمونه ی شی PDO خالص و زیرساختی دسترسی داشته باشید. برای این منظور کافی است متد getPdo را بر روی نمونه ای ازconnection صدا بزنید:$pdo = DB::connection()-&gt;getPdo();اجرای  Raw SQL Queriesهنگامی که اتصال پایگاه داده خود را پیکربندی کرده اید، می توانید با استفاده از فاساد DB کوئری ها را اجرا کنید.&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Support\\Facades\\DB;use App\\Http\\Controllers\\Controller;class UserController extends Controller{    /**     * Show a list of all of the application's users.     *     * @return Response     */    public function index()    {        $users = DB::select('select * from users where active = ?', [1]);        return view('user.index', ['users' =&gt; $users]);    }}اولین آرگومان دستورات SQL و دومین آرگومان مقادیری است که بصورت binding جهت جلوگیری از حملات SQL injection مورد استفاده قرار می گیرد.دستور SELECT آرایه ای از نتایج را بر می گرداند و هر نتیجه شی از کلاس PHP StdClass خواهد بود که به شما امکان می دهد به مقادیر نتایج دسترسی داشته باشید:foreach ($users as $user) {    echo $user-&gt;name;}استفاده از Named Bindingsبجای استفاده از ؟ برای نشان دادن پارامترهای bindings،  می توانید  از نامگذاری پارامترها استفاده کنید:$results = DB::select('select * from users where id = :id', ['id' =&gt; 1]);اجرای دستور Insertکد زیر نحوه اجرای دستور INSERT را نمایش می دهد :DB::insert('insert into users (id, name) values (?, ?)', [1, 'Dayle']);اجرای دستور Updateکد زیر نحوه اجرای دستور UPDATE را نمایش می دهد که تعداد رکوردهای تغییر داده شده را بر می گرداند :$affected = DB::update('update users set votes = 100 where name = ?', ['John']);اجرای دستور Deleteکد زیر نحوه اجرای دستور DELETE را نمایش می دهد که تعداد رکوردهای حذف شده را بر می گرداند :$deleted = DB::delete('delete from users');اجرای سایر دستورات SQLتعدادی از دستورات SQL مقداری را بر نمی گردانند. برای اجرای اینگونه دستورات می توان از متد statement  فاساد DB  همانند زیر استفاده نمود :DB::statement('drop table users');گوش دادن به رخدادهای Query با متد Listenمی توانید با بهره گیری از متد listen در façade DB، برای تمامی کوئری ها listener تعریف کنید. متد ذکر شده به شما کمک می کند از کوئری هاlog گرفته و آن ها را عیب یابی کنید. می توانید query listener را در یک service provider ثبت کنید:&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\DB;use Illuminate\\Support\\ServiceProvider;class AppServiceProvider extends ServiceProvider{    /**     * Bootstrap any application services.     *     * @return void     */    public function boot()    {        DB::listen(function ($query) {            // $query-&gt;sql            // $query-&gt;bindings            // $query-&gt;time        });    }    /**     * Register the service provider.     *     * @return void     */    public function register()    {        //    }}بررسی Database Transactionsبه منظور اجرای مجموعه ای از علملیات طی یک تراکنش بر روی پایگاه داده، Laravel متد transaction را ارائه می دهد. در صورتی که در طول اجرای تابع Closure متد transaction خطا رخ دهد، تراکنش به صورت خودکار به حالت قبلی برگردانده می شود (rollback). و اگر با موفقیت اجرا شد، تراکنش به صورت خودکار تایید ثبت (commit) می گردد.به هنگام استفاده از متد transaction لزومی ندارد نگران بازگرداندن یا تایید ثبت تراکنش به صورت دستی باشید:DB::transaction(function () {    DB::table('users')-&gt;update(['votes' =&gt; 1]);    DB::table('posts')-&gt;delete();});نکته: هرنوع اثتثنائی که از درون Closure تعریف شده در متد  transaction رخ بدهد ، باعث RollBack شدن transaction بصورت خودکار میشود .اداره کردن  deadlock متد transaction  یک آرگومان اختیاری دوم را می پذیرد که تعداد دفعاتی را که یک transaction  باید در هنگام وقوع یک بن بست (deadlock) انجام شود، تعیین می کند. هنگامی که این تلاش ها به ثمر نرسید، یک استثنا رخ خواهد داد :DB::transaction(function () {    DB::table('users')-&gt;update(['votes' =&gt; 1]);    DB::table('posts')-&gt;delete();}, 5);راه اندازی و اجرای Transactions  به صورت دستی اگر می خواهید یک تراکنش را به صورت دستی اجرا کرده و کنترل کامل بر عملیات rollback (بازگشت تراکنش به حالت قبلی) و commit (تایید ثبت تراکنش)، می توانید متد begin Transaction را بر روی DB facade فراخوانی نمایید:DB::beginTransaction();می توانید تراکنش را به وسیله ی متد rollback به حالت قبلی برگردانید (به عقب برگردانید):DB::rollBack();در پایان می توانید تراکنش را به وسیله ی متد commit تایید ثبت نمایید:DB::commit();متدهای مربوط به تراکنش façade DB همچنین در تراکنش های query builder و Eloquent ORM کاربرد دارد (می توان از آن ها برای کنترل تراکنش های query builder و Eloquent استفاده کرد).",
            "url": "/documentation/laravel/Database/database"
          }
          ,
        
          "documentation-laravel-database-queries" :{
            "title": "آشنایی با Query Builder",
            "content": "ابزار کوئری ساز یا به انگلیسی Query Builder یک interface بهینه و کارآمد برای ایجاد و اجرای کوئری جهت پرس و جو از پایگاه داده فراهم می کند. این ابزار قابلیت اجرای غالب عملیات مورد نظر در پایگاه داده ی اپلیکشن را دارا بوده و نیز برای تمامی سیستم های بانک اطلاعاتی که مورد پشتیبانی لاراول است قابل استفاده می باشد.query builder چارچوب نرم افزاری لاراول (جهت گنجاندن مقادیر در query ها) از PDO parameter binding برای محافظت از اپلیکیشن تحت وب شما در برابر حملات SQL injection بهره می گیرد. از اینرو لزومی ندارد رشته های ارسالی به عنوان پارامتر (binding ها) را برای کسب اطمینان از عدم وجود کدهای مخرب چک کنید.واکشی تمامی سطرهای یک جدولبرای نوشتن کوئری، ابتدا متد table را در façade DB درج می کنیم. متد table یک نمونه ی query builder از جدول مورد پرس و جو برگردانده و بدین وسیله به شما امکان می دهد قیود (constraint های) بیشتری را به صورت زنجیره ای به کوئری الحاق کنید و در نهایت نتایج مد نظر را در خروجی دریافت نمایید. در مثال زیر با فراخوانی متد get کلیه ی رکوردها را از جدول مورد نظر استخراج می کنیم:&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Support\\Facades\\DB;use App\\Http\\Controllers\\Controller;class UserController extends Controller{    /**     * Show a list of all of the application's users.     *     * @return Response     */    public function index()    {        $users = DB::table('users')-&gt;get();        return view('user.index', ['users' =&gt; $users]);    }}متد get  یک Illuminate \\ Support \\ Collection را که شامل نتایجی است که در آن هر نتیجه یک نمونه شی از کلاس PHP StdClass می باشد. می توانید به مقدار هر ستون به صورت یک property (از شی) دسترسی داشته باشید (می توان با دسترسی به ستون به صورت یکproperty از شی مورد نظر، به مقدار آن ستون دست یافت):foreach ($users as $user) {    echo $user-&gt;name;}بازیابی تنها یک سطر / ستون از جدول مورد نظربرای دسترسی به تنها یک سطر از جدول مورد نظر، می توان متد first را بکار برد. این متد تنها یک شی StdClass را در خروجی برمی گرداند:$user = DB::table('users')-&gt;where('name', 'John')-&gt;first();echo $user-&gt;name;اگر به کل یک سطر نیازی نیست، می توانید یک تک مقدار را با فراخوانی متد value از رکورد واکشی کنید. این متد مقدار ستون را به صورت مستقیم در خروجی برمی گرداند:$email = DB::table('users')-&gt;where('name', 'John')-&gt;value('email');بازیابی  لیستی از مقادیر ستوناگر می خواهید در خروجی یک آرایه داشته باشید که تمامی مقادیر یک ستون را دربرگیرد، می توانید متد pluck را بکار ببرید. در این مثال آرایه ای ازtitle ها را در خروجی دریافت می کنیم:$titles = DB::table('roles')-&gt;pluck('title');foreach ($titles as $title) {    echo $title;}همچنین می توانید یک ستون کلید (key column) اختصاصی برای آرایه ی خروجی (نتیجه) مشخص نمایید:$roles = DB::table('roles')-&gt;pluck('title', 'name');foreach ($roles as $name =&gt; $title) {    echo $title;}واکشی سطرها از جدول به صورت تکه تکه (متد chunk)در شرایطی که با هزاران رکورد سروکار دارید (مانند سناریوی واکشی هزاران رکورد)، توصیه می کنیم متد chunk را بکار ببرید. این متد در هر برهه ی زمانی تنها تکه ی کوچکی از داده ها را بازگردانده و سپس هر تکه را برای پردازش به تابع Closure می دهد. این متد برای نوشتن دستوراتArtisan که هزاران رکورد را یکجا پردازش می کنند، بسیار مفید واقع می شود. در نمونه ی زیر کل جدول users را در قالب رکورد صدتایی به صورت جدا پردازش می کنیم:DB::table('users')-&gt;orderBy('id')-&gt;chunk(100, function ($users) {    foreach ($users as $user) {        //    }});جهت توقف پردازش رکوردها به این شکل (پردازش رکوردها در گروه های صد تایی) کافی است مقدار false را از تابع Closure بازگردانید:DB::table('users')-&gt;orderBy('id')-&gt;chunk(100, function ($users) {    // Process the records...    return false;});توابع تجمعی (Aggregate)query builder توابع متعددی برای اجرای عملیات مختلف بر روی یک کل را فراهم می آورد. این توابع یک مقدار را بر اساس داده های یک ستون محاسبه و بر می گرداند. توابع تجمعی عبارتند از: count، max، min، avg و sum. می توانید هر یک از این متدها را پس از ساخت کوئری خود فراخوانی نمایید:$users = DB::table('users')-&gt;count();$price = DB::table('orders')-&gt;max('price');می توانید این متدها را با دیگر عبارات مانند دستورات شرطی where ترکیب نموده و کوئری های پیچیده تری بسازید:$price = DB::table('orders')                -&gt;where('finalized', 1)                -&gt;avg('price');دستور Selectگاهی لزومی ندارد تمامی ستون های یک جدول را از پایگاه داده واکشی کنیم. متد select به شما این امکان را می دهد تا یک دستور Select سفارشی برای کوئری نوشته و تنها ستون های دلخواه را در خروجی دریافت نمایید:$users = DB::table('users')-&gt;select('name', 'email as user_email')-&gt;get();متد distinct به شما این امکان را می دهد تا فقط ستون های غیر تکراری را در خروجی لحاظ نمایید:$users = DB::table('users')-&gt;distinct()-&gt;get();چنانچه از قبل یک نمونه از query builder دارید و اکنون می خواهید یک ستون جدید به دستور select آن اضافه کنید، در آن صورت می توانید از متد addSelect استفاده نمایید:$query = DB::table('users')-&gt;select('name');$users = $query-&gt;addSelect('age')-&gt;get();عبارت های خالص (raw expression)گاهی لازم می شود یک عبارت خالص در کوئری مورد نظرتان بکار ببرید. عبارت خالص به صورت رشته در کوئری تزریق می شوند. از این رو بایستی حین تزریق عبارت های خالص از ایجاد حفره ی امنیتی و فراهم آوردن زمینه برای حملات SQL injection خودداری نمایید.$users = DB::table('users')                     -&gt;select(DB::raw('count(*) as user_count, status'))                     -&gt;where('status', '&lt;&gt;', 1)                     -&gt;groupBy('status')                     -&gt;get();به منظور ایجاد یک عبارت خالص، می توان متد DB::raw را بکار برد (مورد استفاده ی این متد گنجاندن یک کوئری در دل کوئری دیگر است. لازم به ذکر است که این متد کوئری را از نظر کدهای مخرب چک نمی کند): متدهای Rawبه جای استفاده از DB :: raw، شما همچنین ممکن است از روش های زیر برای قرار دادن یک عبارت خام به بخش های مختلف درخواست خود استفاده کنید.متد selectRawمتد selectRaw را می توان به جای (DB :: raw (...) استفاده کرد). این روش در آرگومان دوم خود یک آرایه اختیاری از مقادیر bindings  را می پذیرد:$orders = DB::table('orders')                -&gt;selectRaw('price * ? as price_with_tax', [1.0825])                -&gt;get();متد whereRaw / orWhereRawروشهای whereRaw و orWhereRaw را می توان برای تزریق یک جمله Raw به کار برد. این روش در آرگومان دوم خود یک آرایه اختیاری از مقادیر bindings  را می پذیرد:$orders = DB::table('orders')                -&gt;whereRaw('price &gt; IF(state = \"TX\", ?, 100)', [200])                -&gt;get();متد havingRaw / orHavingRawمتدهای havingRaw و orHavingRaw جهت نشاندن یک رشته Raw به عنوان مقدار having استفاده می شود : $orders = DB::table('orders')                -&gt;select('department', DB::raw('SUM(price) as total_sales'))                -&gt;groupBy('department')                -&gt;havingRaw('SUM(price) &gt; 2500')                -&gt;get(); متد orderByRawمتد orderByRaw  جهت نشاندن یک رشته Raw به عنوان مقدار order by استفاده می شود : $orders = DB::table('orders')                -&gt;orderByRaw('updated_at - created_at DESC')                -&gt;get();دستور Inner Joinاز query builder می توان جهت اجرای دستورات مختلف join بهره گرفت. برای اجرای یک عملیات ساده ی inner join اس کیو ال، کافی است متدjoin را بر روی نمونه ی ایجاد شده از جدول (نمونه ی query builder) فراخوانی کنید. اولین آرگومان ارسالی به این متد اسم جدولی است که می خواهید به آن عملیات پیوند را انجام دهید. دیگر آرگومان های پاس داده شده قیود و constraint های اعمال شده بر روی ستون ها در عملیات join را تعیین می کنند. همان طور که در این مثال مشاهده می کنید، در قالب تنها یک کوئری می توان به چندین جدول پیوند انجام داد:$users = DB::table('users')            -&gt;join('contacts', 'users.id', '=', 'contacts.user_id')            -&gt;join('orders', 'users.id', '=', 'orders.user_id')            -&gt;select('users.*', 'contacts.phone', 'orders.price')            -&gt;get();دستور Left Join Clauseاگر می خواهید بجای عملیات inner join، عملیات left join را بر روی جدولی اجرا کنید، کافی است متد leftJoin را به صورت زیر فراخوانی نمایید. لازم به ذکر است که متد نام برده از نظر نوع و تعدادی ورودی (signature) با متد join یکسان است:$users = DB::table('users')            -&gt;leftJoin('posts', 'users.id', '=', 'posts.user_id')            -&gt;get();دستور Cross Join Clauseجهت اجرای عملیات cross join، کافی است متد crossJoin را فراخوانی کرده و اسم جدولی که می خواهید عملیات cross join بر روی آن اجرا شود را به عنوان آرگومان به آن پاس دهید. نتیجه ی عملیات cross join ترکیبی است که از قرار گرفتن هر سطر یا رکورد از جدول اول در کنار تمامی سطرهای جدول دوم بدست می آید، به عبارتی دیگر نتیجه cross join حاصلضرب دکارتی دو جدول در هم است.$users = DB::table('sizes')            -&gt;crossJoin('colours')            -&gt;get();دستورات پیچیده ی joinمی توانید دستورات join پیچیده تری بنویسید. برای شروع یک تابع Closure به عنوان آرگومان دوم به متد join ارسال کنید. این تابع یک شیJoinClause به عنوان پارامتر ورودی می گیرد که به شما اجازه می دهد constraint ها و محدودیت هایی را در دستور join تعریف نمایید:DB::table('users')        -&gt;join('contacts', function ($join) {            $join-&gt;on('users.id', '=', 'contacts.user_id')-&gt;orOn(...);        })        -&gt;get();می توانید دستورات join پیچیده تری بنویسید. برای شروع یک تابع Closure به عنوان آرگومان دوم به متد join ارسال کنید. این تابع یک شیJoinClause به عنوان پارامتر ورودی می گیرد که به شما اجازه می دهد constraint ها و محدودیت هایی را در دستور join تعریف نمایید:DB::table('users')        -&gt;join('contacts', function ($join) {            $join-&gt;on('users.id', '=', 'contacts.user_id')                 -&gt;where('contacts.user_id', '&gt;', 5);        })        -&gt;get();دستور Unionsquery builder به شما امکان می دهد تا نتیجه ی حاصل از اجرای دو کوئری را به راحتی با یکدیگر ادغام یا متحد نمایید. برای مثال یک کوئری اولیه ایجاد می کنیم و سپس با فراخوانی متد union، آن را با یک کوئری دیگر ترکیب می کنیم:$first = DB::table('users')            -&gt;whereNull('first_name');$users = DB::table('users')            -&gt;whereNull('last_name')            -&gt;union($first)            -&gt;get();می توان متد unionAll را برای لحاظ کردن مقادیر تکراری صدا زد. این متد از نظر signature با متد union تفاوتی ندارد. دستور Whereبه منظور افزودن دستورات where به کوئری، می توانید متد where را بر روی نمونه ی query builder صدا بزنید. در ساده ترین نوع فراخوانی متد where، ارسال سه آرگومان الزامی می باشد. اولین آرگومان اسم ستون می باشد. دومین آرگومان یکی از عملگرهای مورد پشتیبانی پایگاه داده است. سومین آرگومان مقداری است که با ستون مورد نظر از جدول مقایسه می شود.در مثال زیر بررسی می کنیم آیا مقدار ستون \"votes\" برابر 100 هست یا خیر:$users = DB::table('users')-&gt;where('votes', '=', 100)-&gt;get();به منظور سادگی بیشتر، اگر فقط می خواهید بررسی کنید مقدار یک ستون برابر با یک مقدار مشخص هست یا خیر، می توانید مقدار دلخواه را به طور مسقیم به عنوان آرگومان دوم به متد where ارسال کنید:$users = DB::table('users')-&gt;where('votes', 100)-&gt;get();مسلما می توان از دیگر عملگرهای مورد پشتیبانی پایگاه داده در عبارت where استفاده کرد:$users = DB::table('users')                -&gt;where('votes', '&gt;=', 100)                -&gt;get();$users = DB::table('users')                -&gt;where('votes', '&lt;&gt;', 100)                -&gt;get();$users = DB::table('users')                -&gt;where('name', 'like', 'T%')                -&gt;get();می توان آرایه ای از شرط ها را به تابع where ارسال کرد:$users = DB::table('users')-&gt;where([    ['status', '=', '1'],    ['subscribed', '&lt;&gt;', '1'],])-&gt;get();دستورات Orمی توان علاوه بر افزودن constraint های عبارت where (قیودی که در قالب عبارت where به کوئری اعمال می شوند) به صورت زنجیره ای، عبارتor را نیز به کوئری اضافه کرد. query builder این کار با ارائه ی متد orWhere امکان پذیر ساخته است. متد مزبور از نظر آرگومان های ورودی با متد where تفاوتی ندارد:$users = DB::table('users')                    -&gt;where('votes', '&gt;', 100)                    -&gt;orWhere('name', 'John')                    -&gt;get();دیگر دستورات whereدستور whereBetweenمتد whereBetween بررسی می کند آیا مقدار ستون مورد نظر بین دو رینج مشخص هست یا خیر:$users = DB::table('users')                    -&gt;whereBetween('votes', [1, 100])-&gt;get();دستور whereNotBetweenاین متد بررسی می کند آیا مقدار ستون مورد نظر خارج از رینج یا دامنه ی دو مقدار مشخص شده هست یا خیر (ستون هایی که مقادیر آن ها داخل رینج عددی مشخص شده نباشد را جستجو می کند):$users = DB::table('users')                    -&gt;whereNotBetween('votes', [1, 100])                    -&gt;get();دستور whereIn / whereNotInمتد wherein ستون هایی را که مقدار آن ها داخل آرایه ی ورودی باشد را جستجو می کند:$users = DB::table('users')                    -&gt;whereIn('id', [1, 2, 3])                    -&gt;get();متد whereNotIn رکوردهایی را جستجو می کند که مقادیر آن ها محدود به آرایه ی ورودی نباشد (مقدار آن ها در آرایه ی ارسالی به عنوان آرگومان نباشد):$users = DB::table('users')                    -&gt;whereNotIn('id', [1, 2, 3])                    -&gt;get();دستور whereNull / whereNotNullمتد whereNull ستون هایی را برمی گرداند که مقدار آن ها NULL باشد:$users = DB::table('users')                    -&gt;whereNull('updated_at')                    -&gt;get();متد whereNotNull رکوردهایی را جستجو و برمی گرداند که مقدار آن ها NULL نباشد:$users = DB::table('users')                    -&gt;whereNotNull('updated_at')                    -&gt;get();دستورات whereDate / whereMonth / whereDay / whereYear / whereTimeبرای مقایسه مقادیر ستون با یک تاریخ، از متد whereDate استفاده می شود :$users = DB::table('users')                -&gt;whereDate('created_at', '2016-12-31')                -&gt;get();برای مقایسه مقادیر ستون با ماه یک سال، از متد whereMonth استفاده می شود :$users = DB::table('users')                -&gt;whereMonth('created_at', '12')                -&gt;get();برای مقایسه مقادیر ستون با روز یک سال، از متد whereDay استفاده می شود :$users = DB::table('users')                -&gt;whereDay('created_at', '31')                -&gt;get();برای مقایسه مقادیر ستون با  یک سال، از متد whereYear استفاده می شود :$users = DB::table('users')                -&gt;whereYear('created_at', '2016')                -&gt;get();برای مقایسه مقادیر ستون با  یک زمان، از متد whereTime استفاده می شود :$users = DB::table('users')                -&gt;whereTime('created_at', '=', '11:20')                -&gt;get();whereColumnمتد whereColumn را می توان جهت مقایسه و کسب اطمینان از برابر بودن دو ستون مورد استفاده قرار داد:$users = DB::table('users')                -&gt;whereColumn('first_name', 'last_name')                -&gt;get();همچنین می توان یک عملگر مقایسه ای به متد پاس داد:$users = DB::table('users')                -&gt;whereColumn('updated_at', '&gt;', 'created_at')                -&gt;get();متد whereColumn نیز می تواند آرایه ای از چندین شرط را به عنوان آرگومان بپذیرد. این شرط ها توسط عملگر and با یکدیگر پیوند می خورند:$users = DB::table('users')                -&gt;whereColumn([                    ['first_name', '=', 'last_name'],                    ['updated_at', '&gt;', 'created_at']                ])-&gt;get();کوئری های تودرتوگاهی اوقات ملزوم به ساخت دستورات شرطی (where) پیچیده تری می شوید. از جمله می توان به عبارت های \"where exists\" (برای بررسی وجود ستون) یا کوئری های تودرتو اشاره کرد. query builder فریم ورک Laravel انجام این کار را هم برای شما آسان می سازد. برای شروع، به مثال ساده ای که در آن where های تودرتو نوشته و constraint ها داخل پرانتز گروه بندی شده اند می پردازیم:DB::table('users')            -&gt;where('name', '=', 'John')            -&gt;orWhere(function ($query) {                $query-&gt;where('votes', '&gt;', 100)                      -&gt;where('title', '&lt;&gt;', 'Admin');            })            -&gt;get();همان طور که مشاهده می کنید، ارسال تابع Closure به متد orWhere به عنوان آرگومان به query builder اعلان کرده که باید محدودیت ها را گروه بندی کرده و داخل پرانتز قرار دهد. Closure یک نمونه query builder به عنوان ورودی گرفته که شما با استفاده از آن می توانید محدودیت هایی که باید به صورت گروه بندی شده در پرانتز قرار گیرد را اعمال کنید. مثال فوق کوئری زیر را تولید می کند:select * from users where name = 'John' or (votes &gt; 100 and title &lt;&gt; 'Admin')متد whereExistsمتد whereExists به شما اجازه می دهد عبارت های where exists بنویسید. این متد یک تابع Closure به عنوان آرگومان می گیرد. خود این تابع یک نمونه ی query builder به عنوان ورودی دریافت کرده که با استفاده از آن کوئری را تعریف می کنید:DB::table('users')            -&gt;whereExists(function ($query) {                $query-&gt;select(DB::raw(1))                      -&gt;from('orders')                      -&gt;whereRaw('orders.user_id = users.id');            })            -&gt;get();کوئری فوق دستور ساده ی SQL زیر را تولید می کند:select * from userswhere exists (    select 1 from orders where orders.user_id = users.id)کوئری گرفتن از ستون های از نوع JSONلاراول به شما امکان می دهد از ستون های از نوع JSON کوئری بگیرید. در حال حاضر این قابلیت تنها در پایگاه داده ی MySQL ویرایش 5.7 وPostgres پشتیبانی می شود. برای گرفتن کوئری از ستون از نوع JSON، می بایست عملگر -&gt; را مورد استفاده قرار دهید:$users = DB::table('users')                -&gt;where('options-&gt;language', 'en')                -&gt;get();$users = DB::table('users')                -&gt;where('preferences-&gt;dining-&gt;meal', 'salad')                -&gt;get();متد orderByمتد orderBy به شما امکان می دهد تا نتایج حاصل از اجرای یک کوئری را مرتب سازی کنید. اولین آرگومان ارسالی به این متد باید اسم ستونی باشد که می خواهید نتایج بر اساس آن مرتب شوند، در حالی که آرگومان دوم ترتیب مرتب سازی اعم از نزولی (asc) یا صعودی (desc) را کنترل می کند:$users = DB::table('users')                -&gt;orderBy('name', 'desc')                -&gt;get();متد های latest / oldestمتدهای  latest and oldest  به شما اجازه می دهند نتایج را براساس تاریخ مرتب کنید. به طور پیش فرض نتایج براساس ستون created_at مرتب می شوند. همچنین می توانید نام ستونی که می خواهید نتایج براساس آن مرتب شوند را مشخص نمایید :$user = DB::table('users')                -&gt;latest()                -&gt;first();متد inRandomOrderمتد inRandomOrder نتایج یک کوئری را به صورت تصادفی مرتب سازی می کند. در مثال زیر با فراخوانی این متد یک کاربر را به طور تصادفی از جدول واکشی می کنیم:$randomUser = DB::table('users')                -&gt;inRandomOrder()                -&gt;first();متدهای groupBy / havingتوابع groupByو having را می توان جهت گروه بندی نتایج کوئری مورد استفاده قرار داد. متد having از نظر نوع و تعداد پارامتر ورودی (signature) با متد where یکسان می باشد:$users = DB::table('users')                -&gt;groupBy('account_id')                -&gt;having('account_id', '&gt;', 100)                -&gt;get();همچنین می توانید چندیدن ستون را جهت گروه بندی انتخاب نمایید :$users = DB::table('users')                -&gt;groupBy('first_name', 'status')                -&gt;having('account_id', '&gt;', 100)                -&gt;get();skip / takeبه منظور محدود سازی نتایج حاصل از اجرای کوئری یا لحاظ نکردن تعداد خاصی از نتایج در کوئری (OFFSET)، می توان متدهای skip و take را مورد استفاده قرار داد:$users = DB::table('users')-&gt;skip(10)-&gt;take(5)-&gt;get();همچنین می توانید از متدهای limit و offset نیز استفاده نمایید :$users = DB::table('users')                -&gt;offset(10)                -&gt;limit(5)                -&gt;get();دستورات شرطیگاهی می خواهید یک شرط تنها زمانی به یک کوئری اعمال شود که شرط دیگری صادق باشد. به عنوان مثال ممکن است بخواهید یک شرط where تنها در صورتی اعمال شود که درخواست ورودی دارای مقدار خاصی باشد. این کار را می توانید با فراخوانی متد when انجام دهید:$role = $request-&gt;input('role');$users = DB::table('users')                -&gt;when($role, function ($query) use ($role) {                    return $query-&gt;where('role_id', $role);                })                -&gt;get();متد when تنها زمانی تابع Closure را اجرا می کند که اولین پارامتر true باشد. در صورتی که اولین پارامتر false باشد، تابع Closure اجرا نخواهد شد.همچنین می توان تابع Closure دیگری به عنوان آرگومان سوم مشخص کرد که در صورتیکه اولین پارامتر false  باشد آن دستورات اجرا شوند :$sortBy = null;$users = DB::table('users')                -&gt;when($sortBy, function ($query) use ($sortBy) {                    return $query-&gt;orderBy($sortBy);                }, function ($query) {                    return $query-&gt;orderBy('name');                })                -&gt;get();متد Insertsquery builder همچنین یک متد به نام insert ارائه می کند که توسط آن می توانید رکوردهایی را داخل جدول درج نمایید. متد insert آرایه ای از اسم و مقادیر ستون ها را به عنوان ورودی گرفته و در جدول درج می کند:DB::table('users')-&gt;insert(    ['email' =&gt; 'john@example.com', 'votes' =&gt; 0]);می توان با یکبار فراخوانی تابع insert تعداد زیادی رکورد را در جدول وارد کرد. برای این منظور کافی است آرایه ای از آرایه ها را به عنوان آرگومان به تابع ذکر شده ارسال نمایید. هر آرایه نشانگر یک سطر است که در جدول درج می شود:DB::table('users')-&gt;insert([    ['email' =&gt; 'taylor@example.com', 'votes' =&gt; 0],    ['email' =&gt; 'dayle@example.com', 'votes' =&gt; 0]]); ستون Auto-Incrementing IDsاگر جدول مورد نظر دارای یک ستون خود افزاینده id است، در آن صورت می توان با فراخوانی متد insertGetId یک رکورد را وارد جدول کرده و سپس ID آن را بازیابی کنید:$id = DB::table('users')-&gt;insertGetId(    ['email' =&gt; 'john@example.com', 'votes' =&gt; 0]);اگر از پایگاه داده ی PostgreSQL استفاده می کنید، در آن صورت بایستی اسم ستون خود افزاینده (auto-incrementing یا کلید اصلی) را id تنظیم کنید (در واقع این پایگاه داده انتظار دارد اسم ستون نام برده id باشد). اگر می خواهید id را از sequence دیگری بازیابی کنید، آنگاه بایستی اسم sequence را به عنوان آرگومان دوم به متد insertGetId ارسال نمایید.دستور Updatesquery builder با ارائه ی متد update به شما اجازه می دهد رکوردهای جاری را بروز رسانی کنید. این متد مانند insert، آرایه ای از جفت اسم و مقادیر ستون (column / value pair) را برای بروز رسانی به عنوان ورودی می پذیرد. با استفاده از دستورات شرطی where می توانید بر روی کوئری update قید اعمال کرده و آن را محدود نمایید:DB::table('users')            -&gt;where('id', 1)            -&gt;update(['votes' =&gt; 1]);بروز رسانی ستون هایی از نوع JSONهنگام به روز رسانی ستون JSON، شما باید از -&gt;  برای دسترسی به کلید مناسب در شی JSON استفاده کنید. این عملیات تنها در پایگاه های داده پشتیبانی می شود که ستون های JSON را پشتیبانی می کنند:DB::table('users')            -&gt;where('id', 1)            -&gt;update(['options-&gt;enabled' =&gt; true]);توابع Increment و Decrementquery builder چارچوب نرم افزاری لاراول متدهایی را هم برای افزایش یا کاهش مقدار ستون مورد نظر فراهم می کند. این دو متد صرفا یک نوع میان برای دستور update محسوب می شوند.دو متد نام برده حداقل یک آرگومان می پذیرند: 1. اسم ستونی که بروز آوری می شود. در صورت تمایل می توان یک آرگومان دوم به تابع ارسال کرد که واحد افزایش یا کاهش مقدار ستون را مشخص می کند:DB::table('users')-&gt;increment('votes');DB::table('users')-&gt;increment('votes', 5);DB::table('users')-&gt;decrement('votes');DB::table('users')-&gt;decrement('votes', 5);می توان ستون های بیشتری را برای بروز رسانی مشخص کنید:DB::table('users')-&gt;increment('votes', 1, ['name' =&gt; 'John']);متد Deletesquery builder همچنین یک متد به نام delete فراهم می کند که توسط آن می توان رکوردهای دلخواه را از پایگاه داده حذف کرد:می توانید با اضافه کردن عبارت های شرطی where به کوئری، دستورات delete را محدود نمایید (قیودی را بر کوئری اعمال کنید):DB::table('users')-&gt;delete();DB::table('users')-&gt;where('votes', '&gt;', 100)-&gt;delete();اگر می خواهید جدول را کاملا خالی کنید (تمامی سطرهای آن را حذف و ستون شمارشی ID را به صفر بازگردانید)، کافی است متد truncate را صدا بزنید:DB::table('users')-&gt;truncate();قفل گذاری بدبینانه (Pessimistic Locking)query builder با ارائه ی تعدادی تابع به شما امکان می دهد به راحتی بر روی دستورات select خود قفل های pessimistic اعمال کنید. برای اجرای دستور با یک قفل مشترک (shared lock)، می توان متد sharedLock را بر روی کوئری صدا زد. قفل مشترک مانع از این می شود که سطرهای انتخابی پیش از اتمام تایید ثبت و commit شدن کامل تراکنش، ویرایش شوند (قفل اشتراکی یا shared lock به زمان اطلاق می شود که دو تراکنش مجوز در سطح خواندن / read access دریافت کنند). در واقع با استفاده از متد sharedLock یک قفل pessimistic برای دستورSelect ایجاد می کنیم:DB::table('users')-&gt;where('votes', '&gt;', 100)-&gt;sharedLock()-&gt;get();می توانید بجای متد نام برده از lockForUpdate استفاده کنید. این متد حین اجرای دستور select مانع از بروز رسانی و ویرایش سطرها می شود:DB::table('users')-&gt;where('votes', '&gt;', 100)-&gt;lockForUpdate()-&gt;get();",
            "url": "/documentation/laravel/Database/queries"
          }
          ,
        
          "documentation-laravel-eloquent-orm-eloquent" :{
            "title": "آشنایی با eloquent",
            "content": "لاراول همراه با یک ORM پیش فرض به نام Eloquent ارائه می شود. این ORM برای کار با پایگاه داده الگوی ActiveRecord را پیاده سازی می کند. هر یک از جداول در پایگاه داده یک مدل متناظر و معادل خود دارند که برای تعامل با جدول مورد نظر از آن ها استفاده می شود. مدل ها به شما این امکان را می دهند تا به راحتی از داده های جدول کوئری گرفته و نیز رکوردهای جدید در جدول وارد کنید.پیش از هر چیز باید یک connection برای اتصال به پایگاه داده در فایل config/database.php تعریف کنید.تعریف Modelsبرای شروع یک مدل Eloquent ایجاد کنید. مدل ها به طور معمول در پوشه ی app قرار می گیرند، با این حال شما می توانید آن ها را در هر مکانی که امکان بارگذاری خودکار (auto-load) آن ها با توجه به تنظیمات فایل composer.json وجود دارد قرار دهید. تمامی مدل های Eloquent از کلاسIlluminate\\Database\\Eloquent\\Model ارث بری می کنند.آسان ترین روش برای ایجاد یک نمونه ی مدل اجرای دستور آرتیزان make:model است.php artisan make:model Userاگر می خواهید همزمان با ایجاد مدل یک migration نیز ایجاد کنید، در آن صورت کافی است گزینه ی --migration یا -m را به انتهای دستور آرتیزان اضافه نمایید:php artisan make:model User --migrationphp artisan make:model User -mقراردادها و قواعد مربوط به مدل های Eloquentاکنون به یک کلاس نمونه ی مدل به نام Flight می پردازیم. از این کلاس برای واکشی و ذخیره ی اطلاعات از جدول flights بهره می گیریم:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Flight extends Model{    //}اسم جداولهمان طور که می بینید به Eloquent اعلان نکردیم که باید از کدام جدول برای مدل Flight استفاده کند. اگر یک اسم به طور صریح برای جدول مشخص نکنید، فرم snake case و جمع همان کلاس به عنوان اسم جدول لحاظ می شود. مشخص است که در چنین شرایطی Eloquent فرض می گیرد مدل Flight رکوردها را در جدول flights ذخیره کرده است. در صورت متفاوت بودن نام مدل از نام جدول، می توانید با تعریف متغیر (property) table در مدل مورد نظر، آن را مشخص کنید (با تعریف خاصیت table یک نام سفارشی برای جدول تعریف نمایید):&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Flight extends Model{    /**     * The table associated with the model.     *     * @var string     */    protected $table = 'my_flights';}کلیدهای اصلی (primary key)Eloquent فرض می گیرد هر جدول یک ستون کلید اصلی به نام id دارد. می توانید با تعریف یک متغیر (property) به نام$primaryKey اسم جدیدی برای این ستون تنظیم کنید و به اصطلاح این قرارداد را بازنویسی نمایید.علاوه بر آن Eloquent فرض می گیرد که ستون کلید اصلی دارای مقداری از نوع عدد صحیح و افزایش پذیر (incrementing integer) است، از این رو مقدار این ستون به صورت خودکار به int تبدیل می شود. اگر می خواهید از یک کلید اصلی غیر عددی و غیر افزایشی استفاده کنید، در آن صورت می بایست مقدار متغیر (property) $incrementing را که به صورت public تعریف شده، در مدل بر روی false تنظیم کنید.قواعد مربوط به timestamp هاEloquent انتظار دارد دو ستون به نام های created_at و updated_at در جداول شما وجود داشته باشد. اگر نمی خواهید مدیریت این ستون ها به صورت خودکار به Eloquent واگذار شود، بایستی متغیر (property) $timestamps را با false مقداردهی کنید:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Flight extends Model{    /**     * Indicates if the model should be timestamped.     *     * @var bool     */    public $timestamps = false;}اگر می خواهید فرمت timestamp های خود را مطابق نیاز تنظیم کنید، بایستی متغیر (property) $dateFormat را در مدل تعریف نموده و مقداردهی کنید. این متغیر علاوه بر تعیین چگونگی ذخیره ی attribute های مربوط به تاریخ در پایگاه داده، فرمت آن ها را در زمان کد و سریاله شدن مدل به array / JSON نیز تعریف می کند:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Flight extends Model{    /**     * The storage format of the model's date columns.     *     * @var string     */    protected $dateFormat = 'U';}اگر شما بخواهید نام ستون های استفاده شده برای ذخیره timestamps را سفارشی نمایید، کافی است ثابت CREATED_AT و UPDATED_AT را در مدل خود تنظیم کنید:&lt;?phpclass Flight extends Model{    const CREATED_AT = 'creation_date';    const UPDATED_AT = 'last_update';}تعریف connectionدر حالت پیش فرض، تمامی مدل های Eloquent از connection از پیش تنظیم شده اپلیکیشن برای اتصال به پایگاه داده استفاده می کنند. در صورت نیاز به تعریف یک connection دیگر، کافی است متغیر $connection را در مدل بکار ببرید:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Flight extends Model{    /**     * The connection name for the model.     *     * @var string     */    protected $connection = 'connection-name';}بازیابی چندین مدلپس از ایجاد مدل و جدول متناظر آن در پایگاه داده، می توانید نسبت به واکشی اطلاعات از پایگاه داده اقدام نمایید. هر مدل Eloquent به مثابه ی یک query builder قدرتمند ایفای نقش می کند و به شما اجازه می دهد به راحتی از جدول مربوط به مدل کوئری بگیرید. مثال:&lt;?phpuse App\\Flight;$flights = App\\Flight::all();foreach ($flights as $flight) {    echo $flight-&gt;name;}اعمال محدودیت های بیشتر (constraint)متد all از توابع Eloquent تمامی رکوردهای درون جدول متناظر مدل را برمی گرداند. از آنجایی که هر مدل Eloquent به عنوان یک query builder نیز عمل می کند، می توانید به راحتی constraint هایی را به کوئری اعمال کرده و سپس با استفاده از متد get تمامی نتایج را بازیابی کنید:$flights = App\\Flight::where('active', 1)               -&gt;orderBy('name', 'desc')               -&gt;take(10)               -&gt;get();کلیه ی متدهای query builder در کوئری های Eloquent نیز در دسترس هستند.collection هاخروجی توابع Eloquent نظیر all و get که مجموعه ای از نتایج را برمی گردانند، در واقع نمونه ای از کلاسIlluminate\\Database\\Eloquent\\Collection می باشد. کلاس Collection تعداد زیادی متد مفید برای انجام عملیات مختلف بر روی خروجی ها و نتایج Eloquent ارائه می دهد.$flights = $flights-&gt;reject(function ($flight) {    return $flight-&gt;cancelled;});می توان به راحتی داخل collection مانند آرایه حلقه زد (چرخید):foreach ($flights as $flight) {    echo $flight-&gt;name;}اداره ی حجم سنگین نتایج با متد chunk (دریافت خروجی به صورت خورد خورد)برای پردازش یکجای هزاران رکورد، بد نیست دستور chunk را فراخوانی کنید. این متد رکوردهای Eloquent را در قالب تکه یا chunk هایی (مثلا 100 رکورد) واکشی کرده و آن ها را برای پردازش به تابع Closure می دهد.استفاده از chunk به هنگام کار با حجم بالای نتایج سبب صرفه جویی در مصرف حافظه می شود:Flight::chunk(200, function ($flights) {    foreach ($flights as $flight) {        //    }});اولین آرگومان ارسالی به این متد تعداد رکوردهایی است که می خواهید در هر بار (در قالب بسته هایی) واکشی شود. تابع Closure که به عنوان آرگومان دوم پاس داده شده نیز به ازای هر بسته ی واکشی شده از پایگاه داده فراخوانی می گردد.Using Cursorsمتد Cursors به شما این امکان را می دهد تا از طریق یک نشانگر پایگاه داده،  تنها یک پرس و جو را اجرا کنیم. هنگام پردازش مقادیر زیاد داده ها، متد Cursors می تواند به میزان قابل توجهی استفاده از حافظه را کاهش داد:foreach (Flight::where('foo', 'bar')-&gt;cursor() as $flight) {    //}بازیابی یک نمونه از مدل / تک مقدار عددی (aggregate)با فراخوانی توابع first و find می توان بجای واکشی تمامی رکوردهای یک جدول، تنها یک رکورد (تک رکوردهایی) را از جدول استخراج کرد. بجای واکشی مجموعه ای از مدل ها، این متدها یک تک نمونه از مدل را برمی گرداند:// Retrieve a model by its primary key...$flight = App\\Flight::find(1);// Retrieve the first model matching the query constraints...$flight = App\\Flight::where('active', 1)-&gt;first();می توانید متد find را با آرایه ای از کلیدهای اصلی صدا بزنید که مجموعه ای از رکوردهای منطبق و متناظر را در خروجی برمی گرداند:$flights = App\\Flight::find([1, 2, 3]);بازیابی یک مدل یا صدور exception در صورت یافت نشدن مدلگاهی ممکن است لازم شود در صورت عدم وجود یا یافت نشدن مدل مورد نظر، یک exception صادر کنید. این روش به خصوص در route ها یاcontroller ها مفید واقع می شود. متد findOrFail و firstOrFail اولین نتیجه ی حاصل از اجرای کوئری را در خروجی برمی گرداند. و اگر نتیجه ای بازگردانده نشد، یک خطای Illuminate\\Database\\Eloquent\\ModelNotFoundException صادر می شود:$model = App\\Flight::findOrFail(1);$model = App\\Flight::where('legs', '&gt;', 100)-&gt;firstOrFail();در صورتی که exception مدیریت (catch) نشود، یک پاسخ HTTP با کد وضعیت 404 به صورت خودکار به مرورگر برگردانده می شود، از اینرو در زمان استفاده از دو متد مزبور ضرورتی ندارد چک هایی را به صورت صریح برای بازگرداندن پاسخ های 404 به کاربر بنویسید:Route::get('/api/flights/{id}', function ($id) {    return App\\Flight::findOrFail($id);});بازیابی تک مقادیر عددی (aggregates)می توانید از توابع تجمعی نظیر count، sum، max نیز استفاده کنید. این توابع بجای بازیابی یک نمونه ی کامل از مدل در خروجی، مقدار عددی مربوطه را برمی گردانند:$count = App\\Flight::where('active', 1)-&gt;count();$max = App\\Flight::where('active', 1)-&gt;max('price');عملیات درج ساده Insertsبه منظور ایجاد یک رکورد جدید در پایگاه داده، کافی است یک نمونه مدل ایجاد کرده، attribute های مربوطه را در مدل تنظیم کنید و سپس متدsave را صدا بزنید:&lt;?phpnamespace App\\Http\\Controllers;use App\\Flight;use Illuminate\\Http\\Request;use App\\Http\\Controllers\\Controller;class FlightController extends Controller{    /**     * Create a new flight instance.     *     * @param  Request  $request     * @return Response     */    public function store(Request $request)    {        // Validate the request...        $flight = new Flight;        $flight-&gt;name = $request-&gt;name;        $flight-&gt;save();    }}در این مثال فقط پارامتر name را از درخواست HTTP ورودی می گیریم و به اتریبیوت name از نمونه مدل App\\Flight تخصیص می دهیم. هنگامی که متد save را فرا می خوانیم، یک رکورد داخل پایگاه داده درج می گردد. ستون های created_at و updated_at نیز به صورت خودکار مقداردهی می شود، بنابراین نیازی نیست آن ها را به صورت دستی تنظیم کنید.عملیات بروز رسانی ساده Updatesمتد save را می توان جهت بروز رسانی مدل های از پیش موجود در پایگاه داده نیز مورد استفاده قرار داد. به منظور بروز رسانی یک مدل، ابتدا آن را بازیابی نموده، attribute های مد نظر برای بروز رسانی را مقداردهی (set) و در نهایت متد save را فراخوانی نمایید. بار دیگر یادآور می شویم که ستون updated_at به صورت اتوماتیک بروز آوری می شود و نیازی نیست مقدار آن را به صورت دستی تنظیم کنید:$flight = App\\Flight::find(1);$flight-&gt;name = 'New Flight Name';$flight-&gt;save();عملیات update را می توان بر روی هر تعداد مدلی که با کوئری منطبق است اجرا نمود. در این مثال تمامی پروازهای جاری (active) که مقصد (destination) آن ها شهر San Diego هست با تاخیر علامت گذاری می شوند:App\\Flight::where('active', 1)          -&gt;where('destination', 'San Diego')          -&gt;update(['delayed' =&gt; 1]);متد update آرایه ای از جفت های (اسم) ستون و مقدار را به عنوان آرگومان دریافت می کند که نشانگر ستون های متناظری است که باید بروز آوری شوند.تخصیص جمعی (mass assignment)می توانید با بکار گیری متد create یک نمونه ی جدید از مدل را در تنها یک خط کد در پایگاه داده درج و ذخیره کنید. نمونه مدل درج شده توسط متد به شما برگردانده می شود. اما پیش از این کار، بایستی اتریبیوت fillable یا guarded را در مدل مورد نظر تعریف کنید چرا که تمامی مدل هایEloquent به طور پیش فرض در مقابل تخصیص جمعی محافظت شده هستند.خطر امنیتی یا آسیب پذیری در اثر mass-assignment به زمانی گفته می شود که کاربری یک پارامتر HTTP غیر منتظره از طریق request ارسال کند و در پی آن پارامتر مزبور ستونی را که انتظارش را ندارید در پایگاه داده ی شما ویرایش کند. برای مثال کاربر مخرب ممکن است از طریق درخواست HTTP یک پارامترis_admin ارسال کند. این پارامتر بلافاصله به متد create مدل نگاشت شده و به هکر اجازه می دهد سطح دسترسی خود را به admin ارتقا دهد.برای شروع باید مشخص کنید می خواهید به کدام یک از attribute های مدل قابلیت تخصیص جمعی (در تخصیص جمعی به مدل انتساب داده شوند) را اعطا کنید. برای این منظور کافی است متغیر (property) $fillable را در مدل بکار ببرید (این property مشخص می کند کدام یک از attribute ها را در تخصیص جمعی می توان مقداردهی کرد). در مثال زیر با مقداردهی property مذکور، به اتریبیوت name از مدل Flight امکان تخصیص جمعی را اعطا می کنیم:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Flight extends Model{    /**     * The attributes that are mass assignable.     *     * @var array     */    protected $fillable = ['name'];}پس از اعطای قابلیت تخصیص جمعی به attribute های مورد نظر، می توان متد create را صدا زده و یک رکورد جدید را در پایگاه داده وارد کرد. متد نام برده نمونه مدل ذخیره شده در پایگاه داده را در خروجی برمی گرداند:$flight = App\\Flight::create(['name' =&gt; 'Flight 10']);اگر در حال حاضر نمونه ای از مدل دارید، می توانید از متد fill  برای پر کردن آن با یک آرایه از ویژگی ها استفاده کنید:$flight-&gt;fill(['name' =&gt; 'Flight 22']); ویژگی های نگهداری Guarding Attributesمتغیر $fillable مانند یک لیست سفید است که attribute های با قابلیت mass assign در آن درج شده. نقطه ی مقابل آن متغیر $guardedهست که attribute های فاقد این قابلیت را به صورت آرایه در خود ذخیره می کند (در این پراپرتی attribute هایی را ذخیره می کنیم که در مقابل تخصیص جمعی محافظت شده هستند). از اینرو تمامی attribute هایی که در آرایه حاضر نیستند، در تخصیص جمعی قابل انتساب به مدل هستند.می توان گفت که$guarded یک نوع لیست سیاه است. ناگفته پیدا است که این دو property را نمی توان همزمان با هم بکار برد:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Flight extends Model{    /**     * The attributes that aren't mass assignable.     *     * @var array     */    protected $guarded = ['price'];}همان طور که می بینید فقط اتریبیوت price در مقابل تخصیص جمعی محافظت شده می باشد.اگر می خواهید تمام ویژگی های توزیع را تعیین کنید، می توانید guarded$ را به عنوان یک آرایه خالی تعریف کنید:/** * The attributes that aren't mass assignable. * * @var array */protected $guarded = [];متدهای firstOrCreate/ firstOrNewدو متد دیگر وجود دارد که می توان از آن ها برای ایجاد مدل بهره گرفت: firstOrCreate و firstOrCreate. متد firstOrCreate ابتدا سعی می کند رکورد را بر اساس جفت های اسم ستون / مقدار ارائه شده پیدا کند. اگر مدل در پایگاه داده یافت نشد، یک رکورد با attribute های داده شده درج می کند.متد firstOrNew مشابه متد firstOrCreate ابتدا تلاش می کند رکورد منطبق با attribute های ارائه شده را پیدا کند. در صورت یافت نشدن رکورد مورد نظر، یک نمونه مدل جدید در خروجی برمی گرداند (ایجاد می کند). دقت داشته باشید که مدلی که توسط متد firstOrNew برگردانده می شود، هنوز به طور دائمی در پایگاه داده ذخیره نشده است. جهت تثبیت و ذخیره ی دائمی آن باید متد save را صدا بزنید:// Retrieve flight by name, or create it if it doesn't exist...$flight = App\\Flight::firstOrCreate(['name' =&gt; 'Flight 10']);// Retrieve flight by name, or create it with the name and delayed attributes...$flight = App\\Flight::firstOrCreate(    ['name' =&gt; 'Flight 10'], ['delayed' =&gt; 1]);// Retrieve by name, or instantiate...$flight = App\\Flight::firstOrNew(['name' =&gt; 'Flight 10']);// Retrieve by name, or instantiate with the name and delayed attributes...$flight = App\\Flight::firstOrNew(    ['name' =&gt; 'Flight 10'], ['delayed' =&gt; 1]);متد updateOrCreateشما همچنین ممکن است در موقعیت هایی قرار بگیرید که می خواهید یک مدل موجود را به روز کنید یا یک مدل جدید ایجاد کنید چنانچه وجود نداشته باشد. Laravel یک روش updateOrCreate را برای انجام این کار در یک مرحله فراهم می کند. بنابراین نیازی به متد  ()save نخواهد بود:// If there's a flight from Oakland to San Diego, set the price to $99.// If no matching model exists, create one.$flight = App\\Flight::updateOrCreate(    ['departure' =&gt; 'Oakland', 'destination' =&gt; 'San Diego'],    ['price' =&gt; 99]);حذف مدلبه منظور حذف مدل از پایگاه داده، متد delete را در نمونه ی ایجاد شده از مدل فراخوانی کنید:$flight = App\\Flight::find(1);$flight-&gt;delete();حذف مدل از پایگاه داده با استفاده از کلید اصلیدر مثال فوق ابتدا مدل را واکشی می کنیم، سپس متد delete را صدا می زنیم. اما اگر کلید اصلی مدل را می دانید، دیگری نیازی به واکشی آن نیست. برای این منظور متد destroy را صدا زده و کلید اصلی مدل را به عنوان پارامتر ورودی به آن پاس می دهیم:App\\Flight::destroy(1);App\\Flight::destroy([1, 2, 3]);App\\Flight::destroy(1, 2, 3);حذف مدل با استفاده از کوئری سادهمی توانید یک کوئری delete نوشته و آن را بر روی مدل های مورد نظر اجرا کنید. در مثال حاضر تمامی پروازهایی (flight) که غیرفعال (مقدار ستونactive آن ها 0 هست) هستند را حذف می کنیم:$deletedRows = App\\Flight::where('active', 0)-&gt;delete();حذف موقت (soft delete)علاوه بر امکان حذف دائمی رکوردها، Eloquent به شما اجازه می دهد مدل ها را به طور موقت حذف کنید. به حذف موقت رکوردها soft delete گفته می شود. soft delete کردن مدل در واقع سبب می شود یک اتریبیوت deleted_at در مدل (تعریف) مقداردهی و در پایگاه داده ذخیره گردد. اگر این attribute در مدل مقدار دهی شده باشد (مقدارش non-null باشد)، آن مدل soft delete شده است. برای فعال سازی قابلیت soft deleteبرای مدل مورد نظر، کافی است Illuminate\\Database\\Eloquent\\SoftDeletes trait را در مدل بکار برده و ستون deleted_at را به متغیر (property) $dates اضافه نمایید:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;use Illuminate\\Database\\Eloquent\\SoftDeletes;class Flight extends Model{    use SoftDeletes;    /**     * The attributes that should be mutated to dates.     *     * @var array     */    protected $dates = ['deleted_at'];}همچنین لازم است ستون deleted_at را به جدول اضافه نمایید. schema builder لاراول یک متد کمکی برای ایجاد این ستون در اختیار شما قرار می دهد:Schema::table('flights', function ($table) {    $table-&gt;softDeletes();});حال زمانی که متد delete را در مدل صدا می زنید، ستون deleted_at با تاریخ و زمانی جاری مقداردهی می شود. همچنین به هنگام گرفتن کوئری از مدلی که قابلیت soft delete برای آن فعال سازی شده، خواهید دید که مدل های soft delete شده در هیچ یک از مجموعه نتایج حاصل از اجرای کوئری لحاظ نمی شوند.برای پی بردن به اینکه آیا رکوردی به صورت موقت حذف شده یا خیر، متد trashed را صدا بزنید:if ($flight-&gt;trashed()) {    //}آوردن مدل های soft delete شده در مجموعه نتایجهمان طور که در بالا گفته شد، مدل هایی که به صورت موقتی حذف شده اند در مجموعه نتایج لحاظ نخواهند شد. متد withTrashed این امکان را فراهم می کند تا مدل های soft delete شده را نیز در خروجی لحاظ کنید:$flights = App\\Flight::withTrashed()                -&gt;where('account_id', 1)                -&gt;get();متد withTrashed همچنین می تواند بر روی یک پرس و جو رابطه ای استفاده شود:$flight-&gt;history()-&gt;withTrashed()-&gt;get();بازیابی فقط مدل های soft delete شدهمتد onlyTrashed تنها مدل هایی که به صورت موقت حذف شده اند را در خروجی لحاظ می کند:$flights = App\\Flight::onlyTrashed()                -&gt;where('airline_id', 1)                -&gt;get();بازگردانی مدل های soft delete شده به وضعیت فعالگاهی لازم می شود یک مدلی که به صورت موقت حذف شده را به حالت فعال برگردانید (un-delete نمایید). برای این منظور کافی است متدrestore را در نمونه ی مدل فراخوانی کنید:$flight-&gt;restore();می توانید با فراخوانی متد restore در کوئری به سرعت چندین مدل soft delete شده را به حالت فعال برگردانید:App\\Flight::withTrashed()        -&gt;where('airline_id', 1)        -&gt;restore();متد restore نیز مانند متد withTrashed بر روی رابطه ها قابل استفاده می باشد:$flight-&gt;history()-&gt;restore();حذف مدل ها به طور دائمیگاهی لازم می شود یک مدل را به معنای واقعی از پایگاه داده حذف کنید. Eloquent متد forceDelete را برای این منظور ارائه می کند. جهت حذف دائمی یک مدل soft delete شده از بانک اطلاعاتی، کافی است متد forceDelete را صدا بزنید:// Force deleting a single model instance...$flight-&gt;forceDelete();// Force deleting all related models...$flight-&gt;history()-&gt;forceDelete();حوزه ی سراسری (global scope)حوزه یا scope های سراسری به شما این امکان را می دهند تا به تمامی کوئری هایی که بر روی مدل معین اجرا می شوند، محدودیت (constraint) اعمال کنید. قابلیت درون ساخته ی soft deleting چارچوب نرم افزاری لاراول خود از scope سراسری استفاده می کند و به وسیله ی آن تنها مدل های حذف نشده (non-deleted) را از پایگاه داده بیرون می کشد.می توانید scope های سراسری اختصاصی خود را بنویسید و بدین وسیله مطمئن شوید که به هر کوئری که بر روی مدل خاص اجرا می شود، محدودیت های دلخواه اعمال شود.تعریف scope های سراسرینوشتن scope های سراسری آسان است. درگام نخست یک کلاس تعریف کنید که اینترفیس Illuminate\\Database\\Eloquent\\Scope را پیاده سازی کند. لازمه ی interface ذکر شده، پیاده سازی متد apply می باشد. این متد می تواند با توجه به نیاز محدودیت هایی (constraint) را در قالب عبارات where به کوئری مورد نظر اعمال کند:&lt;?phpnamespace App\\Scopes;use Illuminate\\Database\\Eloquent\\Scope;use Illuminate\\Database\\Eloquent\\Model;use Illuminate\\Database\\Eloquent\\Builder;class AgeScope implements Scope{    /**     * Apply the scope to a given Eloquent query builder.     *     * @param  \\Illuminate\\Database\\Eloquent\\Builder  $builder     * @param  \\Illuminate\\Database\\Eloquent\\Model  $model     * @return void     */    public function apply(Builder $builder, Model $model)    {        $builder-&gt;where('age', '&gt;', 200);    }}هیچ پوشه ی پیش فرضی برای ذخیره ی scope ها در اپلیکیشن لاراول در نظر گرفته نشده است. بنابراین می بایست یک پوشه ی اختصاصی به نامScopes داخل دایرکتوری app اپلیکیشن لاراول خود جهت ذخیره ی scope ها ایجاد نمایید.تخصیص scope های سراسری به مدلبه منظور تخصیص scope سراسری به مدل، باید متد boot مدل مورد نظر را بازنویسی نموده و سپس متد addGlobalScope را بکار ببرید:&lt;?phpnamespace App;use App\\Scopes\\AgeScope;use Illuminate\\Database\\Eloquent\\Model;class User extends Model{    /**     * The \"booting\" method of the model.     *     * @return void     */    protected static function boot()    {        parent::boot();        static::addGlobalScope(new AgeScope);    }}پس از اضافه کردن scope به مدل، کوئری مورد نظر برای واکشی تمامی سطرها \" User::all() \" معادل کوئری خالص SQL زیر خواهد شد:select * from `users` where `age` &gt; 200ایجاد Scope های سراسری فاقد شناسه (Anonymous Global Scopes)Eloquent همچنین به شما اجازه می دهد scope های سراسری موردنیازتان را به وسیله ی توابع Closure تعریف نمایید. این روش به خصوص برای تعریف scope های ساده که به کلاس مجزا نیاز ندارند مفید واقع می شود:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;use Illuminate\\Database\\Eloquent\\Builder;class User extends Model{    /**     * The \"booting\" method of the model.     *     * @return void     */    protected static function boot()    {        parent::boot();        static::addGlobalScope('age', function (Builder $builder) {            $builder-&gt;where('age', '&gt;', 200);        });    }}حذف scope های سراسریدر صورت نیاز به حذف scope سراسری از یک کوئری (خارج کردن آن کوئری از پوشش حوزه ی سراسری)، کافی است متد withoutGlobalScopeرا فراخوانی کنید:User::withoutGlobalScope(AgeScope::class)-&gt;get();برای حذف تمامی scope های سراسری تعریف شده، لازم است متد withoutGlobalScopes را صدا بزنید:// Remove all of the global scopes...User::withoutGlobalScopes()-&gt;get();// Remove some of the global scopes...User::withoutGlobalScopes([    FirstScope::class, SecondScope::class])-&gt;get();تعریف scope های محلیscope های محلی این امکان را فراهم می کنند تا یک مجموعه constraint مشترک و پرکاربرد تعریف و آن ها را بارها در سرتاسر اپلیکیشن خود بکار ببرید. برای مثال ممکن است لازم باشد مکررا تمامی کاربرانی که \"محبوب و popular\" تلقی می شوند را واکشی کنید. جهت تعریف یک scope برای این منظور، کافی است واژه ی scope را به ابتدای اسم متد (مدل Eloquent) الصاق نمایید. scope ها همیشه بایستی در خروجی یک نمونه یquery builder برگردانند:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model{    /**     * Scope a query to only include popular users.     *     * @param \\Illuminate\\Database\\Eloquent\\Builder $query     * @return \\Illuminate\\Database\\Eloquent\\Builder     */    public function scopePopular($query)    {        return $query-&gt;where('votes', '&gt;', 100);    }    /**     * Scope a query to only include active users.     *     * @param \\Illuminate\\Database\\Eloquent\\Builder $query     * @return \\Illuminate\\Database\\Eloquent\\Builder     */    public function scopeActive($query)    {        return $query-&gt;where('active', 1);    }}استفاده از Scope محلیپس از اینکه scope و حوزه ی پرس و جو را تعریف کردید، می توانید متدهای مربوط به scope را برای کوئری گرفتن از مدل فراخوانی نمایید. گفتنی است که برای فراخوانی متد نیازی به ذکر پیشوند scope نیست.می توانید متدهای scope را به صورت زنجیره ای و دنبال هم فراخوانی کنید:$users = App\\User::popular()-&gt;active()-&gt;orderBy('created_at')-&gt;get();تعریف scope هایی با قابلیت دریافت پارامتر (dynamic scope)گاهی نیاز می شود scope های تعریف کنید که امکان دریافت پارامتر را دارند. برای این منظور کافی است پارامترهای دلخواه را به scope اضافه کنید. دقت داشته باشید که این پارامترها می بایست پس از آرگومان $query تعریف شوند:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model{    /**     * Scope a query to only include users of a given type.     *     * @param \\Illuminate\\Database\\Eloquent\\Builder $query     * @param mixed $type     * @return \\Illuminate\\Database\\Eloquent\\Builder     */    public function scopeOfType($query, $type)    {        return $query-&gt;where('type', $type);    }}حال می توانید به هنگام فراخوانی scope پارامترهای مورد نظر را به آن پاس دهید:$users = App\\User::ofType('admin')-&gt;get();رخدادها (Events)مدل های Eloquent رخدادهای فراوانی را اعلان و ایجاد (fire) می کنند. با بهره گیری از این اتفاق می توان در مراحل مختلف چرخه ی حیات مدل (lifecycle) عملیات مختلفی را انجام داد. برای انجام این دست عملیات از متدهای زیر استفاده می کنیم: creating، created، updating،updated، saving، saved، deleting،deleted، restoring،restored.event ها به شما اجازه می دهند هر زمان که یک کلاس مدل معین در پایگاه داده ذخیره یا بروز رسانی شد، کد خاصی را اجرا کنید.هرگاه یک مدل جدید برای اولین بار ذخیره می شود، به دنبالش رخدادهای creating و created اعلان می شوند. چنانچه مدل از پیش در پایگاه داده وجود داشته و متعاقبا متد save برای آن صدا زده شود، آنگاه رخدادهای updating / updated اعلان می شوند. در هر دو سناریو رخدادهایsaving / saved (چه مدل از قبل موجود باشد و چه برای اولین بار است که در پایگاه داده ذخیره می شود) اجرا می شوند.برای شروع، تعریف ویژگی $ dispatchesEvents در مدل Eloquent خود را که نقاط مختلف چرخه عمر مدل Eloquent را به کلاس رویداد خود نشان می دهد، مشخص کنید:&lt;?phpnamespace App;use App\\Events\\UserSaved;use App\\Events\\UserDeleted;use Illuminate\\Notifications\\Notifiable;use Illuminate\\Foundation\\Auth\\User as Authenticatable;class User extends Authenticatable{    use Notifiable;    /**     * The event map for the model.     *     * @var array     */    protected $dispatchesEvents = [        'saved' =&gt; UserSaved::class,        'deleted' =&gt; UserDeleted::class,    ];}ایجاد ناظر Observersاگر برای بسیاری از رویدادهای مربوط به یک مدل خاص گوش می دهید، می توانید از ناظران برای جمع آوری تمام شنوندگان خود به یک کلاس واحد استفاده کنید. کلاس های ناظران نامهای متفاوتی دارند که منجر به رویدادهای صلح آمیز می شود که می خواهید گوش دهید. هر یک از این روشها مدل را به عنوان تنها استدلال خود دریافت می کند. Laravel یک دایرکتوری پیش فرض برای ناظران را شامل نمی شود، بنابراین شما می توانید هر دایرکتوری ای را که دوست دارید کلاس های ناظر خود را در آن قرار دهید ایجاد کنید:&lt;?phpnamespace App\\Observers;use App\\User;class UserObserver{    /**     * Listen to the User created event.     *     * @param  \\App\\User  $user     * @return void     */    public function created(User $user)    {        //    }    /**     * Listen to the User deleting event.     *     * @param  \\App\\User  $user     * @return void     */    public function deleting(User $user)    {        //    }}برای ثبت نام یک ناظر، از روش مشاهده در مدل مورد نظر خود استفاده کنید. شما می توانید ناظران را در روش بوت یکی از ارائه دهندگان خدمات ثبت نام کنید. در این مثال، ناظر در AppServiceProvider را ثبت می کنیم:&lt;?phpnamespace App\\Providers;use App\\User;use App\\Observers\\UserObserver;use Illuminate\\Support\\ServiceProvider;class AppServiceProvider extends ServiceProvider{    /**     * Bootstrap any application services.     *     * @return void     */    public function boot()    {        User::observe(UserObserver::class);    }    /**     * Register the service provider.     *     * @return void     */    public function register()    {        //    }}",
            "url": "/documentation/laravel/Eloquent-ORM/eloquent"
          }
          ,
        
          "documentation-laravel-eloquent-orm-eloquent-relationships" :{
            "title": "eloquent relationships  آموزش",
            "content": "جداول پایگاه داده معمولا به هم مرتبط هستند. برای مثال یک پست در وبلاگ می تواند تعداد زیادی دیدگاه (مرتبط) داشته باشد یا سفارشی با کاربری که آن را داده رابطه داشته باشد. Eloquent مدیریت و کار با این رابطه ها را به مراتب آسان می سازد. Eloquent از رابطه های زیر پشتیبانی می کند:رابطه ی یک به یک (one to one)رابطه ی یک به چند (one to many)رابطه ی چند به چند (many to many)رابطه ی چند به چند با واسطه (Has Many Through)رابطه های polymorphicرابطه های polymorphic چند به چندتعریف رابطه ها (relationships)در Eloquent، رابطه ها به صورت توابعی داخل کلاس های مدل تعریف می شوند. از آنجایی که رابطه ها نیز همچون مدل های Eloquent، خود به عنوان یک query builder ایفای نقش می کنند، ویژگی تعریف رابطه ها به صورت توابع این امکان را فراهم می کند تا متدها را به صورت زنجیره ای صدا زده و قابلیت های پرس و جوی بیشتری را در کوئری گرفتن های خود لحاظ کنید. مثال:$user-&gt;posts()-&gt;where('active', 1)-&gt;get();رابطه ی یک به یک One To Oneرابطه ی یک به یک ساده ترین نوع relationship است. به عنوان مثال یک مدل User ممکن است با تنها یک phone رابطه داشته باشد. برای تعریف این رابطه، یک متد phone در مدل User قرار می دهیم. متد phone بایستی خروجی متد hasOne را در کلاس base مدل Eloquentبرگرداند:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model{    /**     * Get the phone record associated with the user.     */    public function phone()    {        return $this-&gt;hasOne('App\\Phone');    }}اولین آرگومان ارسالی به متد hasOne اسم مدل مربوطه هست. پس از اینکه رابطه تعریف شد، می توان رکورد مربوطه را با استفاده از امکانproperty های داینامیک Eloquent بازیابی کرد. property های داینامیک به شما اجازه می دهند به رابطه ها (که به صورت توابع تعریف می شوند) مانند property های تعریف شده در مدل دسترسی داشته باشید:$phone = User::find(1)-&gt;phone;Eloquent اسم کلید خارجی (foreign key) رابطه را بر اساس اسم مدل مربوطه درنظر می گیرد. در این مثال، مدل Phone (با توجه به اسم مدل) باید دارای کلید خارجی به نام user_id باشد. برای شکستن و بازنویسی این قرارداد، می توانید اسم دلخواه برای کلید خارجی را به عنوان آرگومان دوم به متد پاس دهید:return $this-&gt;hasOne('App\\Phone', 'foreign_key');علاوه بر آن Eloquent انتظار دارد کلید خارجی مقداری منطبق با مقدار ستون id (یا متغیر سفارشی primaryKey$) جدول پدر داشته باشد. به عبارت بهتر، Eloquent به دنبال مقدار ستون id کاربر در ستون user_id رکورد Phone می گردد . اگر می خواهید رابطه از مقداری غیر از id به عنوان کلید خارجی استفاده کند، بایستی یک آرگومان سوم به متد hasOne ارسال کرده و از طریق آن کلید سفارشی خود را مشخص کنید:return $this-&gt;hasOne('App\\Phone', 'foreign_key', 'local_key');تعریف عکس رابطه (طرف دیگر رابطه)حال می توان از طریق مدل User خود به Phone دسترسی داشت. در این بخش رابطه ای در مدل Phone تعریف می کنیم که به ما اجازه ی دسترسی به User ای که مالک یا مدل پدر phone هست را می دهد. طرف دیگر رابطه ی hasOne را با استفاده از متد belongsTo تعریف می کنیم:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Phone extends Model{    /**     * Get the user that owns the phone.     */    public function user()    {        return $this-&gt;belongsTo('App\\User');    }}در نمونه ی بالا، Eloquent ستون user_id از مدل Phone را به id در مدل User متصل (match می کند). Eloquent اسم پیش فرض کلید خارجی را با در نظر گرفتن اسم متد (رابطه) و الصاق پسوند id_ تعریف می کند. حال اگر می خواهید کلید خارجی در مدل Phone اسمی غیر ازuser_id داشته باشد، می توانید اسم دلخواه کلید خارجی را به عنوان آرگومان دوم ارسال کنید:/** * Get the user that owns the phone. */public function user(){    return $this-&gt;belongsTo('App\\User', 'foreign_key');}بنابراین : $user = Phone::where('phone', '0911*******')-&gt;first()-&gt;user;اگر مدل پدر از id به عنوان کلید اصلی استفاده نمی کند، یا می خواهید مدل فرزند را به ستون دیگری وصل کنید، در آن صورت می توانید کلید سفارشی جدول پدر (اسم ستون کلید اصلی در جدول پدر) را به عنوان آرگومان سوم به متد belongsTo ارسال کنید:/** * Get the user that owns the phone. */public function user(){    return $this-&gt;belongsTo('App\\User', 'foreign_key', 'other_key');}Default ModelsThe belongsTo relationship allows you to define a default model that will be returned if the given relationship is null. This pattern is often referred to as the Null Object pattern and can help remove conditional checks in your code. In the following example, the user relation will return an empty App\\User model if no user is attached to the post:/** * Get the author of the post. */public function user(){    return $this-&gt;belongsTo('App\\User')-&gt;withDefault();}To populate the default model with attributes, you may pass an array or Closure to the withDefault method:/** * Get the author of the post. */public function user(){    return $this-&gt;belongsTo('App\\User')-&gt;withDefault([        'name' =&gt; 'Guest Author',    ]);}/** * Get the author of the post. */public function user(){    return $this-&gt;belongsTo('App\\User')-&gt;withDefault(function ($user) {        $user-&gt;name = 'Guest Author';    });}رابطه ی یک به چند (one to many)relationship یک به چند برای تعریف رابطه ای بکار می رود که در آن یک مدل مالک چندین مدل دیگر است. برای مثال، یک پست در وبلاگ می تواندn تا دیدگاه داشته باشد. برای تعریف این نوع رابطه نیز یک متد در مدل Eloquent تعریف می کنیم:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model{    /**     * Get the comments for the blog post.     */    public function comments()    {        return $this-&gt;hasMany('App\\Comment');    }}یادآور می شویم که Eloquent خود ستون کلید خارجی را در مدل Comment تعیین می کند. بر اساس قراردادهای از پیش تعیین شده،Eloquent فرم snake case اسم مدل مالک (post) را انتخاب کرده و صرفا یک پسوند id_ به آن اضافه می کند. در این مثال Eloquent فرض را بر این می گذارد که کلید خارجی در مدل Comment ستونی به نام post_id هست.پس از تعریف رابطه ی مورد نیاز، می توان با دسترسی به پراپرتی comments به مجموعه دیدگاه های پست مربوطه دسترسی داشت. همان طور که پیش تر گفته شد، Eloquent از ویژگی dynamic properties پشتیبانی می کند. بنابراین می توان به رابطه ها (relationship function) همانند property های تعریف شده در مدل دسترسی داشت:$comments = App\\Post::find(1)-&gt;comments;foreach ($comments as $comment) {    //}و با توجه به اینکه رابطه ها نقش query builder را نیز ایفا می کنند، می توانید دیدگاه هایی که در خروجی واکشی می شوند را با اعمال constraintها محدود نمایید. برای این منظور متد comments را صدا زده و شرط ها را به صورت زنجیره ای به کوئری الحاق کنید:$comments = App\\Post::find(1)-&gt;comments()-&gt;where('title', 'foo')-&gt;first();برای تعیین اسم کلید خارجی دلخواه و کلید محلی که در رابطه استفاده می شود می توانید آن ها را به ترتیب به عنوان آرگومان های دوم و سوم به متد ارسال کنید:return $this-&gt;hasMany('App\\Comment', 'foreign_key');return $this-&gt;hasMany('App\\Comment', 'foreign_key', 'local_key');تعریف طرف دیگر رابطه  One To Many Inverseپس از تعریف رابطه ی لازم برای دسترسی به تمامی دیدگاه های پست، رابطه ای تعریف می کنیم که اجازه ی دسترسی دیدگاه به پست مربوطه (پست پدر) را فراهم می کند. برای تعریف طرف دیگر رابطه ی hasMany، یک تابع relationship در مدل فرزند اعلان می کنیم که متد belongsTo را صدا می زند:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Comment extends Model{    /**     * Get the post that owns the comment.     */    public function post()    {        return $this-&gt;belongsTo('App\\Post');    }}پس از تعریف رابطه، می توان با دسترسی به property های داینامیک post مدل Post مربوط به یک Comment را واکشی نمود:$comment = App\\Comment::find(1);echo $comment-&gt;post-&gt;title;در مثال بالا، Eloquent ستون post_id از مدل Comment را به ستون id در مدل Post مچ می کند. همان طور که قبلا هم به آن اشاره شد،Eloquent اسم کلید خارجی را با درنظر گرفتن اسم رابطه و افزودن پسوند id_ به اسم متد تعیین می کند. حال اگر اسم ستون کلید خارجی در مدلComment، post_id نباشد در آن صورت یک اسم سفارشی به عنوان آرگومان دوم به متد belongsTo پاس می دهیم:/** * Get the post that owns the comment. */public function post(){    return $this-&gt;belongsTo('App\\Post', 'foreign_key');}اگر اسم ستون کلید اصلی در جدول پدر id نباشد یا شما می خواهید مدل فرزند را به ستون دیگری (غیر از id) وصل کنید، در آن صورت می توانید اسم ستونی که کلید اصلی در جدول پدر هست را به عنوان آرگومان سوم به متد belongsTo ارسال نمایید:/** * Get the post that owns the comment. */public function post(){    return $this-&gt;belongsTo('App\\Post', 'foreign_key', 'other_key');}رابطه ی چند به چند (many to many)relation های چند به چند کمی پیچیده تر از رابطه های hasOne و hasMany هستند. به عنوان مثال می توان به رابطه ای اشاره کرد که در آن یک کاربر می تواند چندین نقش داشته باشد و نقش ها هم می توانند به کاربرهای متعددی داده شوند.برای مثال کاربران متعددی می توانند نقش Admin را داشته باشند. برای تعریف این رابطه به سه جدول نیاز داریم: 1. users 2. roles 3.role_user. اسم جدولrole_user بر اساس ترتیب حروف الفبا از کنار هم قرار گرفتن نام دو مدل مرتبط گرفته شده است. این جدول حاوی دو ستون به نام های user_id و role_id می باشد.برای تعریف رابطه ی چند به چند یک متد تعریف می کنیم که خود متد belongsToMany را در کلاس پایه Eloquent صدا می زند. در مثال زیر متدroles را در مدل User فراخوانی می کنیم:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model{    /**     * The roles that belong to the user.     */    public function roles()    {        return $this-&gt;belongsToMany('App\\Role');    }}پس از تعریف رابطه، کافی است از طریق property داینامیک roles به نقش های کاربر دسترسی پیدا کنید:$user = App\\User::find(1);foreach ($user-&gt;roles as $role) {    //}می توان متد roles را فراخوانی نموده و محدودیت هایی را جهت واکشی نتایج مد نظر در ادامه ی آن متد به صورت زنجیره ای به کوئری الحاق کرد:$roles = App\\User::find(1)-&gt;roles()-&gt;orderBy('name')-&gt;get();همان طور که قبلا گفته شد، اسم جدول واسط با کنار هم قرار گرفتن اسم مدل های مرتبط به ترتیب حروف الفبا مشخص می شود. می توانید اسم دلخواه خود را برای جدول واسط تعریف کنید. برای این منظور بایستی آن را به عنوان آرگومان دوم به متد belongsToMany ارسال کنید:return $this-&gt;belongsToMany('App\\Role', 'role_user');همچنین می توانید اسم ستون های کلید خارجی جدول را توسط آرگومان سوم و چهارم سفارشی تنظیم نمایید. آرگومان سوم اسم کلید خارجی مدلی است که رابطه را در آن تعریف می کنید و آرگومان چهارم اسم کلید خارجی مدلی است که به آن وصل می شوید:return $this-&gt;belongsToMany('App\\Role', 'role_user', 'user_id', 'role_id');تعریف طرف دیگر رابطه Defining The Inverse Of The Relationshipبرای تعریف طرف مقابل رابطه، متد belongsToMany را در مدل مربوطه صدا می زنیم. در ادامه ی مثال قبلی، یک متد users در مدل Roleتعریف می کنیم که متد belongsToMany را صدا می زند:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Role extends Model{    /**     * The users that belong to the role.     */    public function users()    {        return $this-&gt;belongsToMany('App\\User');    }}همان طور که می بینید رابطه ی مقابل درست مانند همتای User آن تعریف شده است. با این تفاوت که در آن به مدل App\\User ارجاع می دهیم. از آن جایی که متد belongsToMany را مجددا در این رابطه استفاده می کنیم، اسم جدول و کلیدهای خارجی که به صورت سفارشی تعریف کرده بودیم در زمان تعریف طرف دیگر رابطه ی چند به چند قابل استفاده خواهند بود.بازیابی ستون های جدول واسط Retrieving Intermediate Table Columnsهمان طور که پیش تر گفته شد، کار با رابطه های چند به چند لازمه ی وجود جدول واسط است. Eloquent روش های آسان و بهینه ای برای کار با این جدول فراهم می کند. برای مثال، فرض بگیرید شی User تعداد زیادی شی Role مرتبط دارد. پس از دسترسی به این رابطه، می توان با بهره گیری از اتریبیوت pivot در مدل ها به راحتی به جدول واسط دسترسی داشت:$user = App\\User::find(1);foreach ($user-&gt;roles as $role) {    echo $role-&gt;pivot-&gt;created_at;}همان طور که می بینید به ازای هر مدل Role که واکشی می کنیم، یک اتریبیوت pivot تخصیص می یابد. این attribute حاوی یک مدل است که بیانگر جدول واسط می باشد و می توان از آن مانند هر مدل دیگری استفاده کرد.به صورت پیش فرض، شی pivot فقط کلیدهای مدل را شامل می شود. چنانچه قرار است جدول pivot دارای attribute هایی ورای کلید های مدل باشد، بایستی آن ها را در زمان تعریف رابطه مشخص نمایید:return $this-&gt;belongsToMany('App\\Role')-&gt;withPivot('column1', 'column2');اگر می خواهید جدول pivot به صورت خودکار ستون های created_at و updated_at را داشته و مدیریت کند، بایستی متد withTimestampsرا در تعریف رابطه بکار ببرید:return $this-&gt;belongsToMany('App\\Role')-&gt;withTimestamps();Customizing The pivot Attribute NameAs noted earlier, attributes from the intermediate table may be accessed on models using the pivot attribute. However, you are free to customize the name of this attribute to better reflect its purpose within your application.For example, if your application contains users that may subscribe to podcasts, you probably have a many-to-many relationship between users and podcasts. If this is the case, you may wish to rename your intermediate table accessor to subscription instead of pivot. This can be done using the as method when defining the relationship:return $this-&gt;belongsToMany('App\\Podcast')                -&gt;as('subscription')                -&gt;withTimestamps();Once this is done, you may access the intermediate table data using the customized name:$users = User::with('podcasts')-&gt;get();foreach ($users-&gt;flatMap-&gt;podcasts as $podcast) {    echo $podcast-&gt;subscription-&gt;created_at;} فیلتر کردن رابطه ها از طریق جداول واسط Filtering Relationships Via Intermediate Table Columnsمی توانید نتایج واکشی شده توسط belongsToMany را با استفاده از متدهای wherePivot و wherePivotIn در تعریف رابطه فیلتر و محدود نمایید:return $this-&gt;belongsToMany('App\\Role')-&gt;wherePivot('approved', 1);return $this-&gt;belongsToMany('App\\Role')-&gt;wherePivotIn('priority', [1, 2]);Defining Custom Intermediate Table ModelsIf you would like to define a custom model to represent the intermediate table of your relationship, you may call the using method when defining the relationship. All custom models used to represent intermediate tables of relationships must extend the Illuminate\\Database\\Eloquent\\Relations\\Pivot class. For example, we may define a Role which uses a custom UserRole pivot model:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Role extends Model{    /**     * The users that belong to the role.     */    public function users()    {        return $this-&gt;belongsToMany('App\\User')-&gt;using('App\\UserRole');    }}When defining the UserRole model, we will extend the Pivot class:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Relations\\Pivot;class UserRole extends Pivot{    //}Has Many ThroughThe \"has-many-through\" relationship provides a convenient shortcut for accessing distant relations via an intermediate relation. For example, a Country model might have many Post models through an intermediate User model. In this example, you could easily gather all blog posts for a given country. Let's look at the tables required to define this relationship:countries    id - integer    name - stringusers    id - integer    country_id - integer    name - stringposts    id - integer    user_id - integer    title - stringThough posts does not contain a country_id column, the hasManyThrough relation provides access to a country's posts via $country-&gt;posts. To perform this query, Eloquent inspects the country_id on the intermediate users table. After finding the matching user IDs, they are used to query the posts table.Now that we have examined the table structure for the relationship, let's define it on the Country model:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Country extends Model{    /**     * Get all of the posts for the country.     */    public function posts()    {        return $this-&gt;hasManyThrough('App\\Post', 'App\\User');    }}The first argument passed to the hasManyThrough method is the name of the final model we wish to access, while the second argument is the name of the intermediate model.Typical Eloquent foreign key conventions will be used when performing the relationship's queries. If you would like to customize the keys of the relationship, you may pass them as the third and fourth arguments to the hasManyThrough method. The third argument is the name of the foreign key on the intermediate model. The fourth argument is the name of the foreign key on the final model. The fifth argument is the local key, while the sixth argument is the local key of the intermediate model:class Country extends Model{    public function posts()    {        return $this-&gt;hasManyThrough(            'App\\Post',            'App\\User',            'country_id', // Foreign key on users table...            'user_id', // Foreign key on posts table...            'id', // Local key on countries table...            'id' // Local key on users table...        );    }}رابطه های polymorphicساختار جداول مورد نیاز رابطه ی پلی مرفیکرابطه های Polymorphic به یک مدل اجازه می دهند در یک رابطه همزمان به چندین مدل دیگر تعلق داشته باشد (امکان رابطه ی یک مدل با چندین مدل دیگر از طریق یک رابطه را فراهم می آورد). به عنوان مثال، فرض کنید کاربران اپلیکیشن شما می خواهند برای پست ها و هم برای ویدئو ها، کامنت بگذارند. با بهره گیری از رابطه های polymorphic می توان به راحتی یک جدول واحد comments برای هر دو این سناریو بکار برد. در گام نخست ساختار جداولی که برای این رابطه لازم است را مورد بررسی قرار می دهیم:posts    id - integer    title - string    body - textvideos    id - integer    title - string    url - stringcomments    id - integer    body - text    commentable_id - integer    commentable_type - stringدو ستون مورد توجه در این مثال، ستون های commentable_id و commentable_type در جدول comments هستند. ستون commentable_id حاوی مقدار ID پست یا ویدئو خواهد بود، در حالی که ستون commentable_type اسم کلاس مدل مالک (پدر) را نگه خواهد داشت. Eloquent در واقع به واسطه ی ستون commentable_type تشخیص می دهد در زمان دسترسی به رابطه ی commentable کدام مدل را بایستی برگرداند.ساختار مدل Model Structureدر مرحله ی بعدی، تعریف مدل لازم برای ایجاد این رابطه را مورد بررسی قرار می دهیم:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Comment extends Model{    /**     * Get all of the owning commentable models.     */    public function commentable()    {        return $this-&gt;morphTo();    }}class Post extends Model{    /**     * Get all of the post's comments.     */    public function comments()    {        return $this-&gt;morphMany('App\\Comment', 'commentable');    }}class Video extends Model{    /**     * Get all of the video's comments.     */    public function comments()    {        return $this-&gt;morphMany('App\\Comment', 'commentable');    }}بازیابی رابطه های polymorphic (Retrieving Polymorphic Relations)پس از تعریف جداول و مدل های مورد نیاز، می توانید از طریق مدل ها به رابطه ها دسترسی داشته باشید.برای مثال، جهت دسترسی به کامنت های های یک پست، می توان از property داینامیک comments استفاده کرد:$post = App\\Post::find(1);foreach ($post-&gt;comments as $comment) {    //}می توان مالک یک رابطه ی polymorphic را از مدل polymorphic بازیابی کرد. برای این منظور بایستی به اسم متدی که متد morphTo را صدا می زند، دسترسی داشته داشت. در مثال ما، این همان متد commentable در مدل Like هست. حال کافی است به آن متد همانند یک dynamic property دسترسی داشته باشید:$comment = App\\Comment::find(1);$commentable = $comment-&gt;commentable;فراخوانی (متد) رابطه ی commentable  در مدل Comment ، بسته به مدلی که مالک آن comment می باشد یک نمونه از Post یا Video  را در خروجی برمی گرداند.نوع های اختصاصی polymorphicبه صورت پیش فرض، Laravel اسم کامل کلاس را برای ذخیره ی نوع (اسم) مدل مربوطه بکار می برد. به عنوان نمونه، در ادامه ی مثال فوق که یک comment ممکن بود به یک Post یا Video تعلق داشته باشد، commentable_type پیش فرضApp\\Post یا App\\Video خواهد بود.شما می توانید این قرار داد را شکسته و پایگاه داده را از ساختار داخلی اپلیکیشن جدا نمایید. این کار را با تعریف یک relationship \"morph map\" انجام می دهیم. morph map به Eloquent اعلان می کند که بجای اسم کلاس، اسم جدول متناظر با آن مدل را بکار ببرد.use Illuminate\\Database\\Eloquent\\Relations\\Relation;Relation::morphMap([    'posts' =&gt; 'App\\Post',    'videos' =&gt; 'App\\Video',]);می توانید morphMap را در تابع boot از AppServiceProvider معرفی کنید یا در صورت تمایل یک service provider مجزا تعریف کنید.رابطه های polymorphic چند به چند (Many To Many Polymorphic Relations)Table Structureعلاوه بر رابطه های polymorphic متعارف، می توانید رابطه های polymorphic چند به چند تعریف کنید. برای مثال، یک مدل Post و Video در یک وبلاگ می توانند یک رابطه ی polymorphic با مدل Tag داشته باشند. استفاده از رابطه ی polymorphic چند به چند این امکان را برای شما فراهم می کند تا یک لیست واحد از تگ های منحصر بفرد داشته باشید که تمامی پست ها و ویدئوهای وبلاگ از آن ها استفاده می کنند. در گام نسخت ساختار جدول را مورد بررسی قرار دهیم:posts    id - integer    name - stringvideos    id - integer    name - stringtags    id - integer    name - stringtaggables    tag_id - integer    taggable_id - integer    taggable_type - stringModel Structureاکنون زمان آن فرا رسیده تا رابطه ها را در مدل تعریف کنیم. مدل های Post و Video هر دو متد tags را خواهند داشت. متد tags متدmorphToMany را در کلاس پایه ی Eloquent فراخوانی می کند&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model{    /**     * Get all of the tags for the post.     */    public function tags()    {        return $this-&gt;morphToMany('App\\Tag', 'taggable');    }}تعریف طرف دیگر رابطه Defining The Inverse Of The Relationshipسپس در مدل Tag می بایست یک متد برای هر یک از مدل های مربوطه تعریف نمایید. در این مثال، یک متد Posts و یک videos تعریف می کنیم:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Tag extends Model{    /**     * Get all of the posts that are assigned this tag.     */    public function posts()    {        return $this-&gt;morphedByMany('App\\Post', 'taggable');    }    /**     * Get all of the videos that are assigned this tag.     */    public function videos()    {        return $this-&gt;morphedByMany('App\\Video', 'taggable');    }}بازیابی رابطه (Retrieving The Relationship)پس از تعریف جداول و مدل های مربوطه، می توان از طریق رابطه ها به مدل ها دسترسی داشت. برای مثال، جهت دسترسی به تمامی تگ های یک پست، کافی است property داینامیک tags را بکار ببرید:$post = App\\Post::find(1);foreach ($post-&gt;tags as $tag) {    //}می توانید مالک یک رابطه ی polymorphic را از مدل polymorphic بازیابی کنید. کافی است به اسم متدی که تابع morphedByMany را صدا می زند، دسترسی داشته باشید. در این مثال منظور دو متد posts یا videos در مدل Tag هست. بنابراین می بایست به متدهای نام برده همانندproperty های داینامیک دسترسی پیدا کنید:$tag = App\\Tag::find(1);foreach ($tag-&gt;videos as $video) {    //}پرس و جو و گرفتن کوئری از رابطه ها (Querying Relations)همان طور که می دانید رابطه های Eloquent به صورت توابعی تعریف می شوند. شما می توانید با فراخوانی این توابع بدون اینکه لازم باشد خود کوئری relationship را واقعا اجرا کنید، نمونه ای از آن رابطه را دریافت نمایید. بعلاوه همان طور که قبلا نیز گفته شد، تمامی رابطه های Eloquentخود مانند query builder عمل می کنند و به شما اجازه می دهند شرط ها و قیودی را برای محدود نمودن نتیجه به صورت زنجیره ای به کوئریrelationship (پیش از اجرای نهایی کوئری بر روی پایگاه داده) اعمال کنید:به عنوان مثال، یک سیستم وبلاگ را در نظر بگیرید که در آن مدل User تعداد زیادی مدل Post مرتبط دارد:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model{    /**     * Get all of the posts for the user.     */    public function posts()    {        return $this-&gt;hasMany('App\\Post');    }}می توانید از رابطه ی posts کوئری گرفته و محدودیت های بیشتری را مانند زیر به رابطه اعمال کنید:$user = App\\User::find(1);$user-&gt;posts()-&gt;where('active', 1)-&gt;get();می توانید تمامی متدهای query builder را بر روی رابطه بکار ببرید.متدهای relationship در برابر property های Dynamicاگر نیازی به اعمال قیود (constraint) اضافی بر سازمان بر روی کوئری relationship نیست، می توانید به راحتی به آن رابطه مانند یک propertyدسترسی داشته باشید. در ادامه ی مثال قبلی (مدل های User و Post)، می توان به تمامی پست های کاربر مانند زیر دسترسی داشت:$user = App\\User::find(1);foreach ($user-&gt;posts as $post) {    //}property های dynamic بار گذاری را با تاخیر انجام می دهند (lazy loading). بدین معنی که داده های relationship خود را تنها زمانی بارگذاری می کنند که شما به آن ها دسترسی پیدا می کنید. به همین خاطر توسعه دهندگان اغلب از eager loading استفاده کرده و بدین وسیله رابطه هایی که می دانند پس از بارگذاری مدل مورد دسترسی قرار می گیرند را از قبل لود می کنند. eager loading تعداد کوئری های SQL که باید برای بارگذاری رابطه های یک مدل اجرا شوند را به طور قابل توجهی کاهش می دهد.محدود کردن نتایج یک کوئری بر اساس وجود یا عدم وجود یک رابطه Querying Relationship Existenceدر زمان دسترسی به رکورد های یک مدل، می توانید نتایج را بر اساس وجود یک رابطه محدود نمایید. برای مثال، فرض کنید می خواهید تمامی پست های وبلاگ که دارای حداقل یک دیدگاه یا comment مرتبط هستند را واکشی نمایید. برای این منظور، اسم رابطه را به عنوان آرگومان به متد hasپاس دهید:// Retrieve all posts that have at least one comment...$posts = App\\Post::has('comments')-&gt;get();می توانید یک عملگر به همراه تعداد دیدگاه ها (تعداد comment هایی که پست ها باید داشته باشد تا در خروجی لحاظ شوند) برای تنظیم بیشتر کوئری مطابق نیاز تعریف کنید:// Retrieve all posts that have three or more comments...$posts = Post::has('comments', '&gt;=', 3)-&gt;get();با استفاده از عملگر نقطه می توانید دستورات has تودرتو بسازید. در نمونه ی زیر تمامی پست هایی که حداقل یک comment و vote دارند را واکشی می کنیم:// Retrieve all posts that have at least one comment with votes...$posts = Post::has('comments.votes')-&gt;get();اگر می خواهید نتایج دقیق تری را در خروجی داشته باشید، می توانید متدهای whereHas و orWhereHas را برای اعمال شرط های where بر روی کوئری های has فراخوانی کنید. این متدها به شما امکان می دهند قیود اختصاصی (constraint) خود را به constraint های رابطه اعمال کنید، مانند بررسی محتویات یک دیدگاه (comment). در زیر تمامی پست هایی که حداقل یک دیدگاه مرتبط دارند و علاوه بر آن دربردارنده ی کلماتی همچون foo می باشد را استخراج می کنیم:// Retrieve all posts with at least one comment containing words like foo%$posts = Post::whereHas('comments', function ($query) {    $query-&gt;where('content', 'like', 'foo%');})-&gt;get();Querying Relationship AbsenceWhen accessing the records for a model, you may wish to limit your results based on the absence of a relationship. For example, imagine you want to retrieve all blog posts that don't have any comments. To do so, you may pass the name of the relationship to the doesntHave and orDoesntHave methods:$posts = App\\Post::doesntHave('comments')-&gt;get();If you need even more power, you may use the whereDoesntHave and orWhereDoesntHave methods to put \"where\" conditions on your doesntHave queries. These methods allows you to add customized constraints to a relationship constraint, such as checking the content of a comment:$posts = Post::whereDoesntHave('comments', function ($query) {    $query-&gt;where('content', 'like', 'foo%');})-&gt;get();Counting Related ModelsIf you want to count the number of results from a relationship without actually loading them you may use the withCount method, which will place a {relation}_count column on your resulting models. For example:$posts = App\\Post::withCount('comments')-&gt;get();foreach ($posts as $post) {    echo $post-&gt;comments_count;}You may add the \"counts\" for multiple relations as well as add constraints to the queries:$posts = Post::withCount(['votes', 'comments' =&gt; function ($query) {    $query-&gt;where('content', 'like', 'foo%');}])-&gt;get();echo $posts[0]-&gt;votes_count;echo $posts[0]-&gt;comments_count;You may also alias the relationship count result, allowing multiple counts on the same relationship:$posts = Post::withCount([    'comments',    'comments as pending_comments_count' =&gt; function ($query) {        $query-&gt;where('approved', false);    }])-&gt;get();echo $posts[0]-&gt;comments_count;echo $posts[0]-&gt;pending_comments_count;Eager loading (بارگذاری زود هنگام)زمانی که به (توابع) رابطه های Eloquent مانند property دسترسی پیدا می کنید، داده های رابطه در واقع با تاخیر بارگذاری می شوند (به اصطلاحlazy load می شوند). بدین معنی که داده های رابطه تنها زمانی به معنای واقعی لود می شوند که شما (برای اولین بار) به property دسترسی پیدا کنید. Eloquent می تواند رابطه ها را در زمانی که از مدل پدر کوئری می گیرید، به صورت زود هنگام بارگذاری (eager load) کند. Eager loading در حقیقت برای برطرف ساختن مشکل کوئری N + 1 در نظر گرفته شد. برای فهم بهتر این مشکل یک مدل Book را در نظر بگیرید که با مدل Author مرتبط است:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Book extends Model{    /**     * Get the author that wrote the book.     */    public function author()    {        return $this-&gt;belongsTo('App\\Author');    }}حال تمامی کتاب ها و نویسندنگان مرتبط آن ها بازیابی می کنیم:$books = App\\Book::all();foreach ($books as $book) {    echo $book-&gt;author-&gt;name;}این حلقه یک کوئری برای واکشی تمامی کتاب های داخل جدول اجرا کرده سپس یک کوئری دیگر به ازای هر کتاب تا نویسنده ی مربوطه ی آن نیز واکشی شود. بنابراین اگر 25 کتاب داشته باشیم، حلقه ی مزبور در کل 26 کوئری اجرا می کند: 1 کوئری برای کتاب اصلی و 25 کوئری جهت استخراج نویسندگان مربوط به هر کتاب.با بهره گیری از امکان eager loading می توان این عملیات و تعداد کوئری را به تنها دو کوئری کاهش داد. به هنگام کوئری گرفتن، می توان مشخص کرد کدام رابطه ها بایستی زود هنگام بارگذاری شوند. این کار با فراخوانی متد with امکان پذیر خواهد بود:$books = App\\Book::with('author')-&gt;get();foreach ($books as $book) {    echo $book-&gt;author-&gt;name;}برای این عملیات دو کوئری بیشتر اجرا نمی شود:select * from booksselect * from authors where id in (1, 2, 3, 4, 5, ...)بارگذاری زود هنگام چندین رابطه Eager Loading Multiple Relationshipsگاهی لازم می شود چندین رابطه ی مختلف را در طی تنها یک عملیات به صورت زود هنگام بارگذاری کنید. برای نیل به این هدف کافی است رابطه ها را به عنوان آرگومان به متد with ارسال نمایید:$books = App\\Book::with(['author', 'publisher'])-&gt;get();بارگذاری زود هنگام رابطه های تودرتو Nested Eager Loadingبرای بارگذاری زود هنگام رابطه های تودرتو کافی است عملگر نقطه را بکار ببرید. در نمونه ی زیر تمامی نویسندگان کتاب و نیز کلیه ی تماس های شخصی نویسنده را در قالب یک دستور Eloquent به صورت زودهنگام بارگذاری می کنیم:$books = App\\Book::with('author.contacts')-&gt;get();Eager Loading Specific ColumnsYou may not always need every column from the relationships you are retrieving. For this reason, Eloquent allows you to specify which columns of the relationship you would like to retrieve:$users = App\\Book::with('author:id,name')-&gt;get(); When using this feature, you should always include the id column in the list of columns you wish to retrieve.اعمال محدودیت بر روی بارگذاری زود هنگام Constraining Eager Loadsگاهی لازم می شود رابطه ای را به صورت زود هنگام بارگذاری کرده و این میان محدودیت هایی نیز را بر روی کوئری اعمال کنید. مثال:$users = App\\User::with(['posts' =&gt; function ($query) {    $query-&gt;where('title', 'like', '%first%');}])-&gt;get();در این مثال، Eloquent تنها پست هایی را بارگذاری می کند که عنوان (مقدار ستون title) آن ها دربردارنده ی کلمه ی first باشد. البته می توانید دیگر متدهای query builder را برای تنظیم دقیق تر عملیات eager loading بکار ببرید:$users = App\\User::with(['posts' =&gt; function ($query) {    $query-&gt;orderBy('created_at', 'desc');}])-&gt;get();Lazy Eager LoadingSometimes you may need to eager load a relationship after the parent model has already been retrieved. For example, this may be useful if you need to dynamically decide whether to load related models:$books = App\\Book::all();if ($someCondition) {    $books-&gt;load('author', 'publisher');}If you need to set additional query constraints on the eager loading query, you may pass an array keyed by the relationships you wish to load. The array values should be Closure instances which receive the query instance:$books-&gt;load(['author' =&gt; function ($query) {    $query-&gt;orderBy('published_date', 'asc');}]);To load a relationship only when it has not already been loaded, use the loadMissing method:public function format(Book $book){    $book-&gt;loadMissing('author');    return [        'name' =&gt; $book-&gt;name,        'author' =&gt; $book-&gt;author-&gt;name    ];}Inserting &amp; Updating Related Modelsمتد saveEloquent متدهای فراوانی برای افزودن مدل های جدید به رابطه ها فراهم می کند. برای مثال، ممکن است لازم شود یک مدل جدید Commentبرای مدل Post درج کنید. بجای اینکه attribute(ستون) post-id را در مدل Comment به صورت دستی مقداردهی کنید، می توانید این مدل را به صورت مستقیم از متد save رابطه وارد نمایید:$comment = new App\\Comment(['message' =&gt; 'A new comment.']);$post = App\\Post::find(1);$post-&gt;comments()-&gt;save($comment);همان طور که در مثال بالا می بینید به رابطه ی comments به صورت یک dynamic property دسترسی پیدا نکردیم. بلکه صرفا متدcomments را برای بدست آوردن نمونه ای از رابطه فراخوانی نمودیم. متد save خود به صورت اتوماتیک مقدار post_id را به مدل جدیدComment اضافه می کند (فیلد مزبور را در مدل Comment مقداردهی می کند).برای ذخیره ی چندین مدل مرتبط، کافی است متد saveMany را بکار ببرید:$post = App\\Post::find(1);$post-&gt;comments()-&gt;saveMany([    new App\\Comment(['message' =&gt; 'A new comment.']),    new App\\Comment(['message' =&gt; 'Another comment.']),]);متد Createعلاوه بر متدهای save و saveMany، می توانید متد create را فراخوانی کنید. این متد آرایه ای از attribute ها را به عنوان آرگومان دریافت کرده، یک مدل جدید ایجاد می کند و سپس آن مدل را داخل پایگاه داده درج می نماید. تفاوت بین دو متد save و create در این است که save یک نمونه ی کامل از مدل Eloquent را به عنوان آرگومان می پذیرد، در حالی که create صرفا یک آرایه ی ساده و متعارف PHP را به عنوان پارامتر ورودی دریافت می کند:$post = App\\Post::find(1);$comment = $post-&gt;comments()-&gt;create([    'message' =&gt; 'A new comment.',]); Before using the create method, be sure to review the documentation on attribute mass assignment.You may use the createMany method to create multiple related models:$post = App\\Post::find(1);$post-&gt;comments()-&gt;createMany([    [        'message' =&gt; 'A new comment.',    ],    [        'message' =&gt; 'Another new comment.',    ],]);بروز رسانی رابطه های \"Belongs To\" (مرتبط کردن مدل ها با متد associate)به هنگام بروز رسانی رابطه ی belongsTo، می توانید متد associate را فراخوانی کنید. این متد کلید خارجی (foreign key) را در مدل فرزند مقداردهی می کند:$account = App\\Account::find(10);$user-&gt;account()-&gt;associate($account);$user-&gt;save();و در زمان حذف یک رابطه ی belongsTo متد dissociate را بکار ببرید. این متد علاوه بر بازگردانی کلید خارجی، رابطه ی موجود در مدل فرزند راreset می کند:$user-&gt;account()-&gt;dissociate();$user-&gt;save();Many To Many Relationshipsدرج (attach) / حذف (detach)  در رابطه های چند به چندبه هنگام کار با رابطه های چند به چند، Eloquent تعداد زیادی متد کمکی (helper method) ارائه می کند که کار با مدل های مرتبط را به مراتب آسان ساخته. سناریویی را در نظر بگیرید که در آن یک کاربر می تواند نقش های متعددی داشته باشد و یک نقش نیز در مقابل به کاربران زیادی تعلق داشته باشد. برای اینکه بتوان یک نقش جدید را با درج یک رکورد در جدول واسطه (که مدل ها را به هم وصل می کند) به کاربر مورد نظر اضافه کرد، بایستی متد attach را بکار برد (می توان با درج یک رکورد در جدول واسطه که مدل ها را به هم پیوند می دهد، یک نقش جدید به کاربر مورد نظر اضافه کرد. برای این منظور کافی است متد attach را فراخوانی کنید):$user = App\\User::find(1);$user-&gt;roles()-&gt;attach($roleId);به هنگام اضافه کردن یک رابطه جدید به مدل، همچنین می توانید آرایه ای از داده های جدید برای درج در جدول واسطه به متد attach ارسال کنید:$user-&gt;roles()-&gt;attach($roleId, ['expires' =&gt; $expires]);گاهی لازم می شود یک نقش را از کاربری حذف کنیم. برای حذف یک رکورد در رابطه ی چند به چند، متد detach را بکار می بریم. این متد رکورد مربوطه را از جدول واسطه حذف می کند. دقت داشته باشید که در پی حذف رکورد، دو مدل در پایگاه داده باقی مانده و حذف نمی شوند:// Detach a single role from the user...$user-&gt;roles()-&gt;detach($roleId);// Detach all roles from the user...$user-&gt;roles()-&gt;detach();هر دو متدهای attach و detach آرایه ای از شناسه ها را به عنوان ورودی می گیرند:$user = App\\User::find(1);$user-&gt;roles()-&gt;detach([1, 2, 3]);$user-&gt;roles()-&gt;attach([    1 =&gt; ['expires' =&gt; $expires],    2 =&gt; ['expires' =&gt; $expires]]);Syncing AssociationsYou may also use the sync method to construct many-to-many associations. The sync method accepts an array of IDs to place on the intermediate table. Any IDs that are not in the given array will be removed from the intermediate table. So, after this operation is complete, only the IDs in the given array will exist in the intermediate table:$user-&gt;roles()-&gt;sync([1, 2, 3]);You may also pass additional intermediate table values with the IDs:$user-&gt;roles()-&gt;sync([1 =&gt; ['expires' =&gt; true], 2, 3]);If you do not want to detach existing IDs, you may use the syncWithoutDetaching method:$user-&gt;roles()-&gt;syncWithoutDetaching([1, 2, 3]);Toggling Associationsهمچنین می توانید از متد sync برای ساخت رابطه های چند به چند استفاده نمایید. این متد آرایه ای از شناسه ها (ID) را به عنوان آرگومان دریافت کرده و در جدول واسطه قرار می دهد. هر ID ای که در آرایه ی ورودی موجود نباشد، از جدول واسطه حذف خواهد شد. پس از اتمام این عملیات، تنهاID های حاضر در آرایه ی ورودی داخل جدول واسطه موجود خواهند بود:$user-&gt;roles()-&gt;toggle([1, 2, 3]);Saving Additional Data On A Pivot TableWhen working with a many-to-many relationship, the save method accepts an array of additional intermediate table attributes as its second argument:App\\User::find(1)-&gt;roles()-&gt;save($role, ['expires' =&gt; $expires]);بروز رسانی یک رکورد در جدول Pivotبرای بروز رسانی سطر موجود در جدول pivot، متد updateExistingPivot را بکار ببرید:$user = App\\User::find(1);$user-&gt;roles()-&gt;updateExistingPivot($roleId, $attributes);بروز رسانی Timestamp مدل پدرزمانی که مدلی به یک (belongsTo) یا چند (belongToMany) مدل دیگر تعلق دارد، مانند مدل Comment که به یک مدل Post تعلق دارد، بروز رسانی timestamp مدل پدر پس از بروز رسانی مدل فرزند می تواند مفید واقع شود. برای مثال زمانی که یک مدل Comment بروز رسانی می شود، ممکن است بخواهید تایم استمپ updated_at مدل مالک (Post) نیز بروز آوری شود. Eloquent این کار را برای شما آسان کرده است. کافی است پراپرتی touches که با اسم رابطه ها مقداردهی شده را به مدل فرزند اضافه نمایید:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Comment extends Model{    /**     * All of the relationships to be touched.     *     * @var array     */    protected $touches = ['post'];    /**     * Get the post that the comment belongs to.     */    public function post()    {        return $this-&gt;belongsTo('App\\Post');    }}حال زمانی که شما یک Comment را بروز رسانی می کنید، مقدار ستون های updated_at در مدل پدر مدل پدر (Post) نیز بروز آوری می شود:$comment = App\\Comment::find(1);$comment-&gt;text = 'Edit to this comment!';$comment-&gt;save();",
            "url": "/documentation/laravel/Eloquent-ORM/eloquent-relationships"
          }
          ,
        
          "documentation-laravel-eloquent-orm-eloquent-mutators" :{
            "title": "آشنایی با eloquent mutators",
            "content": "Accessor ها و Mutator ها به شما این امکان را می دهند تا attribute های Eloquent را به هنگام بازیابی از مدل یا مقدار دهی آن، فرمت دهی کنید. به عنوان مثال می توان به سناریویی اشاره کرد که در آن می خواهیم با استفاده از encrypter لارول مقداری را در حالی که در پایگاه داده ذخیره شده، رمزنگاری کنیم و سپس آن را در زمان دسترسی (به آن) در مدل Eloquent، بار دیگر رمزگشایی نماییم.علاوه بر ارائه ی accessor ها و mutator های اختصاصی، Eloquent قادر است فیلدهای حاوی تاریخ و نوع داده ای date را به نمونه هایی از نوعCarbon کانورت کرده و حتی فیلدهای متنی را به فرمت JSON تبدیل کند.نحوه ی تعریف Accessorبرای تعریف Accessor، یک متد getFooAttribute در مدل خود ایجاد نمایید. واژه ی Foo در نام این متد در واقع نسخه ی CamelCase (بر اساس سیستم نوشتاری camelcase) اسم همان ستونی است که می خواهید به آن دسترسی داشته باشید. در این مثال، یک accessor برای اتریبیوت first_name تعریف می کنیم. به هنگام بازیابی و دسترسی به مقدار attribute نام برده، Eloquent به صورت خودکار accessor تعریف شده را صدا می زند:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model{    /**     * Get the user's first name.     *     * @param  string  $value     * @return string     */    public function getFirstNameAttribute($value)    {        return ucfirst($value);    }}همان طور که می بینید، مقدار اولیه ی ستون به accessor ارسال می شود و به شما این امکان را می دهد تا به آسانی آن را ویرایش و بازیابی کنید. حال برای دسترسی به مقدار mutator، کافی است به اتریبیوت first_name دسترسی پیدا کنید:$user = App\\User::find(1);$firstName = $user-&gt;first_name;همچنین می توانید با استفاده از accessors  جهت ایجاد مقادیر جدید استفاده نمایید :/** * Get the user's full name. * * @return string */public function getFullNameAttribute(){    return \"{$this-&gt;first_name} {$this-&gt;last_name}\";}نحوه ی تعریف یک Mutatorبه منظور تعریف mutator، یک متد به نام setFooAttribute در مدل ایجاد کنید. واژه ی Foo در اسم این متد در واقع نسخه ی camelcase نام همان ستونی است که می خواهید به مقدارش دسترسی داشته باشید. بنابراین ابتدا یک mutator برای اتریبیوت first_name تعریف می کنیم. به هنگام مقداردهی attribute ذکر شده در مدل مورد نظر، این mutator به صورت خودکار فراخوانده می شود:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model{    /**     * Set the user's first name.     *     * @param  string  $value     * @return void     */    public function setFirstNameAttribute($value)    {        $this-&gt;attributes['first_name'] = strtolower($value);    }}mutator مقداری که در attribute قرار داده (set) می شود را دریافت کرده و به شما اجازه می دهد تا مقدار آن را ویرایش کنید، سپس مقدار ویرایش شده را در متغیر (property) درون ساخته ی مدل Eloquent به نام $attributes ذخیره نمایید/قرار دهید. بنابراین، اگر بخواهیم مقدارfirst_name را با Sally تنظیم نماییم، می بایست به صورت زیر اقدام کنیم:$user = App\\User::find(1);$user-&gt;first_name = 'Sally';$user-&gt;save();در این مثال، تابع setFirstNameAttribute با مقدار Sally فراخوانده می شود. mutator سپس تابع strtolower را بر روی اسم اجرا کرده و مقدارش را در آرایه ی درون ساخته ی attributes$ قرار می دهد.تاریخ در  Mutatorبه صورت پیش فرض، Eloquent ستون های created_at و updated_at را به نمونه های (اشیای) از نوع Carbon تبدیل می کند که تعداد زیادی متد مفید در اختیار ما قرار داده و کلاس درون ساخته ی DateTime زبان PHP را ارث بری می کند.می توانید مشخص کنید کدام فیلدها بایستی به صورت خودکار تبدیل (mutate) شوند یا این تبدیل را کاملا غیر فعال نمایید. برای این منظور کافی است property ای که dates$ نام دارد را در مدل خود بازنویسی کنید:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model{    /**     * The attributes that should be mutated to dates.     *     * @var array     */    protected $dates = [        'created_at',        'updated_at',        'deleted_at'    ];}ستونی که از نوع date شناخته می شود را می توان با تایم استمپ های UNIX، تاریخ با فرمت رشته (Y-m-d)، تاریخ-زمان با فرمت رشته و البته یک نمونه از DateTime / Carbon مقداردهی نمود. مقدار date متعاقبا به صورت خودکار با فرمت مناسب در پایگاه داده ذخیره می شود:$user = App\\User::find(1);$user-&gt;deleted_at = now();$user-&gt;save();همان طور که در بالا ذکر شد، زمانی که attribute های لیست شده در متغیر(property) $dates را واکشی می کنید، این attribute ها به صورت خودکار به نمونه هایی از نوع Carbon تبدیل می شوند. این امر به شما اجازه می دهد تا متدهای Carbon را بر روی attribute های مورد نظر فراخوانی کنید:$user = App\\User::find(1);return $user-&gt;deleted_at-&gt;getTimestamp();به صورت پیش فرض، timestamp ها بدین صورت فرمت دهی می شوند: 'Y-m-d H:i:s'. در صورت تمایل می توانید این فرمت را اختصاصی تنظیم کنید. برای این منظور کافی است dateFormat property$ را در مدل خود مقداردهی نمایید. این property تعیین می کند attribute های حاوی مقدار تاریخ چگونه در پایگاه داده ذخیره شوند و همچنین فرمت آن ها را در زمان serialize (کد) شدن مدل به آرایه یا JSON مشخص می کند:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Flight extends Model{    /**     * The storage format of the model's date columns.     *     * @var string     */    protected $dateFormat = 'U';}تبدیل Attributeمتغیر  casts$ (در مدل) روشی آسان برای تبدیل attribute ها به نوع داده های معمول فراهم می کند. property مزبور باید یک متغیر از نوع آرایه باشد که در آن کلید در واقع اسم attribute ای است که باید تبدیل شود و مقدار آن نوع داده ای است که می خواهید ستون (فیلد) به آن cast شود. نوع هایی که برای تبدیل پشتیبانی می شوند عبارتند از: integer، real، float، double، string، boolean، object، array،collection، date، datetime و timestamp.در مثال زیر اتریبیوت is_admin که به صورت یک عدد صحیح 0 یا 1 در پایگاه داده ذخیره شده را به نوع داده ای Boolean تبدیل می کنیم:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model{    /**     * The attributes that should be cast to native types.     *     * @var array     */    protected $casts = [        'is_admin' =&gt; 'boolean',    ];}اکنون دیگر مقدار attribute نام برده همیشه به هنگام دسترسی به آن، به یک مقدار از نوع بولی تبدیل می شود، هرچند مقدار اصلی به صورت یک عدد صحیح در پایگاه داده ذخیره شده:$user = App\\User::find(1);if ($user-&gt;is_admin) {    //}تبدیل به نوع Array &amp; JSON تبدیل نوع آرایه به خصوص برای کار با ستون هایی که به صورت JSON سریاله شده، ذخیره شده اند مفید واقع می شود. به عنوان مثال، اگر پایگاه داده ی شما دارای فیلدی از نوع TEXT باشد که با JSON سریاله شده مقداردهی شده است، در آن صورت افزودن نوع array به آن attributeباعث می شود، در زمان دسترسی به آن ATTRIBUTE در مدل Eloquent، نوع attribute خودکار به یک آرایه ی معمولی PHP تبدیل شود:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model{    /**     * The attributes that should be cast to native types.     *     * @var array     */    protected $casts = [        'options' =&gt; 'array',    ];}پس از تعریف عملیات تبدیل، می توانید به options attribute دسترسی پیدا کنید. خواهید دید که نوعش به صورت خودکار از JSON سریاله شده به یک آرایه ی متعارف PHP تبدیل می شود. زمانی که attribute نام برده را مقداردهی می کنید، آرایه ی ارائه شده مجددا برای ذخیره سازی به صورت خودکار به فرمت JSON (serialized) برگردانده می شود:$user = App\\User::find(1);$options = $user-&gt;options;$options['key'] = 'value';$user-&gt;options = $options;$user-&gt;save();",
            "url": "/documentation/laravel/Eloquent-ORM/eloquent-mutators"
          }
          ,
        
          "documentation-laravel-eloquent-orm-eloquent-collections" :{
            "title": "آشنایی با eloquent collections",
            "content": "تمامی مجموعه های چند نتیجه ای که در خروجی کوئری های Eloquent دریافت می کنیم، در واقع نمونه ای از شیIlluminate\\Database\\Eloquent\\Collection هستند. نتایج واکشی شده توسط متد get یا رابطه ها (relationship method) نیز از این قاعده مستثنی نیستند. شی نام برده کلاس پایه ی (base) collection لاراول را به ارث می برد. بنابراین تمامی توابعی که برای کار با Eloquentاستفاده می شوند نیز به ارث برده می شوند.می توان در تمامی collection ها مانند آرایه حلقه زد (collection ها قابل iterate هستند).$users = App\\User::where('active', 1)-&gt;get();foreach ($users as $user) {    echo $user-&gt;name;}البته collection ها بسیار قدرتمندتر از آرایه ها هستند و می توان از آن ها برای عملیات نگاشت / سازماندهی و کاهش (map/reduce) بهره گرفت. این عملیات را می توان از طریق یک رابط (intuitive interface) مانند زنجیر به هم متصل کرد. در نمونه ی زیر تمامی مدل های غیرفعال را حذف کرده و اسم تمامی کاربران باقی مانده را بیرون می کشیم:$users = App\\User::all();$names = $users-&gt;reject(function ($user) {    return $user-&gt;active === false;})-&gt;map(function ($user) {    return $user-&gt;name;});بیشتر توابع collection در Eloquent یک نمونه ی جدید از collection در خروجی برمی گردانند، این درحالی است که متدهایpluck، keys، zip، collapse، flatten و flip یک نمونه از collection پایه را به عنوان نتیجه برمی گردانند.کلاس پایه ی collectionتمامی collection های Eloquent شی پایه ی collection لاراول را به ارث می برند. از این رو، تمامی متدهای قدرتمند این کلاس نیز در اختیار کالکشن ها قرار می گیرد:allaverageavgchunkcollapsecombineconcatcontainscontainsStrictcountcrossJoindddiffdiffKeysdumpeacheachSpreadeveryexceptfilterfirstflatMapflattenflipforgetforPagegetgroupByhasimplodeintersectisEmptyisNotEmptykeyBykeyslastmapmapIntomapSpreadmapToGroupsmapWithKeysmaxmedianmergeminmodenthonlypadpartitionpipepluckpopprependpullpushputrandomreducerejectreversesearchshiftshuffleslicesortsortBysortByDescsplicesplitsumtaketaptoArraytoJsontransformunionuniqueuniqueStrictunlessvalueswhenwherewhereStrictwhereInwhereInStrictwhereNotInwhereNotInStrictzipایجاد collection های اختصاصیچنانچه لازم است از یک شی Collection سفارشی به همراه متدهای الحاقی (extension method) خود استفاده کنید، در آن صورت می توانید متدnewCollection را در مدل بازنویسی (override) نمایید:&lt;?phpnamespace App;use App\\CustomCollection;use Illuminate\\Database\\Eloquent\\Model;class User extends Model{    /**     * Create a new Eloquent Collection instance.     *     * @param  array  $models     * @return \\Illuminate\\Database\\Eloquent\\Collection     */    public function newCollection(array $models = [])    {        return new CustomCollection($models);    }}پس از اینکه متد newCollection را تعریف کردید، هر بار که Eloquent یک نمونه Collection از مدل مربوطه را برمی گرداند به همراش نمونه ای از collection سفارشی خود را در خروجی دریافت می کنید. اگر می خواهید به ازای هر مدل در اپلیکیشن خود یک collection سفارشی استفاده کنید، در آن صورت می بایست متد newCollection را بر روی کلاس مدل پایه که توسط تمامی مدل های برنامه به ارث برده می شود، بازنویسی نمایید.",
            "url": "/documentation/laravel/Eloquent-ORM/eloquent-collections"
          }
          ,
        
          "documentation-laravel-eloquent-orm-eloquent-serialization" :{
            "title": "آشنایی با eloquent serialization",
            "content": "به هنگام ساخت API برای JSON، اغلب لازم می شود مدل ها و رابطه های خود را به فرمت آرایه یا JSON تبدیل نمایید. Eloquent برای اجرای این نوع عملیات تبدیل متدهای کارآمدی را ارائه نموده و همچنین به شما اجازه می دهد attribute هایی که در فرایند serialization لحاظ می شوند را مدیریت کنید (سریالی شدن / serialization به پروسه ای اشاره دارد که در آن یک object یا مجموعه ای از object ها که به یکدیگر اشاره می کنند به صورت گروهی از بایت ها یا فرمت داده ای XML درآمده که متعاقبا می توان آن را ذخیره یا منتقل کرد. در مقابل Deserialization به فرایندی گفته می شود که در آن گروهی از بایت ها دریافت شده و به دنبال آن به object یا مجموعه ای از object ها تبدیل می شوند).تبدیل یک مدل به آرایه Serializing To Arraysمی توان با استفاده از متد toArray یک مدل و رابطه های بارگذاری شده آن را به نوع آرایه تبدیل نمایید. متد مذکور یک تابع recursive یا به اصطلاح بازگشتی است، بنابراین تمامی attribute ها و relation ها (از جمله رابطه ی رابطه ها) به آرایه تبدیل می شوند:$user = App\\User::with('roles')-&gt;first();return $user-&gt;toArray();همچنین می توانید collection ها را به آرایه تبدیل نمایید:$users = App\\User::all();return $users-&gt;toArray();تبدیل یک مدل به فرمت JSON (Serializing To JSON)برای تبدیل یک مدل به JSON، می توانید متد toJson را فراخوانی نمایید. این متد نیز مانند toArray، یک تابع بازگشتی است. از اینرو تمامیattribute ها و relation ها به نوع JSON تبدیل می شوند:$user = App\\User::find(1);return $user-&gt;toJson();یا می توانید یک مدل یا collection را به نوع رشته تبدیل نمایید. این فرایند خود سبب فراخوانی خودکار متد toJson می شود و رشته ی تولید شده را به JSON تبدیل می کند:$user = App\\User::find(1);return (string) $user;از آنجایی که مدل ها و collection ها پس از تبدیل نوع به رشته، به فرمت JSON تبدیل می شوند، شما می توانید شی Eloquent را مستقیما ازroute ها یا controller های اپلیکیشن بازگردانی نمایید (return):Route::get('users', function () {    return App\\User::all();});مخفی سازی attribute ها به هنگام تبدیل به JSON یا آرایهگاهی لازم می شود attribute هایی نظیر گذرواژه ها که در نسخه ی تبدیل شده به آرایه یا JSON آن مدل لحاظ می شود را محدود نمایید. برای این منظور، کافی است یک property به نام $hidden به مدل خود اضافه نمایید و سپس attribute دلخواه را در آن قرار دهید:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model{    /**     * The attributes that should be hidden for arrays.     *     * @var array     */    protected $hidden = ['password'];}در زمان پنهان سازی رابطه ها لازم است از اسم متد استفاده کنید، نه از اسم dynamic property آن.یا (به روشی دیگر) می توانید با استفاده از property به نام visible یک لیست سفید تعریف نموده و در آن attribute هایی که می خواهید در نسخه ی تبدیل شده به JSON یا آرایه از مدل موجود باشند را مشخص نمایید:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model{    /**     * The attributes that should be visible in arrays.     *     * @var array     */    protected $visible = ['first_name', 'last_name'];}ویرایش قابلیت رویت و دسترسی یک property مخفی به صورت موقتاگر می خواهید برخی attribute هایی که غالبا مخفی هستند را در نمونه ی مدل خروجی قابل دسترس و visible نمایید (لیستی از attribute ها تعریف کنید که در آرایه یا JSON تبدیل وجود داشته باشند)، در آن صورت بایستی متد makeVisible را بکار ببرید.return $user-&gt;makeVisible('attribute')-&gt;toArray();به همین ترتیب، می توان برخی از attribute هایی که اغلب visible و قابل دسترس هستند را به صورت موقت از دسترس خارج نمایید (hiddenکنید). برای نیل به این هدف، Eloquent متد makeHidden را در اختیار برنامه نویس قرار می دهد. این متد در خروجی نمونه ای از مدل مورد نظر را برگردانده و زمینه را برای فراخوانی زنجیره ای متدها فراهم می آورد:return $user-&gt;makeHidden('attribute')-&gt;toArray();افزودن attribute های جدید در نسخه ی آرایه و JSON از مدلگاهی لازم می شود attribute هایی را در آرایه اضافه کنید که ستون متناظری در پایگاه داده ندارند. برای این منظور ابتدا بایستی یک accessorبرای مقدار مورد نظر تعریف نمایید:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model{    /**     * Get the administrator flag for the user.     *     * @return bool     */    public function getIsAdminAttribute()    {        return $this-&gt;attributes['admin'] == 'yes';    }}پس از ایجاد accessor مربوطه، کافی است اسم attribute را به متغیر appends در مدل اضافه نمایید:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model{    /**     * The accessors to append to the model's array form.     *     * @var array     */    protected $appends = ['is_admin'];}پس از اضافه شدن attribute به لیست مقادیر appends، این attribute هم در نسخه ی تبدیل شده به آرایه و هم در نسخه ی JSON از مدل لحاظ خواهد شد. attribute های موجود در آرایه appends از تنظیمات visible و hidden پیکربندی شده در مدل کاملا پیروی می کنند.Date Serializationلاراول کتابخانه تاریخ کربن را به منظور ارائه سفارشی مناسب از فرمت سریال JSON کربن گسترش می دهد. برای سفارشی کردن اینکه چگونه تمامی کربن ها در طول برنامه شما سریال می شوند، از روش Carbon :: serializeUsing استفاده کنید. روش serializeUsing یک Closure  را پذیرفته که رشته ای از تاریخ برای سریال سازی JSON را برمی گرداند:&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Carbon;use Illuminate\\Support\\ServiceProvider;class AppServiceProvider extends ServiceProvider{    /**     * Perform post-registration booting of services.     *     * @return void     */    public function boot()    {        Carbon::serializeUsing(function ($carbon) {            return $carbon-&gt;format('U');        });    }    /**     * Register bindings in the container.     *     * @return void     */    public function register()    {        //    }}",
            "url": "/documentation/laravel/Eloquent-ORM/eloquent-serialization"
          }
          ,
        
          "documentation-laravel-architecture-concepts-lifecycle" :{
            "title": "چرخه ی حیات درخواست (Request Lifecycle)",
            "content": "به هنگام استفاده از هر ابزاری در دنیای واقعی، مسلما آشنایی با نحوه ی استفاده از آن اطمینان خاطر بیشتری به شما می دهد. برنامه نویسی هم از این قاعده مستثنی نیست. زمانی که می دانید چگونه ابزار توسعه ی شما کار می کنند قطعا استفاده از آن ها برای شما آسان تر می شود.هدف اصلی این آموزش ارائه ی مرورکلی و سطح بالا بر نحوه ی عملکرد فریم ورک لاراول می باشد. پس از آشنایی با چارچوب کلی این فریم ورک، استفاده از همه چیز نسبتا آسان تر می شود و متعاقبا برنامه ی کاربردی خود را با اعتماد به نفس بیشتری طراحی خواهید کرد.اگر با تمامی اصطلاحات موجود در این برنامه آشنایی ندارید، جای هیچ نگرانی نیست. فقط کافی است دانش ابتدایی از آنچه رخ می دهد بدست آورید. خواهید دید که با خواندن بخش های مختلف این آموزش دانش شما افزایش یافته و درک بهتری از مفاهیم آن پیدا خواهید کرد.مرور کلی بر چرخه ی حیاتEntry point (نقطه ی شروع اجرای برنامه) تمامی درخواست ها به اپلیکیشن تحت وب لاراول فایل public/index.php می باشد. تمامی درخواست ها بر اساس پیکربندی سرور مجازی (وب سرور Apache / Nginx) به این فایل هدایت می شوند. فایل index.php حاوی مقدار کد زیادی نیست. در واقع فایل نام برده صرفا یک نقطه ی شروع برای بارگذاری باقی چارچوب نرم افزاری می باشد.فایل index.php تعریف autoloader که توسط Composer تولید شده را بارگذاری می کند و سپس یک نمونه از برنامه ی کاربردی Laravel را از اسکریپتbootstrap/app.php بازیابی می کند. اولین عملیاتی که خود لاراول انجام می دهد ایجاد یک نمونه از برنامه ی کاربردی / Service container می باشد.هسته های console / HTTPسپس درخواست ورودی، بسته به نوع آن، یا به هسته ی HTTP و یا به هسته ی console ارسال می گردد. این دو هسته (kernel) به عنوان یک نقطه ی مرکزی برای تمامی درخواست های ورودی ایفای نقش می کند. بدین معنی که تمامی درخواست ها از این دو هسته عبور می کنند. اجالتا فقط به شرح هسته ی HTTP مقیم در مسیر app/Http/Kernel.php می پردازیم.هسته ی HTTP از کلاس Illuminate\\Foundation\\Http\\Kernel ارث بری می کند. این کلاس آرایه ای از bootstrapper ها تعریف کرده که پیش از اجرای درخواست اجرا می شوند. این bootstrapper ها (خود راه اندازه ها) وظیفه ی پیکربندی مدیریت خطاها، ثبت وقایع (logging)، همچنین تشخیص محیط برنامه و دیگر کارهایی که بایستی پیش از اداره و اجرای (خود) درخواست اجرا شوند را بر عهده دارد.هسته ی HTTP همچنین یک لیست از middleware ها را تعریف می کند که تمامی درخواست ها بایستی پیش از مدیریت شدن توسط برنامه ی کاربردی از آن عبور کنند. این middleware ها وظیفه ی خواندن و نوشتن HTTP session، بررسی اینکه آیا برنامه در حالت تعمیر و نگهداشت قرار دارد یا خیر (maintenance mode) و نیز بررسی توکن CSRF را برعهده دارند (middleware یک سازوکار بهینه برای فیلتر کردن درخواست های HTTP تعبیه می کند. به عنوان مثال می توان به middleware تصدیق هویت برای login و ثبت ورود کاربر اشاره کرد).امضای متد handle، از توابع هسته ی HTTP، بسیار ساده و قابل فهم می باشد: یک Request دریافت کرده و یک Response برگرداند (منظور از امضا یا signature متد همان اسم متد و تعداد پارامترهای ورودی و نیز نوع آن ها می باشد). می توانید به Kernel یا هسته به چشم یک جعبه ی سیاه نگاه کنید که کل برنامه ی شما را تشکیل می دهد (بیانگر کل برنامه ی شما می باشد). درخواست های HTTP را به آن خورانده و در خروجی پاسخ های HTTP را دریافت نمایید.مفهوم Service Providerیکی از مهمترین عملیات (تنظیم و راه اندازی به صورت خودکار) bootstrapping که هسته (kernel) عهده دار آن است، بارگذاری service provider برای اپلیکیشن تحت وب شما می باشد (منظور از bootstrapping ثبت و رجیستر binding و اتصال service container، event listener و middleware و حتی route ها است). تمامی service provider های برنامه در فایل پیکربندی config/app.php متعلق به آرایه یproviders تنظیم می شوند. به این صورت است که ابتدا متد register بر روی تمامی provider ها فراخوانی می شود، بعد از اینکه تمامیprovider ها ثبت و ایجاد شدند، آنگاه متد boot صدا زده می شود.گفتنی است که service provider ها مسئولیت تنظیم و راه اندازی خودکار (bootstrapping) اجزاء مختلف برنامه را بر عهده دارند که از جمله یآن ها می توان به کامپوننت های database، queue، validation و routing اشاره کرد. از آنجایی که service provider ها تمامی ابزار و امکانات ارائه شده توسط فریم ورک لاراول را به صورت خودکار راه اندازی (bootstrap) و پیکربندی می کنند، می توان گفت که (service provider) مهمترین بخش کل فرایند تنظیم و راه اندازی خودکار لاراول محسوب می شوند.ارسال درخواست (Dispatch Request)پس از اینکه برنامه به صورت خودکار راه اندازی (bootstrap) شده و همچنین تمامی service provider ها کاملا ثبت شدند، Request برای ارسال (Dispatch) به router واگذار می شود. router علاوه بر ارسال درخواست به route یا controller، تمامی middleware های مختص بهroute نیز را اجرا می کند.شرح دقیق Service ProviderService provider ها مرکز پیکربندی و انجام تنظیمات پایه ای برنامه می باشند. به این صورت است که ابتدا نمونه ی اپلیکیشن ایجاد می شود و به دنبال آن service provider ها ثبت گردیده و سپس درخواست به اپلیکیشن تنظیم شده (bootstrapped app) فرستاده می شود. به همین راحتی!داشتن فهمی عمیق از چگونگی ساخته شدن برنامه و تنظیم آن توسط service provider بسیار ازشمند می باشد. لازم به ذکر است که providerهای پیش فرض اپلیکیشن در پوشه ی app/Providers نگهداری می شوند.به طور پیش فرض، AppServiceProvider تقریبا تهی می باشد. این provider مکان یا ظرف بسیار مناسبی برای افزودن service container binding ها و نیز فرایند پیکربندی (bootstrapping) اختصاصی برنامه ی تحت وب شما می باشد. لازم به گفتن نیست که برای برنامه های بزرگ بایستی چندین service provider ایجاد کرده و برای هر یک bootstrapping با درجه ی granuality بیشتر درنظر بگیرید (granularity به تعیین سطح جزیئات سیستم اشاره دارد).",
            "url": "/documentation/laravel/Architecture-Concepts/lifecycle"
          }
          ,
        
          "documentation-laravel-the-basics-routing" :{
            "title": "Routing یا مسیریابی در لاراول",
            "content": "مسیرهای پایه در لاراول یک URI و یک تابع Closure می‌پذیرند که یک متد بسیار ساده برای تعریف مسیرها ارائه می‌دهد:Route::get('foo', function () {    return 'Hello World';});فایل‌های route پیش‌فرض در لاراولتمام مسیرهای لاراول در فایل‌های route که در دایرکتوری routes قرار می‌گیرند، تعریف شده‌ است. این فایل‌ها به صورت خودکار توسط فریم ورک بارگزاری می‌شوند. فایل routes/web.php مسیرهایی را برای رابط وب تعریف می‌کند. این مسیرها به گروه middlewareweb اختصاص داده می‌شوند که قابلیت‌هایی مانند حالت جلسه و حفاظت CSRF را ارائه می‌دهند. مسیرهای موجود در routes/api.php در گروه middleware api  قرار می‌گیرند.دراکثر برنامه‌های کاربردی لاراول، بایستی کار خود را با تعریف مسیرها در فایل routes/web.php شروع کنید. می‌توان به مسیرهای تعریف شده در فایل routes/web.php با وارد کردن URL مسیر تعریف شده در مرورگر، دسترسی داشت. به عنوان مثال، اگر در مرورگر خود آدرس http://your-app.dev/user را وارد کنید، می‌توانید به مسیر زیر دسترسی داشته باشید:Route::get('/user', 'UserController@index');مسیرهای تعریف شده در فایل routes/api.php توسط RouteServiceProvider در یک گروه مسیر قرار می‌گیرند. در این گروه، پیشوند /api به صورت خودکار به URL اعمال می‌شود، در این صورت، دیگر لازم نیست به صورت دستی آن را به مسیرهای درون فایل اعمال کنید. می‌توان پیشوند و گزینه‌های دیگر در گروه مسیر با ایجاد تغییر در کلاس RouteServiceProvider تنظیم کرد.متدهای router قابل دسترس در مسیریابی لاراولتوسط روتر می‌توان مسیرهایی را که به هر درخواست از HTTP پاسخ می‌دهند را ثبت و تعریف کرد:Route::get($uri, $callback);Route::post($uri, $callback);Route::put($uri, $callback);Route::patch($uri, $callback);Route::delete($uri, $callback);Route::options($uri, $callback);گاهی ممکن است لازم باشد مسیری را که به چندین درخواست HTTP پاسخ می‌دهد، ثبت کنید. می‌توان این کار را با استفاده از متد match انجام داد. حتی می‌توان با استفاده از متد any مسیری را ثبت کرد که به تمام درخواست‌های HTTP پاسخ می‌دهد:Route::match(['get', 'post'], '/', function () {    //});Route::any('foo', function () {    //});در مسیریابی لاراول CSRF محافظتهر فرم‌ HTML که به مسیرهای POST ، PUT یا DELETE که در فایل مسیرهای web تعریف شده‌اند، اشاره دارد، باید شامل یک فیلد نشانه CSRF باشند. در غیر این صورت، درخواست رد خواهد شد.&lt;form method=\"POST\" action=\"/profile\"&gt;    {{ csrf_field() }}    ...&lt;/form&gt;تغییر مسیر یا redirect route در لاراولاگر مسیری را تعریف می‌کنید که باید به URI دیگری هدایت می‌شود، باید از متد Route::redirect استفاده کنید. این متد یک میانبر مناسب ارائه می‌دهد، به طوری که برای انجام یک تغییر مسیر (redirect) ساده دیگر نیازی به تعریف یک مسیر کامل یا یک کنترلر نخواهید داشت:Route::redirect('/here', '/there', 301);مسیریابی در لاراول : مسیرهای viewاگر مسیر یا route نیاز به برگرداندن یک view داشته باشد، می‌توانید از متد Route::view استفاده کنید. درست مثل متد redirect ، این متد نیز یک میانبر ساده ارائه می‌دهد، بنابراین نباید یک مسیر کامل یا کنترلر تعریف شود. متد view یک URI به عنوان آرگومان اول و نام یک view را به عنوان آرگومان دوم دریافت می‌کند. علاوه بر این می‌توان آرایه‌ای از داده‌ها را برای انتقال به view به عنوان آرگومان سوم منتقل کنید که استفاده از این آرگومان اختیاری است:Route::view('/welcome', 'welcome');Route::view('/welcome', 'welcome', ['name' =&gt; 'Taylor']);پارامترهای مسیر (route parameters) در مسیریابی لاراولگاهی ممکن است نیاز به گرفتن بخش‌هایی از URI در مسیر خود داشته باشید. برای مثال، ممکن است نیاز به دریافت شناسه کاربر (id) از URL داشته باشید. این کار را می‌توان با تعیین پارامترهای مسیر انجام داد. به مثال زیر توجه کنید:Route::get('user/{id}', function ($id) {    return 'User '.$id;});همچنین می‌توان چند پارامتر موردنیاز را به صورت زیر تعریف کرد:Route::get('posts/{post}/comments/{comment}', function ($postId, $commentId) {    //});پارامترهای مسیر در داخل براکت {} قرار می‌گیرند و باید از حروف الفبا تشکیل شده باشند و نباید حاوی کاراکتر ( - ) باشد. به جای استفاده از کاراکتر ( - ) می‌توان از کاراکتر زیرخط ( _ ) استفاده کرد. پارامترهای مسیر به callback / controllers مسیر براساس سفارش تزریق می‌شوند. نام آرگومان‌های callback / controller زیاد مهم نیست.پارامترهای اختیاری یا Optional در مسیریابی لاراولگاهی ممکن است نیاز به تعیین پارامتر مسیر داشته باشید، اما استفاده از پارامتر مسیر را اختیاری کنید. این کار را می‌توان با قرار دادن یک علامت سوال ( ؟ ) بعد از نام پارامتر انجام داد:Route::get('user/{name?}', function ($name = null) {    return $name;});Route::get('user/{name?}', function ($name = 'John') {    return $name;});عبارات منظم (Regular Expression) در مسیریابی لاراولمی‌توان فرمت پارامترهای مسیر را با استفاده از متد where در یک نمونه مسیر تنظیم کرد. متد where نام پارامتر را دریافت می کند و عبارت منظمی که پارامتر بوسیله آن باید محدود شود را تعریف می‌کند :Route::get('user/{name}', function ($name) {    //})-&gt;where('name', '[A-Za-z]+');Route::get('user/{id}', function ($id) {    //})-&gt;where('id', '[0-9]+');Route::get('user/{id}/{name}', function ($id, $name) {    //})-&gt;where(['id' =&gt; '[0-9]+', 'name' =&gt; '[a-z]+']);استفاده از عبارات منظم به صورت عمومی در مسیریابی لاراولاگر بخواهید یک پارامتر مسیر همواره با یک «عبارات منظم» خاص محدود شود، می‌توانید از متد pattern استفاده کنید. این الگوها را در متد boot مربوط به RouteServiceProvider خود تعریف کنید:/** * Define your route model bindings, pattern filters, etc. * * @return void */public function boot(){    Route::pattern('id', '[0-9]+');    parent::boot();}زمانی که الگوی خاصی تعریف شده باشد، با استفاده از نام پارامتر به صورت خودکار به تمام مسیرها اعمال می‌شود:Route::get('user/{id}', function ($id) {    // Only executed if {id} is numeric...});مسیرهای نام‌گذاری شده در Routing مسیرهای نامگذاری شده (Named routes) این امکان را می‌دهد تا به راحتی برای آن‌ها URL تولید کنید یا از آن‌ها برای redirect کردن در برنامه استفاده کنید. برای اختصاص یک نام به یک مسیر از متد name در تعریف مسیر به صورت زیر استفاده کنید:Route::get('user/profile', function () {    //})-&gt;name('profile');همچنین می‌توان نام مسیر را به اکشن‌های یک کنترلر به صورت زیر اختصاص داد:Route::get('user/profile', 'UserController@showProfile')-&gt;name('profile');تولید URLها برای مسیرهای نامگذاری شده در لاراولزمانی که یک نام برای یک مسیر مشخص اختصاص دادید، از طریق تابع route عمومی، می‌توانید از نام مسیر در زمان تولید URLها یا تغییرمسیرها (redirect) به صورت زیر استفاده کنید:// Generating URLs...$url = route('profile');// Generating Redirects...return redirect()-&gt;route('profile');اگر مسیر نامگذاری شده شامل پارامتر باشد، می‌توانید پارامترها را به عنوان آرگومان دوم به تابع route منتقل کنید. پارامترهای داده شده به صورت خودکار به URL تولید شده وارد می‌شوند:Route::get('user/{id}/profile', function ($id) {    //})-&gt;name('profile');$url = route('profile', ['id' =&gt; 1]);بررسی مسیر فعلی در مسیر یابی لاراولبرای مشخص کردن اینکه آیا درخواست فعلی HTTP به یک مسیر نامگذاری شده هدایت شده است، می‌توانید از متد named در نمونه Route استفاده کنید. برای مثال، می‌توانید نام مسیر فعلی را در middleware مسیر چک کنید:/** * Handle an incoming request. * * @param  \\Illuminate\\Http\\Request  $request * @param  \\Closure  $next * @return mixed */public function handle($request, Closure $next){    if ($request-&gt;route()-&gt;named('profile')) {        //    }    return $next($request);}گروه‌های مسیر در لاراول Route Groupsممکن است برخی از ویژگی‌های مسیر، مانند middleware یا فضای نامی (namespaces)، در تعداد زیادی از مسیرها مشترک باشد. می‌توان بدون نیاز به تعریف جداگانه این ویژگی‌ها در هر یک از مسیرها، از امکان گروه‌ بندی مسیرها استفاده کرد و آن ویژگی‌ها را به تمام مسیرهای موجود در گروه اختصاص داد. ویژگی‌های به اشتراک گذاشته شده در قالب آرایه به عنوان اولین پارامتر در متد Route::group تعیین می‌شوند.مسیریابی در Middlewareبرای اختصاص یک Middleware به تمامی مسیرهای موجود در یک گروه، قبل از تعریف گروه می‌توانید از متد middleware استفاده کنید. Middlewareها به ترتیبی که در آرایه لیست شده‌اند بر روی مسیرها اعمال می‌شوند:Route::middleware(['first', 'second'])-&gt;group(function () {    Route::get('/', function () {        // Uses first &amp; second Middleware    });    Route::get('user/profile', function () {        // Uses first &amp; second Middleware    });});فضای نام Namespacesمی‌توان یک فضای نامی PHP را به یک گروه از کنترلرها با استفاده از متد namespace اختصاص داد:Route::namespace('Admin')-&gt;group(function () {    // Controllers Within The \"App\\Http\\Controllers\\Admin\" Namespace});در حالت پیش‌فرض، RouteServiceProvider فایل‌های مسیر را در یک گروه namespace قرار می‌دهد، که امکان می‌دهد تا مسیرهای کنترلر را بدون مشخص کردن پیشوند کامل App\\Http\\Controllers ثبت کنید. پس از آن فقط نیاز به مشخص کردن بخشی از فضای نامی دارید که بعد از App\\Http\\Controllers قرار دارد.در لاراول Sub-Domain مسیریابیاز گروه‌های مسیر همچنین برای مدیریت مسیریابی زیر دامنه (Sub-Domain) استفاده می‌شود. زیر دامنه‌ها پارامترهای مسیر مثل URIهای مسیر را اختصاص داده و همچنین امکان می‌دهند تا بخشی از زیر دامنه را برای استفاده در مسیر یا کنترلر خود دریافت کنید. می‌توان زیر دامنه را قبل از تعریف گروه با فراخوانی متد domain مشخص کرد:Route::domain('{account}.myapp.com')-&gt;group(function () {    Route::get('user/{id}', function ($account, $id) {        //    });});در مسیریابی لاراول Route پیشوندهایبرای اضافه کردن پیشوند به هر مسیر موجود در گروه از متد prefix استفاده می‌شود . برای مثال، در صورتیکه بخواهید تمام مسیرهای URIهای موجود در گروه، پیشوند admin را داشته باشد، به صورت زیر عمل کنید:Route::prefix('admin')-&gt;group(function () {    Route::get('users', function () {        // Matches The \"/admin/users\" URL    });});  Route Model Binding  در مسیریابی لاراولهنگام تزریق یک model ID به یک مسیر یا یک اکشن مربوط به کنترلر، اغلب یک پرس و جو برای بازیابی مدلی که مربوط به آن شناسه است، بکار می‌برید. binding مدل مسیر در لاراول راه مناسبی است که از طریق آن می‌توان به طور خودکار یک نمونه مدل را به طور مستقیم در مسیرها تزریق کرد. برای مثال، به جای تزریق یک شناسه کاربر (ID)، می‌توان کل نمونه مدل User که با شناسه داده شده مطابقت دارد را تزریق کرد. Implicit Binding : مسیریابی در لاراوللاراول به طور خودکار مدل‌های Eloquent تعریف شده در مسیرها یا اکشن‌های کنترلر که نام‌های متغیر type-hint شده آن‌ها با نام یک بخش از مسیر منطبق است را resolve می‌کند. مثال زیر را در نظر بگیرید:Route::get('api/users/{user}', function (App\\User $user) {    return $user-&gt;email;});از آنجایی که متغیر $user به عنوان Eloquent modelApp\\User  اعلان نوع یا type-hint شده است و نام متغیر با بخش {user} در URI مطابق است، لاراول به طور خودکار نمونه مدلی را که شناسه یا ID آن با مقدار موجود در URI منطبق است را تزریق می‌کند. اگر نمونه مطابق در پایگاه داده یافت نشود، یک پاسخ 404 HTTP به طور اتوماتیک تولید می‌شود. مسیریابی در لاراول : سفارشی سازی نام کلیداگر بخواهید binding مدل در پایگاه داده از ستونی غیر از id در هنگام بازیابی یک کلاس مدل استفاده کند، می‌توانید متد getRouteKeyName را در مدل Eloquent بازنویسی کنید:/** * Get the route key for the model. * * @return string */public function getRouteKeyName(){    return 'slug';} Explicit Binding : مسیریابی در لاراولبرای ثبت یک پیوند صریح (Explicit Binding)، از متد model روتر برای مشخص کردن کلاس برای یک پارامتر داده استفاده کنید. بایستی binding مدل صریح خود را در متد boot در کلاس RouteServiceProvider تعریف کنید:public function boot(){    parent::boot();    Route::model('user', App\\User::class);}سپس، مسیری را که شامل یک پارامتر {user} است را تعریف کنید:Route::get('profile/{user}', function (App\\User $user) {    //});از آنجایی که ما تمام پارامترهای {user} را به مدل App\\User محدود کرده‌ایم، نمونه‌ای از کلاس User به مسیر تزریق می‌شود. برای مثال، هنگام ایجاد یک درخواست برای profile/1 یک نمونه از کلاس User که دارای شناسه 1 است از پایگاه داده تزریق می‌شود.اگر نمونه مطابق با آن در پایگاه داده یافت نشود، یک پاسخ 404 HTTP به طور اتوماتیک تولید می‌شود.سفارشی سازی Resolution Logic در مسیریابی لاراولاگر بخواهید از Resolution Logic استفاده کنید، باید از متد Route::bind استفاده کنید. Closure به متد bind ، مقدار یک بخش از URI را دریافت می‌کند و نمونه کلاسی را که باید به مسیر تزریق شود را بازمی‌گرداند:public function boot(){    parent::boot();    Route::bind('user', function ($value) {        return App\\User::where('name', $value)-&gt;first() ?? abort(404);    });}جعل متد فرم در مسیریابی در لاراولفرم‌های HTML از عملیات PUT ، PATCH یا DELETE پشتیبانی نمی‌کنند. بنابراین، هنگام تعریف مسیرهای PUT ، PATCH یا DELETE که از یک فرم HTML فراخوانی می‌شوند، نیاز دارید یک فیلد _method مخفی را به فرم اضافه کنید. مقدار فرستاده شده با فیلد _method به عنوان متد درخواست HTTP مورد استفاده قرار می‌گیرد:&lt;form action=\"/foo/bar\" method=\"POST\"&gt;    &lt;input type=\"hidden\" name=\"_method\" value=\"PUT\"&gt;    &lt;input type=\"hidden\" name=\"_token\" value=\"{{ csrf_token() }}\"&gt;&lt;/form&gt;می‌توانید از تابع کمکی method_field برای تولید فیلد _method استفاده کنید: method_field('PUT')دسترسی به مسیر فعلی در لاراولمی‌توانید از متدهای current ، currentRouteName و currentRouteAction در  facade Route  برای دسترسی به اطلاعات مربوط به مسیر رسیدگی به درخواست ورودی استفاده کنید:$route = Route::current();$name = Route::currentRouteName();$action = Route::currentRouteAction();برای کسب اطلاعات بیشتر درباره کلاس پایه Route facade و Route instance، به مستندات API مراجعه کنید.",
            "url": "/documentation/laravel/The-Basics/routing"
          }
          ,
        
          "documentation-laravel-the-basics-middleware" :{
            "title": "آموزش Middleware",
            "content": "middleware مکانیزم مناسبی ارائه می‌دهد که به وسیله آن می‌توان درخواست‌های HTTP را قبل از ورود به برنامه فیلتر کرد. برای مثال، لاراول شامل یک middleware است که بوسیله آن می‌توان مشخص کرد که کاربر برنامه به درستی احراز هویت شده است یا خیر. اگر کاربر تایید نشده باشد، middleware کاربر را دوباره به صفحه ورود به سایت (Login) هدایت می‌کند. ولی اگر کاربر تأیید هویت شده باشد، middleware به درخواست اجازه می‌دهد تا به برنامه وارد شده و عملیات دیگری را نیز انجام دهد. در ادامه بیشتر به middleware در لاراول می‌پردازیم.البته، middlewareهای دیگری نیز برای انجام کارهای مختلف، علاوه بر احراز هویت نوشته شده است. برای مثال، یک CORS middleware مسئول اضافه کردن سرصفحه‌های مناسب به تمام پاسخ‌هایی است که از برنامه خارج می‌شوند. یک middleware ثبت وقایع، تمام درخواست‌های ورودی به برنامه را ثبت می‌کند.در فریم ورک لاراول چند middleware به صورت پیش فرض وجود دارند که از جمله آن‌ها می‌توان به middleware احراز هویت و حفاظت CSRF اشاره کرد. همه این middlewareها در دایرکتوری app/Http/Middleware قرار دارند.تعریف middleware برای ایجاد یک middleware جدید، از دستور آرتیسان make:middleware استفاده کنید:php artisan make:middleware CheckAgeاین دستور یک کلاس CheckAge جدید را در دایرکتوری app/Http/Middleware ایجاد می‌کند. در این middleware، فقط در صورتی که age بیشتر از 200 باشد، به مسیر دسترسی خواهیم داشت. در غیر این صورت، کاربران را به URI مربوط به home هدایت می‌شوند.&lt;?phpnamespace App\\Http\\Middleware;use Closure;class CheckAge{    /**     * Handle an incoming request.     *     * @param  \\Illuminate\\Http\\Request  $request     * @param  \\Closure  $next     * @return mixed     */    public function handle($request, Closure $next)    {        if ($request-&gt;age &lt;= 200) {            return redirect('home');        }        return $next($request);    }}همانطور که مشاهده می‌کنید، اگر age داده شده کمتر یا برابر 200 باشد، middleware یک HTTP redirect را به مشتری یا سرویس گیرنده بازمی‌گرداند؛ در غیر این صورت، درخواست به برنامه منتقل خواهد شد. برای ارسال محتاطانه یک درخواست به برنامه (middleware اجازه می‌دهد که درخواست یک pass به برنامه داشته باشد)، به سادگی تابع $next را با آرگومان $request فراخوانی کنید.می‌توان middleware را به عنوان مجموعه‌ای از لایه‌ها در نظر گرفت که درخواست های HTTP باید از آن‌ها عبور کنند و وارد برنامه شوند. هر لایه باید درخواست‌ها را بررسی کند و حتی می‌تواند آن‌ها را به طور کامل رد کند.انجام وظایف توسط Middleware قبل و بعد از اجرای درخواست در لاراولاینکه آیا middleware قبل یا بعد از درخواست اجرا ‌شود، بستگی به خود middleware دارد. برای مثال، middleware زیر برخی از کارها را قبل از پردازش درخواست توسط برنامه انجام می‌دهد:&lt;?phpnamespace App\\Http\\Middleware;use Closure;class BeforeMiddleware{    public function handle($request, Closure $next)    {        // Perform action        return $next($request);    }}ولی middleware مثال زیر وظیفه خود را پس از پردازش درخواست توسط برنامه انجام می‌دهد:&lt;?phpnamespace App\\Http\\Middleware;use Closure;class AfterMiddleware{    public function handle($request, Closure $next)    {        $response = $next($request);        // Perform action        return $response;    }}ثبت middleware بصورت Globalاگر می‌خواهید یک middleware بر روی هر درخواست HTTP در برنامه اجرا شود، می‌توانید به سادگی کلاس middleware را در خصوصت $middleware کلاس app/Http/Kernel.php لیست کنید.اختصاص middleware به مسیر در لاراولاگر می‌خواهید middleware را به مسیرهای خاصی اختصاص دهید، ابتدا باید یک کلید به middleware در فایل app/Http/Kernel.php اختصاص دهید. در حالت پیش‌فرض، ویژگی $routeMiddleware  در این کلاس شامل ثبت middlewareهایی است که در درون لاراول قرار دارند. برای افزودن middleware خود، به سادگی آن را به این لیست اضافه کنید و یک کلید به آن اختصاص دهید. مثال زیر را در نظر بگیرید:// Within App\\Http\\Kernel Class...protected $routeMiddleware = [    'auth' =&gt; \\Illuminate\\Auth\\Middleware\\Authenticate::class,    'auth.basic' =&gt; \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class,    'bindings' =&gt; \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,    'can' =&gt; \\Illuminate\\Auth\\Middleware\\Authorize::class,    'guest' =&gt; \\App\\Http\\Middleware\\RedirectIfAuthenticated::class,    'throttle' =&gt; \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class,]; زمانی که middleware در هسته HTTP تعریف شده باشد، می‌توان از متد middleware برای اختصاص middleware به یک مسیر استفاده کرد:Route::get('admin/profile', function () {    //})-&gt;middleware('auth');همچنین می‌توان چند middleware را به مسیر مانند مثال زیر اختصاص داد:Route::get('/', function () {    //})-&gt;middleware('first', 'second');هنگام تعیین middleware، همچنین می‌توانید نام کامل کلاس موردنظر را منتقل کنید:use App\\Http\\Middleware\\CheckAge;Route::get('admin/profile', function () {    //})-&gt;middleware(CheckAge::class);middleware گروه بندی شده در لاراولگاهی اوقات ممکن است بخواهید چند middleware را با یک کلید واحد گروه بندی کنید تا به راحتی بتوانید آن‌ها را به مسیرها اختصاص دهید. این کار را با استفاده از خصوصیت $middlewareGroups در هسته HTTP می‌توان انجام داد.علاوه بر middlewareهای پیش‌فرض لاراول،   web   و api دو گروه middleware هستند که شامل یک middleware مشترکند که ممکن است بخواهید آن‌ها را به web UI و API routes  اعمال کنید:/** * The application's route middleware groups. * * @var array */protected $middlewareGroups = [    'web' =&gt; [        \\App\\Http\\Middleware\\EncryptCookies::class,        \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class,        \\Illuminate\\Session\\Middleware\\StartSession::class,        \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class,        \\App\\Http\\Middleware\\VerifyCsrfToken::class,        \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,    ],    'api' =&gt; [        'throttle:60,1',        'auth:api',    ],];روش اختصاص middlewareهای گروه بندی شده به مسیرها و اکشن‌های کنترلر، مثل روش اختصاص middlewareهای تکی است. با استفاده از middlewareهای گروه بندی شده اختصاص چندین middleware به یک مسیر به راحتی انجام می‌گیرد.Route::get('/', function () {    //})-&gt;middleware('web');Route::group(['middleware' =&gt; ['web']], function () {    //});گروه middleware web به صورت خودکار توسط RouteServiceProvider به فایل routes/web.php اعمال می‌شود.middleware پارامترهایهمچنین middleware می‌تواند پارامترهای اضافی نیز دریافت کند. برای مثال، اگر برنامه قبل از انجام هر عملی خاصی از سوی کاربر احراز هویت شده، نیازمند مشخص کردن role مربوط به آن کاربر نیز باشد، بایستی یک middleware CheckRole  ایجاد کنید که نام role را به عنوان یک آرگومان دریافت می‌کند.پارامترهای اضافی بعد از آرگومان $next به middleware منتقل می‌شوند:&lt;?phpnamespace App\\Http\\Middleware;use Closure;class CheckRole{    /**     * Handle the incoming request.     *     * @param  \\Illuminate\\Http\\Request  $request     * @param  \\Closure  $next     * @param  string  $role     * @return mixed     */    public function handle($request, Closure $next, $role)    {        if (! $request-&gt;user()-&gt;hasRole($role)) {            // Redirect...        }        return $next($request);    }}برای مشخص کردن پارامتر middleware در هنگام تعیین مسیر، نام middleware و پارامترها با یک علامت : جدا می‌شوند. برای جدا کردن چند پارامتر باید از کاما استفاده کنید:Route::put('post/{id}', function ($id) {    //})-&gt;middleware('role:editor');Middleware پایان‌ پذیر (Terminable Middleware)گاهی اوقات بایستی بعضی از کارها توسط یک middleware پس از ارسال پاسخ HTTP به مرورگر، انجام شود. برای مثال، session middleware که به صورت ‌پیش‌فرض در لاراول قرار دارد، اطلاعات session را پس از ارسال پاسخ به مرورگر در حافظه می‌نویسد. اگر متد terminate را در middleware خود تعریف کنید، به صورت خودکار پس از ارسال پاسخ به مرورگر آن را فراخوانی می‌کند.&lt;?phpnamespace Illuminate\\Session\\Middleware;use Closure;class StartSession{    public function handle($request, Closure $next)    {        return $next($request);    }    public function terminate($request, $response)    {        // Store the session data...    }}متد terminate باید هم درخواست و هم پاسخ را دریافت کند. زمانی که یک middleware پایان ‌پذیر را تعریف می‌کنید، باید آن را به لیست مسیر یا middlewareهای عمومی در فایل app/Http/Kernel.php اضافه کنید.هنگام فراخوانی متد terminate  در middleware، لاراول یک نمونه از middleware را در service container بایند می‌کند. زمانی که متدهای handle و terminate فراخوانی می‌شوند، اگر بخواهید از یک middleware مشترک استفاده کنید، باید middleware را در  container با استفاده از متد singleton ثبت کنید.",
            "url": "/documentation/laravel/The-Basics/middleware"
          }
          ,
        
          "documentation-laravel-the-basics-csrf" :{
            "title": "حفاظت CSRF",
            "content": "به حملاتی که از طریق درخواست‌های متقابل جعلی به سایت صورت می‌گیرد، CSRF گفته می‌شود. ان عبارت مخفف عبارت cross-site request forgery است. لاراول یک روش آسان برای حفاظت در برابر این حملات ارائه می‌دهد. درخواست‌های متقابل جعلی نوعی سوءاستفاده مخرب است که به موجب آن هکرها دستورات غیرمجاز را از طریق کاربر لاگین شده اجرا می‌کنند. در این در از آموزش لاراوال 5.5 با هم این قابلیت لاراول را بررسی می‌کنیم.هر کاربر فعال که توسط برنامه مدیریت می‌شود، یک سشن دارد. لاراول به صورت خودکار یک نشانه CSRF برای هر سشن تولید می‌کند. از این نشانه برای شناسایی کاربر لاگین شده‌ که درخواست‌ها را به صورت واقعی به برنامه می‌فرستد، استفاده می‌کنیم.هر زمان که یک فرم HTML را در برنامه خود تعریف می‌کنید، باید فیلد پنهان CSRF را در درون فرم قرار دهید تا middleware مربوط به حفاظت CSRF بتواند درخواست کاربر را تایید کند. برای تولید فیلد نشانه می‌توان از تابع کمکی csrf_field به صورت زیر استفاده کرد:&lt;form method=\"POST\" action=\"/profile\"&gt;    {{ csrf_field() }}    ...&lt;/form&gt;middlewareVerifyCsrfToken، که در گروه middleware web قرار دارد، به صورت خودکار نشانه‌ی موجود در درخواست ورودی برنامه را با نشانه ذخیره شده در سشن (session) کاربر مقایسه می‌کند تا مشخص کند که با هم مطابقت دارند یا خیر.توکن CSRF و جاوا اسکریپتدر هنگام ایجاد برنامه‌های کاربردی تحت جاوا اسکریپت، برای راحتی کار، به صورت خودکار کتابخانه HTTP جاوا اسکریپت نشانه CSRF را برای هر درخواست خروجی پیوست می‌کند. در حالت پیش‌فرض، فایل resources/assets/js/bootstrap.js مقدار تگ متا csrf-token را با کتابخانه Axisse HTTP ثبت می‌کند. اگر از این کتابخانه در برنامه خود استفاده نمی‌کنید، باید این کار را به صورت دستی برای برنامه خود پیکربندی کنید.حذف برخی از URIها از حفاظت CSRF در لاراولگاهی اوقات ممکن است بخواهید مجموعه‌ای از URIها را از حفاظت CSRF حذف کنید. برای مثال، اگر از روش Stripe برای پردازش پرداخت‌ها استفاده می‌کنید و همچنین از سیستم webhook نیز بهره می‌برید، باید مسیر Stripe webhook handler خود را از حفاظت CSRF حذف کنید، زیرا Stripe نمی‌داند که کدام نشانه CSRF برای مسیرهای شما ارسال می‌شود.این نوع مسیرها را باید خارج از گروه middlewareweb  قرار دهید که RouteServiceProvider در تمام مسیرها در فایل routes/web.php اعمال می‌کند. می‌توانید مسیرها را با اضافه کردن URIهای خود به خصوصیت $except به middleware VerifyCsrfToken حذف کنید:&lt;?phpnamespace App\\Http\\Middleware;use Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken as Middleware;class VerifyCsrfToken extends Middleware{    /**     * The URIs that should be excluded from CSRF verification.     *     * @var array     */    protected $except = [        'stripe/*',        'http://example.com/foo/bar',        'http://example.com/foo/*',    ];}در لاراول X-CSRF-TOKENmiddlewareVerifyCsrfToken  علاوه بر چک کردن نشانه CSRF به عنوان پارامتر POST، همچنین هدر درخواست X-CSRF-TOKEN  را بررسی می‌کند. می‌توانید نشانه را در یک تگ meta مربوط به HTML ذخیره کنید:&lt;meta name=\"csrf-token\" content=\"{{ csrf_token() }}\"&gt;زمانی که تگ meta را ایجاد کردید، می‌توانید به یک کتابخانه مانند jQuery بگویید که به صورت خودکار نشانه‌ها را به تمام هدرهای درخواست اضافه کند. این روش، یک محافظت ساده و روان CSRF برای برنامه‌های مبتنی بر AJAX فراهم می‌‌کند:$.ajaxSetup({    headers: {        'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content')    }}); By default, the resources/assets/js/bootstrap.js file registers the value of the csrf-token meta tag with the Axios HTTP library. If you are not using this library, you will need to manually configure this behavior for your application.در لاراول X-XSRF-TOKENلاراول نشانه CSRF فعلی را در کوکی XSRF-TOKEN ذخیره می‌کند که هر پاسخی که توسط فریم ورک تولید شده است را شامل می‌شود. می‌توانید از مقدار کوکی برای تنظیم هدر درخواست X-XSRF-TOKEN استفاده کنید.برخی از کتابخانه‌ها و فریم ورک‌های جاوا اسکریپت، مانند Angular و Axios، این مقدار را به صورت خودکار در هدر X-XSRF-TOKEN قرار می‌دهند.",
            "url": "/documentation/laravel/The-Basics/csrf"
          }
          ,
        
          "documentation-laravel-the-basics-controllers" :{
            "title": "استفاده از Controller",
            "content": "به جای تعریف منطق مدیریت درخواست‌های برنامه به عنوان تابع Closure در فایل‌های مسیر لاراول، می‌توانید این کارها را با استفاده از کلاس‌های کنترلر انجام دهید. کنترلرها منطق پردازش درخواست‌های مرتبط به هم را در یک کلاس واحد دسته بندی می‌کنند. کنترلرها در دایرکتوری app/Http/Controllers قرار می‌گیرند. در ادامه چگونگی کار با کنترلرها و مسیردهی به آن‌ها را با هم بررسی می‌کنیم. پایه در لاراولتعریف Controllersدر مثال زیر نمونه‌ای از کلاس کنترلر پایه را مشاهده می‌کنید. توجه کنید که کنترلرهای برنامه از کلاس کنترلر پایه که به صورت پیش‌فرض در لاراول قرار دارد، ارث بری می‌کنند. کلاس پایه چندین متد ارائه می‌دهد، برای مثال متد middleware برای اتصال middleware به اکشن‌های کنترلر مورد استفاده قرار می‌گیرد:&lt;?phpnamespace App\\Http\\Controllers;use App\\User;use App\\Http\\Controllers\\Controller;class UserController extends Controller{    /**     * Show the profile for the given user.     *     * @param  int  $id     * @return Response     */    public function show($id)    {        return view('user.profile', ['user' =&gt; User::findOrFail($id)]);    }}می‌توان یک مسیر مانند مثال زیر برای این کنترلر تعریف کرد:Route::get('user/{id}', 'UserController@show');زمانی که یک درخواست ورودی با URI مربوط به مسیر مطابقت داشته باشد، متد show در کلاس UserController اجرا خواهد شد. همچنین پارامترهای موجود در مسیر نیز به متد ارسال می‌شوند.کنترلرها را می‌توان بدون نیاز به ارث بری از یک کلاس پایه تعریف کرد. اما در این صورت به امکاناتی مانند استفاده از متدهای middleware ، validate و dispatch دسترسی نخواهید داشت.استفاده از controller و namespace در لاراولنکته مهمی که باید به آن توجه داشته باشیم این است که در هنگام تعیین مسیر کنترلر، نیازی نیست که فضای نامی کنترلر را به صورت کامل تعریف کنیم. از آنجا که RouteServiceProvider فایل‌های مسیر را در یک گروه مسیر که فضای نامی ریشه را شامل می‌شود، بارگزاری می‌کند؛ فقط آن بخش از نام کلاس که بعد از بخش App\\Http\\Controllers در فضای نامی قرار دارد را مشخص می‌کنیم.اگر بخواهید کنترلرها توسط فضای نامی در دایرکتوری App\\Http\\Controllers به صورت تودرتو گروه بندی کنید، می‌توانید به سادگی از نام کلاس خاصی نسبت به فضای نامی ریشه App\\Http\\Controllers استفاده کنید. بنابراین، اگر کلاس کامل کنترلر شما App\\Http\\Controllers\\Photos\\AdminController است، باید مانند مثال زیر مسیر را برای کنترلر ثبت کنید:Route::get('foo', 'Photos\\AdminController@method');کنترلرهای تک اکشن (Single Action Controllers) در لاراولاگر بخواهید کنترلری تعریف کنید که فقط یک اکشن داشته باشد، باید یک متد __invoke را در کنترلر قرار دهید:&lt;?phpnamespace App\\Http\\Controllers;use App\\User;use App\\Http\\Controllers\\Controller;class ShowProfile extends Controller{    /**     * Show the profile for the given user.     *     * @param  int  $id     * @return Response     */    public function __invoke($id)    {        return view('user.profile', ['user' =&gt; User::findOrFail($id)]);    }}در هنگام ثبت مسیر، مشخص کردن متد تعریف شده برای کنترلرهای single action نیاز نیست. به مثال زیر توجه کنید:Route::get('user/{id}', 'ShowProfile');Controller Middleware در لاراولمی‌توان یک middleware را به مسیرهای کنترلر در فایل‌های مسیر به صورت زیر اختصاص داد:Route::get('profile', 'UserController@show')-&gt;middleware('auth');با این حال، برای راحتی کار می‌توان middleware را در سازنده کنترلر تعریف کرد. با استفاده از متد middleware در سازنده کنترلر، می‌توان به راحتی middleware را به اکشن کنترلر اختصاص داد. حتی می‌توان middleware را به متدهای خاصی در کلاس کنترلر محدود کرد:class UserController extends Controller{    /**     * Instantiate a new controller instance.     *     * @return void     */    public function __construct()    {        $this-&gt;middleware('auth');        $this-&gt;middleware('log')-&gt;only('index');        $this-&gt;middleware('subscribed')-&gt;except('store');    }}همچنین کنترلر امکان ثبت middleware با استفاده از Closure را فراهم می‌کند. این موضوع روش مناسبی جهت تعریف middleware برای یک کنترلر بدون نیاز به تعریف کلاس کلی middleware است.$this-&gt;middleware(function ($request, $next) {    // ...    return $next($request);}); می‌توان middleware را به زیرمجموعه‌ای از اکشن‌های یک کنترلر اختصاص داد؛ با این حال، این موضوع نشان دهنده رشد بیش از حد کنترلر است. می‌توان به جای این کار، کنترلر را به کنترلرهای کوچکتر تقسیم کرد.کنترلر منابع یا resource controllers در لاراولدر مسیریابی منابع لاراول، مسیرهای معمول عملیات CRUD را می‌توان با یک خط کد به یک کنترلر اختصاص داد. برای مثال، اگر بخواهید کنترلری ایجاد کنید که تمام درخواست‌های HTTP برای عکس‌های ذخیره شده توسط برنامه را مدیریت کند، می‌توان به سرعت و با استفاده از دستور make:controller این کنترلر را ایجاد کرد:php artisan make:controller PhotoController --resourceاین دستور کنترلر را در app/Http/Controllers/PhotoController.php ایجاد می‌کند. این کنترلر برای هر یک از عملیات مربوط به منابع موجود، یک متد را شامل می‌شود.سپس، می‌توان یک مسیر خوب برای کنترلر مانند مثال زیر ثبت کرد:Route::resource('photos', 'PhotoController');این اعلان ساده مسیر، مسیرهای متعددی را برای مدیریت انواع عملیات بر روی منابع (عکس‌ها) ایجاد می‌کند. اکنون کنترلر ایجاد شده متدهایی را برای هر کدام از این عملیات، ارائه کرده است. این متدها شامل یادداشت‌هایی هستند که مشخص می‌کند کدام درخواست‌های HTTP و URIها توسط آن‌ها مدیریت می‌شوند.می‌توان چند کنترلر منابع را در یک زمان بوسیله انتقال یک آرایه به متد resources ثبت کرد:Route::resources([    'photos' =&gt; 'PhotoController',    'posts' =&gt; 'PostController']);عملیاتی که توسط کنترلر منابع مدیریت می‌شود:VerbURIActionRoute NameGET/photosindexphotos.indexGET/photos/createcreatephotos.createPOST/photosstorephotos.storeGET/photos/{photo}showphotos.showGET/photos/{photo}/editeditphotos.editPUT/PATCH/photos/{photo}updatephotos.updateDELETE/photos/{photo}destroyphotos.destroyتعیین مدل منابع (Resource Model) در لاراولاگر از binding مدل مسیر استفاده می‌کنید و مایلید متدهای کنترلر منابع را به یک نمونه مدل type-hint کنید، می‌توانید از گزینه --model هنگام ایجاد کنترلر استفاده کنید:php artisan make:controller PhotoController --resource --model=Photoمتدهای فرم جعلی در لاراولاز آنجا که فرم‌های HTML نمی‌توانند درخواست‌های PUT ، PATCH یا DELETE را ایجاد کنند، باید یک فیلد پنهان _method برای ایجاد جعلی این درخواست‌های HTTP اضافه کنید. تابع کمکی method_field این فیلد را برای شما ایجاد می‌کند:{{ method_field('PUT') }}اعلان مسیر‌های منابع به صورت سفارشی در لاراولهنگام اعلان یک مسیر منابع، می‌توان زیرمجموعه‌ای از عملیاتی که کنترلر باید مدیریت کند را به جای مجموعه کامل عملیات پیش‌فرض تعریف کرد:Route::resource('photo', 'PhotoController', ['only' =&gt; [    'index', 'show']]);Route::resource('photo', 'PhotoController', ['except' =&gt; [    'create', 'store', 'update', 'destroy']]);اعلان مسیرهای منابع API در لاراولهنگام اعلان مسیرهای منابعی که توسط APIها استفاده می‌شوند، معمولا مسیرهای مربوط به عملیات create و edit را در قالب های HTML حذف می‌کنید. برای راحتی کار، می‌توانید متد apiResource را استفاده کنید که به صورت خودکار این دو مسیر را حذف می‌کند:Route::apiResource('photo', 'PhotoController');می‌توان چندین کنترلر API را در یک زمان با انتقال یک آرایه به متد apiResource ثبت کرد:Route::apiResources([    'photos' =&gt; 'PhotoController',    'posts' =&gt; 'PostController']);نام‌گذاری مسیرهای منابع در لاراولدر حالت پیش‌فرض تمام اکشن‌های کنترلر منابع دارای یک نام مسیر یا route name هستند؛ با این حال، می‌توانید این نام‌ها را با انتقال یک آرایه names با گزینه‌های موردنظر خود بازنویسی کنید:Route::resource('photo', 'PhotoController', ['names' =&gt; [    'create' =&gt; 'photo.build']]);پارامترهای مربوط به نام‌گذاری مسیرهای منابع در لاراولدر حالت پیش‌فرض، Route::resource پارامترهای مسیر را برای مسیرهای منابع بر اساس نام‌های یکتا سازی شده منابع ایجاد می‌کند. می‌توان این نام‌ها را براساس هر منبع، توسط انتقال آرایه گزینه‌های parameters بازنویسی کرد. آرایه parameters باید یک آرایه ترکیبی از نام‌های منابع و نام‌های پارامترها باشد:Route::resource('user', 'AdminUserController', ['parameters' =&gt; [    'user' =&gt; 'admin_user']]);مثال فوق URIهای زیر را برای مسیر show منابع ایجاد می‌کند:/user/{admin_user}ایجاد URLهای منابع به صورت محلی در لاراولدر حالت پیش‌فرض، URLهای منابع توسط Route::resource با استفاده از کلمات انگلیسی ایجاد می‌کند. برای مثال، اگر نیاز به محلی سازی کلمات اکشن‌های create و edit دارید، می‌توانید از متد Route::resourceVerbs استفاده کنید و در متد boot مربوط به AppServiceProvider این عمل را انجام دهید:use Illuminate\\Support\\Facades\\Route;/** * Bootstrap any application services. * * @return void */public function boot(){    Route::resourceVerbs([        'create' =&gt; 'crear',        'edit' =&gt; 'editar',    ]);}زمانی که کلمات محلی سازی شدند، URIهای زیر توسط ثبت منابع مسیر Route::resource('fotos', 'PhotoController') ،   تولید می‌‌شود:/fotos/crear/fotos/{foto}/editarاضافه کردن مسیرهای اضافی به کنترلر منابع در لاراولاگر نیاز به اضافه کردن مسیرهای اضافی، علاوه بر مجموعه پیش‌فرض مسیرهای منابع به یک کنترلر منابع دارید، قبل از فراخوانی Route::resource شما باید این مسیرها را تعریف کنید، در غیر این صورت، مسیرهای تعریف شده توسط متد resource بر روی مسیرهای اضافی که قصد اضافه کردن آن‌ها را داریم، اولویت خواهند داشت:Route::get('photos/popular', 'PhotoController@method');Route::resource('photos', 'PhotoController'); Remember to keep your controllers focused. If you find yourself routinely needing methods outside of the typical set of resource actions, consider splitting your controller into two, smaller controllers.تزریق وابستگی و Controller در لاراولاز  service container لاراول برای resolve کردن تمام کنترلرهای لاراول استفاده می‌شود. در نتیجه، قادر خواهیم بود، هر وابستگی که ممکن است کنترلر در سازنده به آن نیاز داشته باشد را اعلان نوع یا type-hint کنیم. وابستگی‌های اعلان شده به صورت خودکار resolve می‌شوند و تزریق وابستگی به نمونه‌ی کنترلر انجام می‌شود:&lt;?phpnamespace App\\Http\\Controllers;use App\\Repositories\\UserRepository;class UserController extends Controller{    /**     * The user repository instance.     */    protected $users;    /**     * Create a new controller instance.     *     * @param  UserRepository  $users     * @return void     */    public function __construct(UserRepository $users)    {        $this-&gt;users = $users;    }}همچنین می‌توانید هر قرارداد لاراول را نیز اعلان نوع یا type-hint کنید. اگر container می‌تواند آن را resolve کند، می‌توانید آن را اعلان نوع کنید. بسته به برنامه، تزریق وابستگی‌ها به کنترلر، ممکن است تست پذیری بهتری را فراهم کند.تزریق وابستگی به متد در لاراولعلاوه بر تزریق وابستگی در سازنده، می‌توانید وابستگی‌ها را در متدهای کنترلر نیز type-hint کنید. یک مورد استفاده معمول برای روش تزریق در متد، تزریق نمونه Illuminate\\Http\\Request به متد کنترلر مانند مثال زیر است:&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller{    /**     * Store a new user.     *     * @param  Request  $request     * @return Response     */    public function store(Request $request)    {        $name = $request-&gt;name;        //    }}اگر متد کنترلر انتظار دریافت ورودی از یک پارامتر مسیر را دارد، می‌توانید به سادگی آرگومان‌های مسیر را پس از وابستگی‌ها لیست کنید. برای مثال، اگر مسیر شما به صورت مثال زیر تعریف شده باشد:Route::put('user/{id}', 'UserController@update');می‌توانید Illuminate\\Http\\Request را اعلان نوع کنید و با تعریف متد کنترلر خود به صورت زیر به پارامتر id دسترسی داشته باشید:&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller{    /**     * Update the given user.     *     * @param  Request  $request     * @param  string  $id     * @return Response     */    public function update(Request $request, $id)    {        //    }}ذخیره سازی مسیر در حافظه نهان (route caching) در لاراول مسیرهای مبتنی بر Closure با مسیرهای ذخیره شده در کش سازگاری ندارند. برای استفاده از route caching، بایستی هر مسیر مبتنی بر Closure را به کلاس‌های کنترلر تبدیل کنید.اگر برنامه شما به صورت انحصاری از مسیرهای مبتنی بر کنترلر استفاده می‌کند، می‌توانید به راحتی از route caching در لاراول استفاده کنید. استفاده از route cache به میزان قابل توجهی زمان لازم برای ثبت تمام مسیرهای برنامه در لاراول را کاهش می‌دهد. در برخی موارد، با استفاده از این روش ثبت مسیر می‌تواند حتی تا 100 برابر سریع‌تر انجام شود. برای ساخت یک route cache، باید دستور آرتیسان route:cache را اجرا کنید:php artisan route:cacheپس از اجرای این دستور، فایل مسیرهای کش شده بر روی هر درخواست بارگزاری می‌شود. توجه کنید، اگر بخواهید هر مسیر جدیدی را اضافه کنید، باید یک route cache جدید ایجاد کنید. به همین دلیل، توصیه می‌شود، دستور route:cache را در هنگام استقرار و نصب پروژه اجرا نمایید.می‌توانید از دستور route:clear مانند مثال زیر برای پاک کردن route cache استفاده کنید:php artisan route:clearدر این مقاله از سری مقالات آموزشی لاراول در لیداوب قصد ما آشنا کردن شما با مبحث مهم و کلیدی کنترلرهای لاراول و چگونگی کار با آن‌ها و همچنین مسیردهی آن‌ها بود. امیدواریم این مقاله به شما کرده باشد، تا هر چه سریعتر بتوانید با اصول اولیه و مفاهیم لاراول آشنا شده و راه یادگیری خود را هموار کنید.",
            "url": "/documentation/laravel/The-Basics/controllers"
          }
          ,
        
          "documentation-laravel-the-basics-requests" :{
            "title": "اصول requests",
            "content": "برای دسترسی به نمونه‌ای از درخواست HTTP فعلی در لاراول از طریق روش تزریق وابستگی (dependency injection)، باید نمونه کلاس Illuminate\\Http\\Request را در متد کنترلر خود اعلان نوع یا type-hint کنید. درخواست ورودی به صورت خودکار توسط service container تزریق می‌شود:&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller{    /**     * Store a new user.     *     * @param  Request  $request     * @return Response     */    public function store(Request $request)    {        $name = $request-&gt;input('name');        //    }}تزریق وابستگی و استفاده از پارامترهای مسیردر صورتی که، متد کنترلر در انتظار دریافت ورودی از یک پارامتر مسیر باشد، می‌توانید پارامترهای مسیر را پس از وابستگی‌های دیگر لیست کنید. برای مثال، اگر مسیر شما مانند مثال زیر تعریف شده باشد:Route::put('user/{id}', 'UserController@update');می‌توانید نمونه کلاس Illuminate\\Http\\Request را اعلان نوع کنید و با تعریف متد کنترلر به صورت مثال زیر به پارامتر مسیر یا همان id ، دسترسی داشته باشید:&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller{    /**     * Update the specified user.     *     * @param  Request  $request     * @param  string  $id     * @return Response     */    public function update(Request $request, $id)    {        //    }}دسترسی به درخواست HTTP  از طریق route closureهمچنین، می‌توانید نمونه کلاس Illuminate\\Http\\Request را در route closure اعلان نوع کنید. service container به صورت خودکار درخواست ورودی را به Closure در هنگام اجرای آن تزریق می‌کند:use Illuminate\\Http\\Request;Route::get('/', function (Request $request) {    //});به کارگیری متد‌ها و مسیر در درخواست HTTP جهت بررسی درخواست HTTP در برنامه، نمونه کلاس Illuminate\\Http\\Request چندین متد ارائه می‌دهد و از کلاس Symfony\\Component\\HttpFoundation\\Request ارث بری می‌کند. در ادامه، برخی از مهمترین متدهای این کلاس را با هم بررسی می‌کنیم.بازیابی مسیر درخواست‌ها HTTP متد path اطلاعات مربوط به مسیر یک درخواست را بازمی‌گرداند. بنابراین، اگر درخواست ورودی به آدرس http://domain.com/foo/bar ارسال شود، این متد قسمت foo/bar را بازمی‌گرداند:$uri = $request-&gt;path();توسط متد is می‌توانید مطمئن شوید که مسیر درخواست ورودی مطابق با یک الگوی خاص تعریف شده است یا خیر. در هنگام استفاده از این متد می‌توان کاراکتر * را نیز به عنوان یک wildcard بکار برد:if ($request-&gt;is('admin/*')) {    //}دریافت URL درخواست‌ها برای بازیابی URL کامل یک درخواست ورودی، می‌توانید متد url یا fullUrl را بکار ببرید. متد url برای بازیابی URL بدون رشته پرس و جو بکار می‌رود، در حالی که متد fullUrl رشته پرس و جو را نیز شامل می‌شود.// Without Query String...$url = $request-&gt;url();// With Query String...$url = $request-&gt;fullUrl();بازیابی متد درخواست‌ها متد method فعل یا متد درخواست HTTP را برای یک درخواست بازگشت می‌دهد. می‌توانید از متد isMethod برای بررسی اینکه متد درخواست HTTP با یک رشته مشخص مطابق است یا خیر، استفاده کنید:$method = $request-&gt;method();if ($request-&gt;isMethod('post')) {    //}استفاده از درخواست‌های PSR-7استاندارد PSR-7 رابط‌هایی را برای پیغام‌های HTTP مانند درخواست‌ها و پاسخ‌ها ارائه می‌دهد. اگر می‌خواهید به نمونه‌ای از درخواست PSR-7 به جای یک درخواست لاراول دسترسی داشته باشید، در ابتدا بایستی چند کتابخانه مهم را نصب کنید. لاراول از کامپوننت Symfony HTTP Message Bridge برای تبدیل درخواست‌ها و پاسخ‌های لاراول به پیاده سازی‌های سازگار با PSR-7 استفاده می‌کند:composer require symfony/psr-http-message-bridgecomposer require zendframework/zend-diactorosزمانی که این کتابخانه‌ها را نصب کردید، می‌توانید با type-hint کردن رابط درخواست درroute Closure یا متد کنترلر خود به یک درخواست PSR-7 دسترسی داشته باشید:use Psr\\Http\\Message\\ServerRequestInterface;Route::get('/', function (ServerRequestInterface $request) {    //}); اگر نمونه‌ای از پاسخ PSR-7 از یک مسیر یا کنترلر برگردانده شود، این پاسخ به صورت خودکار به یک پاسخ لاراول تبدیل می‌شود و توسط فریم ورک نمایش داده می‌شود.مرتب سازی ورودی درخواست HTTPبه صورت پیش‌فرض middlewareهای TrimStrings و ConvertEmptyStringsToNull در پشته middleware عمومی برنامه لاراول قرار دارند. این middlewareها توسط کلاس App\\Http\\Kernel در پشته لیست شده‌اند. این middlewareها به صورت خودکار تمام فیلدهای رشته ورودی بر روی درخواست را مرتب می‌کنند، همچنین هر فیلد رشته خالی را به null تبدیل می‌کنند. این موضوع باعث می‌شود تا هیچ نگرانی در مورد کارهای کوچک و عادی از این قبیل، در مسیرها و کنترلرهای خود نداشته نباشیم.اگر می‌خواهید این ویژگی را در برنامه خود غیرفعال کنید، می‌توانید این دو middleware را از پشته middleware برنامه خود حذف کنید، می‌توانید این کار را با حذف آن‌ها از خصوصیت $middleware کلاس App\\Http\\Kernel انجام دهید.دريافت ورودی درخواست در لاراولبازیابی تمام داده‌های ورودی درخواستمی‌توانید تمام داده‌های ورودی را به عنوان یک array با استفاده از متد all بازیابی کنید:$input = $request-&gt;all();بازیابی مقدار ورودی درخواست با استفاده از چند متد ساده، می‌توانید به تمام ورودی‌های کاربر از نمونه کلاس Illuminate\\Http\\Request دسترسی داشته باشید و نگران اینکه کدام متد HTTP برای درخواست استفاده شود، نباشید. صرف نظر از متد درخواست HTTP، از متد input نیز می‌توانید برای بازیابی ورودی کاربر استفاده کنید:$name = $request-&gt;input('name');می‌توانید یک مقدار پیش‌فرض را به عنوان آرگومان دوم به متد input منتقل کنید. اگر مقدار ورودی در درخواست کاربر موجود نباشد، این مقدار بازگردانده خواهد شد:$name = $request-&gt;input('name', 'Sally');در هنگام کار با فرم‌هایی که ورودی‌های آن‌ها به صورت آرایه‌ای هستند، می‌توانید از علامت «نقطه» برای دسترسی به آرایه‌ها استفاده کنید:$name = $request-&gt;input('products.0.name');$names = $request-&gt;input('products.*.name');گرفتن ورودی از رشته پرس و جو درخواستدر حالی که متد input مقادیر را از کل درخواست کاربر (شامل رشته پرس و جو) بازیابی می‌کند، متد query ، مقادیر را فقط از رشته پرس و جو بازیابی می‌کند:$name = $request-&gt;query('name');اگر مقدار داده رشته پرس و جو درخواست شده موجود نباشد، آرگومان دوم این متد بازگشت داده می‌شود:$name = $request-&gt;query('name', 'Helen');می‌توانید متد query را بدون هیچ آرگومانی به منظور بازیابی تمام مقادیر رشته پرس و جو به عنوان یک آرایه انجمنی فراخوانی کنید:$query = $request-&gt;query();دریافت ورودی درخواست از طریق خصوصیات پویا همچنین، می‌توانید به ورودی کاربر با استفاده از خواص پویا بر روی نمونه کلاس Illuminate\\Http\\Request دسترسی داشته باشید. برای مثال، اگر یکی از فرم‌های درخواست، شامل یک فیلد name باشد، می‌توانید به مقدار فیلد مانند مثال زیر دسترسی داشته باشید:$name = $request-&gt;name;هنگام استفاده از خواص پویا، لاراول ابتدا مقدار پارامتر را در کل درخواست جستجو می‌کند. اگر مقدار پارامتر موجود نباشد، لاراول مقدار پارامتر را در پارامترهای مسیر جستجو می‌کند.بازیابی مقادیر ورودی JSON در درخواست لاراولهنگام ارسال درخواست‌های JSON به برنامه، تا زمانی که هدر Content-Type درخواست به درستی بر روی application/json تنظیم شده باشد، می‌توانید از طریق متد input به داده‌های JSON دسترسی داشته باشید. حتی می‌توانید از علامت «نقطه» برای کاوش در آرایه‌های JSON استفاده کنید:$name = $request-&gt;input('user.name');بازیابی بخش‌هایی از داده‌های ورودی اگر نیاز به بازیابی زیرمجموعه‌ای از داده‌های ورودی دارید، می‌توانید از متدهای only و except استفاده کنید. هر دو متد، یک array یا یک لیست پویا از آرگومان‌ها را می‌پذیرند.$input = $request-&gt;only(['username', 'password']);$input = $request-&gt;only('username', 'password');$input = $request-&gt;except(['credit_card']);$input = $request-&gt;except('credit_card'); متد only جفت كليد و مقداری که درخواست مي‌كنيد را برمی‌گرداند. با این وجود، اگر کلید و مقداری در درخواست موجود نباشد، برگردانده نمی‌شوند.تعیین مقدار ورودی درخواست در صورت وجوداز متد has برای تعیین اینکه آیا یک مقدار در درخواست موجود است یا خیر، استفاده می‌شود. اگر مقدار در یک درخواست موجود باشد، این متد مقدار true را برمی‌گرداند:if ($request-&gt;has('name')) {    //}زمانی که از یک آرایه استفاده می‌شود، متد has برای تعیین اینکه تمام مقادیر مشخص شده در آرایه موجود هستند یا خیر، استفاده می‌شود:if ($request-&gt;has(['name', 'email'])) {    //}می‌توانید از متد filled برای تعیین اینکه یک مقدار در درخواست موجود است و خالی نیست، استفاده کنید:if ($request-&gt;filled('name')) {    //}حفظ ورودی‌های قبلی درخواست در لاراوللاراول این امکان را فراهم می‌کند که ورودی یک درخواست را در طول درخواست بعدی حفظ کنید. این ویژگی برای بارگزاری مجدد فرم‌ها با مقادیر قبلی، پس از تشخیص خطاهای اعتبار سنجی بسیار مفید است. با این حال، اگر از ویژگی‌های اعتبار سنجی موجود در لاراول استفاده می‌کنید، لزومی ندارد که از این متدها به صورت دستی استفاده کنید، زیرا برخی از امکانات اعتبار سنجی از پیش ساخته شده در لاراول این متدها را به صورت خودکار فراخوانی می‌کنند.اضافه کردن ورودی درخواست به session در لاراولمتد flash در نمونه کلاس Illuminate\\Http\\Request ورودی فعلی را به صورت فوری در session قرار می‌دهد، به طوری که این ورودی در طول درخواست بعدی کاربر به برنامه نیز در دسترس باشد:$request-&gt;flash();همچنین، برای قرار دادن زیرمجموعه‌ای از داده‌های درخواست در session می‌توانید از متدهای flashOnly و flashExcept استفاده کنید. این متدها برای حفظ اطلاعات حساسی مانند کلمات عبور در session مفید هستند.$request-&gt;flashOnly(['username', 'email']);$request-&gt;flashExcept('password');قرار دادن ورودی درخواست در session و تغییر مسیر (redirect) از آنجا که اغلب ورودی در session قرار داده می‌شود و سپس تغییر مسیر (redirect) به صفحه قبل انجام می‌گیرد، می‌توانید با استفاده از متد withInput قرار دادن ورودی در sessionرا به تغییر مسیر یا redirect متصل کنید:return redirect('form')-&gt;withInput();return redirect('form')-&gt;withInput(    $request-&gt;except('password'));بازیابی ورودی قبلی قرار داده شده در sessionبرای بازیابی داده‌های قرار داده شده در session از درخواست قبلی، از متد old بر روی نمونه کلاس Request استفاده می‌شود. متد old داده‌های ورودی که قبلا در session قرار گرفته‌اند را از session بازیابی می‌کند:$username = $request-&gt;old('username');همچنین، لاراول یک تابع کمکی old عمومی ارائه می‌دهد. اگر ورودی‌های قبلی را در یک قالب Blade نمایش می‌دهید، به راحتی می‌توانید از تابع کمکی old استفاده کنید. اگر هیچ ورودی قبلی برای فیلد داده موجود نباشد، مقدار null بازگشت داده خواهد شد:&lt;input type=\"text\" name=\"username\" value=\"{{ old('username') }}\"&gt;کوکی‌ها و درخواست‌ها در لاراولبازیابی کوکی‌ها از درخواست‌ها تمام کوکی‌هایی که توسط فریم ورک لاراول ایجاد می‌شوند، رمزگذاری شده و توسط یک کد تأیید اعتبار امضا می‌شوند، بنابراین، اگر کوکی‌ها توسط کلاینت تغییر کنند، نامعتبر تلقی خواهند شد. برای بازیابی مقدار کوکی از یک درخواست، می‌توان از متد cookie بر روی نمونه کلاس Illuminate\\Http\\Request استفاده کرد.$value = $request-&gt;cookie('name');همچنین، می‌توانید از facade Cookie  نیز برای دسترسی به مقادیر کوکی استفاده کنید:$value = Cookie::get('name');پیوست کوکی‌ها به پاسخ‌های HTTP در لاراولمی‌توانید یک کوکی را به یک پاسخ و نمونه خروجی کلاس Illuminate\\Http\\Response با استفاده از متد cookie پیوست کنید. در این صورت، باید اسم، مقدار و تعداد دقیقه‌هایی را که کوکی باید معتبر باشد، را به این متد انتقال دهید:return response('Hello World')-&gt;cookie(    'name', 'value', $minutes);متد cookie چند آرگومان دیگر را نیز می‌پذیرد که به نسبت کمتری استفاده می‌شوند.return response('Hello World')-&gt;cookie(    'name', 'value', $minutes, $path, $domain, $secure, $httpOnly);همچنین، می‌توانید از facade Cookie  برای صف بندی کوکی جهت پیوست به پاسخی که از برنامه خارج می‌شود، استفاده کنید. متد queue یک نمونه کلاس Cookie یا آرگومان‌های موردنیاز برای ایجاد یک نمونه کوکی را می‌پذیرد. این کوکی‌ها قبل از ارسال پاسخ خروجی به مرورگر به آن وصل می‌شوند:Cookie::queue(Cookie::make('name', 'value', $minutes));Cookie::queue('name', 'value', $minutes);ایجاد نمونه کوکی برای پاسخ‌ها در لاراولاگر می‌خواهید یک نمونه کلاس مانند Symfony\\Component\\HttpFoundation\\Cookie ایجاد کنید که بتواند به یک مورد پاسخ در یک زمان دیگر وصل شود، می‌توانید از تابع کمکی cookie عمومی استفاده کنید. این کوکی دوباره به کلاینت ارسال نمی‌شود مگر آنکه به یک نمونه پاسخ وصل شود:$cookie = cookie('name', 'value', $minutes);return response('Hello World')-&gt;cookie($cookie);فایل‌ها و درخواست‌ها در لاراولبازیابی فایل‌های آپلود شدهمی‌توانید به فایل‌های آپلود شده از نمونه کلاس Illuminate\\Http\\Request ، با استفاده از متد file یا با استفاده از خواص پویا دسترسی داشته باشید. متد file یک نمونه از کلاس Illuminate\\Http\\UploadedFile را برمی‌گرداند که از کلاس SplFileInfo مربوط به PHP ارث بری می‌کند و متدهای متعددی برای تعامل با فایل‌ها در اختیار ما قرار می‌دهد:$file = $request-&gt;file('photo');$file = $request-&gt;photo;می‌توان با استفاده از متد hasFile وجود یک فایل در یک درخواست را مشخص کرد:if ($request-&gt;hasFile('photo')) {    //}تایید بارگزاری‌های موفق فایل‌هااز طریق متد isValid علاوه بر چک کردن وجود فایل، می‌توان مشخص کرد که هیچ‌گونه مشکلی در آپلود فایل وجود ندارد:if ($request-&gt;file('photo')-&gt;isValid()) {    //}مسیرهای فایل‌ها و پسوندهاکلاس UploadedFile شامل متدهایی برای دسترسی به مسیر کامل و مناسب فایل و پسوند آن است. متد extension تلاش می‌کند، پسوند فایل را بر اساس محتویات داخل آن حدس بزند. این پسوند ممکن است از پسوندی که توسط کلاینت ارائه شده است، متفاوت باشد:$path = $request-&gt;photo-&gt;path();$extension = $request-&gt;photo-&gt;extension();استفاده از سایر متدهای فایلانواع متدهای دیگری نیز در نمونه کلاس UploadedFile وجود دارد. می‌توانید مستندات API را برای کسب اطلاعات بیشتر در مورد این متدها بررسی کنید.ذخیره فایل‌های آپلود شدهبرای ذخیره یک فایل آپلود شده، معمولاً از یکی از فایل‌ سیستم‌های پیکربندی شده استفاده می‌شود. نمونه کلاس UploadedFile دارای یک متد store است که یک فایل آپلود شده را بر روی یکی از دیسک‌هایی که ممکن است مکانی در فایل سیستم محلی شما یا حتی یک مکان ذخیره سازی ابری مانند Amazon S3 باشد، ذخیره می‌کند.متد store مسیری را که فایل باید در دایرکتوری ریشه فایل سیستم پیکربندی شده ذخیره ‌شود، می‌پذیرد. این مسیر نباید شامل یک نام فایل باشد، زیرا یک شناسه یا ID منحصر به فرد به صورت خودکار به عنوان نام فایل ایجاد می‌شود.متد store همچنین یک آرگومان دوم که استفاده از آن اختیاری است را برای نام دیسکی که باید برای ذخیره فایل مورد استفاده قرار گیرد، می‌پذیرد. این متد مسیر فایل را نسبت به ریشه دیسک بازمی‌گرداند:$path = $request-&gt;photo-&gt;store('images');$path = $request-&gt;photo-&gt;store('images', 's3');اگر نمی‌خواهید نام فایل به صورت خودکار تولید شود، می‌توانید از متد storeAs که مسیر، نام فایل و نام دیسک را به عنوان آرگومان می‌پذیرد، استفاده کنید:$path = $request-&gt;photo-&gt;storeAs('images', 'filename.jpg');$path = $request-&gt;photo-&gt;storeAs('images', 'filename.jpg', 's3');پیکربندی پروکسی‌های معتبر (Trusted Proxies)زمانی که برنامه‌های خود را پشت یک توازن بار اجرا می‌کنید که گواهینامه‌های TLS / SSL را متوقف می‌کنند، متوجه خواهید شد که برنامه شما گاهی لینک‌های HTTPS را ایجاد نمی‌کند. به طور معمول، این امر به دلیل این است که برنامه در حال بارگزاری ترافیک از یک متعادل کننده بار در پورت 80 است و ایجاد لینک‌های امن را فراموش می‌کند.برای حل این مشکل، می‌توانید از middleware App\\Http\\Middleware\\TrustProxies که به صورت پیش‌فرض در یک برنامه لاراول قرار دارد، استفاده کنید. این middleware به شما امکان می‌دهد تا بتوانید به سرعت متعادل کننده بار یا پروکسی‌هایی که باید توسط برنامه مورد اعتماد قرار گیرند را سفارشی کنید. پروکسی‌های مورد اعتماد باید به عنوان یک آرایه در خصوصیت $proxies این middleware لیست شوند. علاوه بر پیکربندی پروکسی‌های قابل اعتماد، می‌توانید هدرهایی را که توسط پروکسی ارسال می‌شوند با اطلاعات مربوط به درخواست اصلی را نیز پیکربندی کنید.&lt;?phpnamespace App\\Http\\Middleware;use Illuminate\\Http\\Request;use Fideloper\\Proxy\\TrustProxies as Middleware;class TrustProxies extends Middleware{    /**     * The trusted proxies for this application.     *     * @var array     */    protected $proxies = [        '192.168.1.1',        '192.168.1.2',    ];    /**     * The current proxy header mappings.     *     * @var array     */    protected $headers = [        Request::HEADER_FORWARDED =&gt; 'FORWARDED',        Request::HEADER_X_FORWARDED_FOR =&gt; 'X_FORWARDED_FOR',        Request::HEADER_X_FORWARDED_HOST =&gt; 'X_FORWARDED_HOST',        Request::HEADER_X_FORWARDED_PORT =&gt; 'X_FORWARDED_PORT',        Request::HEADER_X_FORWARDED_PROTO =&gt; 'X_FORWARDED_PROTO',    ];}ایجاد اعتماد به تمام پروکسی‌هااگر از Amazon AWS یا یکی دیگر از ارائه دهندگان تعادل بار ابری استفاده می کنید، ممکن است آدرس‌های IP متعادل کننده‌های واقعی را ندانید. در این صورت، می‌توانید از ** برای اعتماد به تمام پروکسی‌ها استفاده کنید:/** * The trusted proxies for this application. * * @var array */protected $proxies = '**';",
            "url": "/documentation/laravel/The-Basics/requests"
          }
          ,
        
          "documentation-laravel-the-basics-views" :{
            "title": "ایجاد view",
            "content": "در یک برنامه لاراول خدمات HTML، توسط صفحات view ارائه می‌شوند؛ بنابراین، به واسطه آن منطق یا کد برنامه که معمولاً در کنترلر برنامه قرار دارد را از لایه نمایشی جدا می‌شود. صفحات view در دایرکتوری resources/views ذخیره می‌شوند. در مثال زیر نمونه‌ای از یک view ساده را مشاهده می‌کنید:&lt;!-- View stored in resources/views/greeting.blade.php --&gt;&lt;html&gt;    &lt;body&gt;        &lt;h1&gt;Hello, {{ $name }}&lt;/h1&gt;    &lt;/body&gt;&lt;/html&gt;از آنجا که این view در resources/views/greeting.blade.php ذخیره می‌شود، می‌توانیم آن را با استفاده از تابع کمکی view عمومی به صورت زیر بازگردانیم:Route::get('/', function () {    return view('greeting', ['name' =&gt; 'James']);});همانطور که مشاهده می‌کنید، آرگومان اول در تابع کمکی view با نام فایل موجود در دایرکتوری resources/views برابر است. آرگومان دوم آرایه‌ای از داده‌ها است که باید به view انتقال داده شود. در این مثال، متغیر name انتقال داده شده است که می‌توان با استفاده از سینتکس Blade آن را نمایش داد.البته، می‌توان viewها را به صورت تودرتو زیردایرکتوری‌های موجود در دایرکتوری اصلی یا همان resources/views قرار داد. در این صورت، می‌توان از علامت «نقطه» برای مشاهده view‌های تودرتو استفاده کرد. برای مثال، اگر view در مسیر resources/views/admin/profile.blade.php ذخیره شده باشد، برای دسترسی به آن باید مانند مثال زیر عمل کرد:return view('admin.profile', $data);تعیین موجود بودن یک view در برنامهاگر بخواهید تعیین کنید که آیا یک view موجود است یا خیر، می‌توانید از facade مربوط به View استفاده کنید. متد exists در صورت موجود بودن یک view مقدار true  را بازمی‌گرداند.use Illuminate\\Support\\Facades\\View;if (View::exists('emails.customer')) {    //}ایجاد اولین view موجودبرای ایجاد اولین view موجود در آرایه‌ای از viewها، می‌توان از متد first استفاده کرد. این امر زمانی مفید است که برنامه یا پکیج امکان اینکه viewها سفارشی یا بازنویسی شوند را می‌دهد:return view()-&gt;first(['custom.admin', 'admin'], $data);فراخوانی این متد توسط facade View  هم می‌تواند انجام شود:use Illuminate\\Support\\Facades\\View;return View::first(['custom.admin', 'admin'], $data);انتقال اطلاعات به viewهمان طور که در مثال‌های قبلی مشاهده کردید، می توان آرایه‌ای از داده‌ها را به view انتقال داد:return view('greetings', ['name' =&gt; 'Victoria']);هنگام انتقال اطلاعات به این روش، داده‌ها باید به همراه کلید و مقدار در یک آرایه‌ قرار گیرند. در داخل view، می‌توان به هر مقدار با استفاده از کلید مربوط به آن مانند  دسترسی داشت. به جای انتقال آرایه‌ای کامل از داده‌ها به تابع کمکی view ، مانند مثال زیر می‌توان از متد with جهت اضافه کردن تکه داده‌ها به صورت جداگانه به view، استفاده کرد:return view('greeting')-&gt;with('name', 'Victoria');اشتراک گذاری داده‌ در تمام viewهای برنامه گاهی اوقات، لازم است بخشی از داده‌ها را با تمام viewهایی که توسط برنامه ارائه شده‌اند، به اشتراک بگذارید. این کار را می‌توان با استفاده از متد share  در facade view  انجام داد. معمولاً، فراخوانی‌های متد share را بایستی در متد boot موجود در service provider قرار داد. می‌توانید آن‌ها را به AppServiceProvider   اضافه کنید یا یک service provider جداگانه برای آن‌ها بسازید:&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\View;class AppServiceProvider extends ServiceProvider{    /**     * Bootstrap any application services.     *     * @return void     */    public function boot()    {        View::share('key', 'value');    }    /**     * Register the service provider.     *     * @return void     */    public function register()    {        //    }}استفاده از کامپوزرهای viewکامپوزرهای view ، توابع callback یا متدهای کلاسی هستند که در هنگام رندر شدن یا نمایش یک view فراخوانی می‌شوند. اگر بخواهید هر زمان که  view نمایش داده می‌شود، داده‌ها را به آن انتقال دهید، استفاده از  view composer می‌تواند این منطق را در یک مکان واحد برای شما سازماندهی کند.برای درک بهتر این موضوع، اجازه دهید view composer را در service provider ثبت کنیم. از facade مربوط به View برای دسترسی به زیرمجموعه‌های پیاده سازی قرارداد Illuminate\\Contracts\\View\\Factory استفاده می‌کنیم. باید توجه داشت که لاراول دایرکتوری پیش‌فرض برای view composer ندارد. با این وجود، می‌توانید آن‌ها را سازماندهی کنید. برای مثال، می‌توانید یک دایرکتوری app/Http/ViewComposers برای آن‌ها ایجاد کنید:&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\View;use Illuminate\\Support\\ServiceProvider;class ComposerServiceProvider extends ServiceProvider{    /**     * Register bindings in the container.     *     * @return void     */    public function boot()    {        // Using class based composers...        View::composer(            'profile', 'App\\Http\\ViewComposers\\ProfileComposer'        );        // Using Closure based composers...        View::composer('dashboard', function ($view) {            //        });    }    /**     * Register the service provider.     *     * @return void     */    public function register()    {        //    }}توجه داشته باشید که اگر بخواهید یک service provider جدید برای ثبت view composer خود ایجاد کنید، باید حتما این service provider را به آرایه providers در پیکربندی config/app.php اضافه کنید.اکنون که composer ثبت شده است، هر زمان که ویو profile نمایش داده می‌شود، متد ProfileComposer@compose اجرا می‌شود. حال اجازه دهید در مثال زیر، کلاس composer را تعریف کنیم:&lt;?phpnamespace App\\Http\\ViewComposers;use Illuminate\\View\\View;use App\\Repositories\\UserRepository;class ProfileComposer{    /**     * The user repository implementation.     *     * @var UserRepository     */    protected $users;    /**     * Create a new profile composer.     *     * @param  UserRepository  $users     * @return void     */    public function __construct(UserRepository $users)    {        // Dependencies automatically resolved by service container...        $this-&gt;users = $users;    }    /**     * Bind data to the view.     *     * @param  View  $view     * @return void     */    public function compose(View $view)    {        $view-&gt;with('count', $this-&gt;users-&gt;count());    }}درست قبل از آنکه view نمایش داده شود، متد  composer مربوط به composer با نمونه کلاس Illuminate\\View\\View فراخوانی می‌شود. می‌توانید با استفاده از متد with داده‌ها را به ویو bind کنید.تمام view composerها از طریق service container تشخیص داده شده و resolve می‌شوند، بنابراین، می‌توانید هر وابستگی‌ که به آن نیاز دارید را در سازنده composer خود اعلان نوع یا type-hint کنید.پیوست composer به چندین view می‌توان با انتقال آرایه‌ای از viewها به عنوان اولین آرگومان به متد composer  یک view composer را به چندین view به صورت همزمان پیوست کرد:View::composer(    ['profile', 'dashboard'],    'App\\Http\\ViewComposers\\MyViewComposer');همچنین، متد composer کاراکتر * را به عنوان یک پارامتر wildcard می‌پذیرد که امکان می‌دهد که یک composer را به تمام viewها پیوست کنید:View::composer('*', function ($view) {    //});view creator استفاده ازاستفاده از view creatorها بسیار شبیه به view composerها هستند. با این حال، آن‌ها بلافاصله پس از ایجاد view اجرا می‌شوند و اجازه اماده شدن view برای نمایش را نمی‌دهند. برای ثبت یک view creator، می‌توان از متد creator به صورت مثال زیر استفاده کرد:View::creator('profile', 'App\\Http\\ViewCreators\\ProfileCreator');",
            "url": "/documentation/laravel/The-Basics/views"
          }
          ,
        
          "documentation-laravel-the-basics-session" :{
            "title": "استفاده از  Session",
            "content": "از آنجا که برنامه‌های کاربردی تحت وب HTTP به صورت stateless یا بی ثبات هستند و اطلاعات کاربر را حفظ نمی‌کنند، استفاده از سشن (session) این امکان را فراهم می‌کند که بتوان اطلاعات کاربر را در طول چند درخواست ذخیره کرد. لاراول در حالت پیش‌فرض دارای انواع مختلفی از سشن‌ها به صورت backend است که از طریق یک API ساده و یکپارچه می‌توان به آن‌ها دسترسی داشت. لاراول از backendهای پرطرفدار مثل Memcached و Redis پشتیبانی می‌کند.پیکربندی تنظیمات session فایل پیکربندی سشن در config/session.php قرار دارد. حتماً باید گزینه‌های در دسترس موجود در این فایل را بررسی کنید. به صورت پیش‌فرض پیکربندی تنظیمات لاراول از درایور سشن file استفاده می‌کند که برای بسیاری از برنامه‌ها کارایی لازم را ارائه می‌دهد. در برنامه‌های تولید شده (production)، برای دستیابی به کارایی بهتر و سریعتر می‌توانید از درایور memcached یا redis استفاده کنید.گزینه پیکربندی driver سشن مشخص می‌کند که داده‌های سشن برای هر درخواست در کجا ذخیره می‌شوند. لاراول به صورت پیش‌فرض دارای چند درایور بزرگ و مهم است:file - سشن‌ها در آدرس storage/framework/sessions ذخیره می‌شوند..cookie - سشن‌ها در کوکی‌های امن و رمزگذاری شده ذخیره می‌شوند..database - سشن‌ها در پایگاه داده‌ مربوط به برنامه کاربردی ذخیره می‌شوند..memcached / redis - سشن‌ها در یکی از storeهای سریع مبتنی بر کش موجود ذخیره می‌شوند.array - سشن‌ها در آرایه PHP ذخیره می‌شوند و پایدار نخواهند بود.از آرایه driver در زمان انجام تست استفاده می‌شود و مانع از ذخیره داده‌ها به صورت دائمی در سشن می‌شود.پیش نیازهای درایور session در لاراولپایگاه دادههر زمان که از درایور سشن database استفاده می‌کنید، باید یک جدول ایجاد کنید که حاوی آیتم‌های سشن باشد. در مثال زیر یک نمونه تعریف Schema برای این جدول را مشاهده می‌کنید:Schema::create('sessions', function ($table) {    $table-&gt;string('id')-&gt;unique();    $table-&gt;unsignedInteger('user_id')-&gt;nullable();    $table-&gt;string('ip_address', 45)-&gt;nullable();    $table-&gt;text('user_agent')-&gt;nullable();    $table-&gt;text('payload');    $table-&gt;integer('last_activity');});می‌توان از دستور آرتیسان session:table برای ایجاد این migration استفاده کرد:php artisan session:tablephp artisan migrateRedisقبل از استفاده از سشن‌های Redis در لاراول، باید پکیج predis/predis (~1.0) را با استفاده از Composer نصب کنید. می‌توانید کانکشن‌های Redis را در فایل پیکربندی database پیکربندی کنید. در درون فایل پیکربندی session ، از گزینه connection می‌توان برای مشخص کردن کانکشن Redis مورد استفاده توسط سشن، استفاده کرد.بازیابی داده‌ها از session در لاراولدو روش اصلی برای کار با داده‌های سشن در لاراول وجود دارد؛ روش اول استفاده از تابع کمکی session عمومی و روش دوم استفاده از یک نمونه Request است. در ابتدا، دسترسی به سشن از طریق یک نمونه Request را بررسی می‌کنیم که می‌تواند بر روی یک متد کنترلر اعلان نوع یا type-hint شود. توجه کنید که وابستگی‌های متد کنترلر به صورت خودکار از طریق service container لاراول تزریق می‌شوند:&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;use App\\Http\\Controllers\\Controller;class UserController extends Controller{    /**     * Show the profile for the given user.     *     * @param  Request  $request     * @param  int  $id     * @return Response     */    public function show(Request $request, $id)    {        $value = $request-&gt;session()-&gt;get('key');        //    }}در زمان بازیابی یک مقدار از سشن، می‌توان یک مقدار پیش‌فرض را نیز به عنوان آرگومان دوم به متد get انتقال داد. در صورتی که کلید مشخص شده در سشن موجود نباشد، این مقدار پیش‌فرض برگردانده می‌شود. اگر یک Closure را به عنوان مقدار پیش‌فرض به متد get انتقال دهید و کلید درخواست شده موجود نباشد، Closure اجرا شده و نتیجه آن بازگشت داده می‌شود:$value = $request-&gt;session()-&gt;get('key', 'default');$value = $request-&gt;session()-&gt;get('key', function () {    return 'default';});استفاده از تابع کمکی session در لاراولهمچنین، می‌توان از تابع PHP عمومی session برای بازیابی و ذخیره داده‌ها در سشن استفاده کرد. زمانی که تابع کمکی session با یک آرگومان رشته‌ای واحد فراخوانی می‌شود، مقدار کلید آن سشن را باز می‌گرداند. زمانی که تابع کمکی با آرایه‌ای از جفت کلید و مقدار فراخوانی می‌شود، این مقادیر در سشن ذخیره می‌شوند:Route::get('home', function () {    // Retrieve a piece of data from the session...    $value = session('key');    // Specifying a default value...    $value = session('key', 'default');    // Store a piece of data in the session...    session(['key' =&gt; 'value']);});بین کار با سشن از طریق یک HTTP request و از طریق یک تابع کمکی session عمومی، تفاوت اندکی وجود دارد. هر دو روش از طریق متد assertSessionHas که در تمام گزینه‌های تست موجود است، قابل تست کردن هستند.بازیابی تمام داده‌‌های sessionاگر بخواهید تمام داده‌ها را از سشن بازیابی کنید، باید از متد all به صورت زیراستفاده کنید:$data = $request-&gt;session()-&gt;all();تعیین موجود بودن یک آیتم درون sessionبرای تعیین اینکه آیا یک مقدار در سشن وجود دارد یا خیر، می‌توان از متد has استفاده کرد. اگر مقدار موردنظر موجود باشد، این متد مقدار true را برمی‌گرداند، در غیر این صورت مقدار  null برگشت داده می‌شود:if ($request-&gt;session()-&gt;has('users')) {    //}برای تعیین وجود یک مقدار در سشن، حتی اگر مقدار آن null باشد، می‌توانید از متد exists استفاده کنید. اگر مقدار موجود باشد، این متد مقدار true را برمی‌گرداند:if ($request-&gt;session()-&gt;exists('users')) {    //}ذخیره سازی داده‌ها درون sessionبه منظور ذخیره داده‌ها در سشن، معمولاً می‌توان از متد put یا تابع کمکی session به صورت زیر استفاده کرد:// Via a request instance...$request-&gt;session()-&gt;put('key', 'value');// Via the global helper...session(['key' =&gt; 'value']);push کردن مقادیر session آرایه از متد push می‌توان برای push کردن یک مقدار جدید بر روی مقدار سشنی که در یک آرایه وجود دارد، استفاده کرد. برای مثال، اگر کلید user.teams حاوی آرایه‌ای از نام‌های تیم باشد، می‌توان یک مقدار جدید را بر روی آرایه به صورت مثال زیر push کرد:$request-&gt;session()-&gt;push('user.teams', 'developers');بازیابی و حذف یک مورد از sessionبا استفاده از متد pull می‌توان یک مورد را از سشن، توسط یک خط کد مانند مثال زیر بازیابی و حذف کرد:$value = $request-&gt;session()-&gt;pull('key', 'default');Flash کردن داده‌ها برای درخواست بعدی در sessionگاهی اوقات، ممکن است بخواهید آیتم‌های داده را فقط برای درخواست بعدی در سشن ذخیره کنید. این کار را می‌توان با استفاده از متد flash انجام داد. داده‌هایی که توسط این متد در سشن ذخیره می‌شود، در طول درخواست HTTP بعدی در دسترس خواهند بود و پس از آن حذف می‌شوند. استفاده از داده‌های flash شده، عمدتاً برای پیام‌های نشانگر وضعیت که عمر کوتاهی دارند، مفید است:$request-&gt;session()-&gt;flash('status', 'Task was successful!');اگر بخواهید، اطلاعات flash شده را برای چند درخواست بعدی حفظ کنید، می‌توانید از متد reflash استفاده کنید که تمام داده‌های flash شده را برای درخواست‌های اضافی بعدی حفظ می‌کند. برای حفظ داده‌های flash شده خاص، می‌توان از متد keep استفاده کرد:$request-&gt;session()-&gt;reflash();$request-&gt;session()-&gt;keep(['username', 'email']);پاک کردن داده‌ها از sessionمتد forget یک تکه داده را از سشن حذف می‌کند. اگر بخواهید تمام داده‌ها را از سشن حذف کنید، می‌توانید از متد flush استفاده کنید:$request-&gt;session()-&gt;forget('key');$request-&gt;session()-&gt;flush();ایجاد دوباره شناسه session ایجاد دوباره شناسه سشن، اغلب برای جلوگیری از حمله session fixation، توسط کاربران غیر مجاز صورت می‌گیرد. ایجاد دوباره شناسه سشن در لاراول به صورت خودکار در زمان احراز هویت کاربر انجام می‌شود، اگر از LoginController ساخته شده استفاده می‌کنید و نیاز به ایجاد دوباره شناسه سشن به صورت دستی دارید، می‌توانید از متد regenerate استفاده کنید.$request-&gt;session()-&gt;regenerate();اضافه کردن درایور‌های session به صورت سفارشیپیاده سازی درایور session در لاراولدرایور سشن سفارشی باید رابط SessionHandlerInterface را پیاده سازی کند. این رابط شامل چند متد ساده است که ما برای پیاده سازی به آن‌ها نیاز داریم. پیاده سازی MongoDB مانند مثال زیر است:&lt;?phpnamespace App\\Extensions;class MongoSessionHandler implements \\SessionHandlerInterface{    public function open($savePath, $sessionName) {}    public function close() {}    public function read($sessionId) {}    public function write($sessionId, $data) {}    public function destroy($sessionId) {}    public function gc($lifetime) {}}لاراول دایرکتوری پیش‌فرضی برای قرار دادن موارد اضافی ندارد. می‌توانید آن‌ها را هر جا که بخواهید قرار دهید. در این مثال، ما دایرکتوری Extensions را برای قرار دادن MongoSessionHandler ایجاد کردیم.از آنجا که اهداف از این متدها به راحتی قابل درک نیست، اجازه دهید به صورت خلاصه کارهایی که توسط هر متد انجام می‌شود را بررسی کنیم:The open معمولاً در سیستم‌های file based session store استفاده می‌شود. از آنجا که لاراول درایور سشن file را به صورت پیش‌فرض در خود دارد، نیاز به قرار دادن چیزی در این متد نخواهیم داشت و می‌توانید آن را به عنوان یک تکه کد خالی رها کنید. اما PHP از ما می‌خواهد این متد را پیاده سازی کنیم، می‌توان گفت این یک ضعف آشکار در طراحی رابط در زبان PHP است.The close  مانند متد open ، معمولاً می‌تواند نادیده گرفته شود. برای اکثر درایورها، استفاده از آن لازم نیست.The read باید رشته داده‌های سشن مربوط به پارامتر ورودی $sessionId را بر‌گرداند. هنگام بازیابی یا ذخیره داده‌های سشن در درایور نیازی به انجام serialization و یا سایر عملیات رمزگذاری نیست، زیرا لاراول عملیات serialization را برای شما اجرا می‌کند.The write باید رشته $data ورودی مربوط به پارامتر $sessionId را به بعضی از سیستم‌های ذخیره سازی داده دائمی، مانند MongoDB، Dynamo و غیره بنویسد. مجدداً نباید عملیات serialization انجام دهید، لاراول قبلاً این کار را برای شما انجام داده است.The destroy باید داده‌های مربوط به پارامتر $sessionId را از حافظه دائمی حذف کند.The gc باید تمام داده‌های سشنی که قدیمی‌تر از پارامتر $lifetime ورودی هستند را از بین می‌برد که یک برچسب زمانی UNIX است. برای سیستم‌های مستقل مانند Memcached و Redis، این متد می‌تواند خالی باشد.ثبت درایور sessionزمانی که درایور پیاده سازی شد، می‌توانید آن را در فریم ورک ثبت کنید. برای اضافه کردن درایورهای اضافی به backend سشن در لاراول، می‌توانید از متد extend در fasade مربوط به Session استفاده کنید. باید متد extend را از متد boot در یک service provider فراخوانی کنید. می‌توانید این کار را از AppServiceProvider موجود انجام دهید یا یک provider جدید ایجاد کنید:&lt;?phpnamespace App\\Providers;use App\\Extensions\\MongoSessionHandler;use Illuminate\\Support\\Facades\\Session;use Illuminate\\Support\\ServiceProvider;class SessionServiceProvider extends ServiceProvider{    /**     * Perform post-registration booting of services.     *     * @return void     */    public function boot()    {        Session::extend('mongo', function ($app) {            // Return implementation of SessionHandlerInterface...            return new MongoSessionHandler;        });    }    /**     * Register bindings in the container.     *     * @return void     */    public function register()    {        //    }}زمانی که درایور سشن ثبت شد، می‌توانید از درایور mongo در فایل پیکربندی config/session.php خود استفاده کنید.",
            "url": "/documentation/laravel/The-Basics/session"
          }
          ,
        
          "documentation-laravel-the-basics-responses" :{
            "title": "پاسخ Response",
            "content": "پاسخ نوع Strings &amp; Arraysتمام مسیرها و کنترلرهای لاراول باید یک پاسخ HTTP ایجاد کنند که در مرحله آخر، این پاسخ به مرورگر کاربر ارسال می‌‌‌شود. لاراول روش‌های مختلفی را برای برگرداندن یک پاسخ فراهم کرده است. ساده‌ترین نوع یک پاسخ HTTP در لاراول، برگرداندن یک رشته از مسیر یا کنترلر موجود در برنامه است. فریم ورک به صورت خودکار رشته را به یک پاسخ HTTP کامل تبدیل می‌کند:Route::get('/', function () {    return 'Hello World';});علاوه بر برگرداندن رشته‌ها از مسیرها و کنترلرهای برنامه، آرایه‌ها هم می‌توانند به عنوان یک پاسخ به مرورگر کاربر ارسال شوند. فریم ورک به صورت خودکار آرایه‌ را به یک پاسخ JSON تبدیل می‌کند:Route::get('/', function () {    return [1, 2, 3];});Eloquent collections نیز می‌توانند از مسیرها و كنترلرهای برنامه به عنوان یک پاسخ برگردانده شوند که به صورت خودکار توسط فریم ورک به JSON تبدیل می‌شوند.پاسخ نوع  Response Objectsدر اکثر موارد، این تنها رشته‌ها و آرایه‌های ساده نیستند که از اکشن‌های مسیر در برنامه برگردانده می‌شوند، بلکه نمونه‌ کلاس Illuminate\\Http\\Response یا viewها نیز می‌توانند به عنوان یک پاسخ برگردانده شوند.برگرداندن یک نمونه کلاس Response به صورت کامل، این امکان را ایجاد می‌کند که هدرها و کد وضعیت HTTP مربوط به پاسخ را به صورت سفارشی ایجاد کنید. نمونه کلاس Response از کلاس Symfony\\Component\\HttpFoundation\\Response ارث می‌برند که متدهای مختلفی را برای ایجاد یک پاسخ HTTP در اختیار ما قرار می‌دهد:Route::get('home', function () {    return response('Hello World', 200)                  -&gt;header('Content-Type', 'text/plain');});الحاق هدرها به پاسخ‌های HTTP در لاراولتوجه کنید که اکثر متدهای پاسخ، به یکدیگر مرتبط هستند که امکان ایجاد ساختار واضحی از پاسخ‌ها را فراهم می‌کند. برای مثال، می‌توان از متد header برای اضافه کردن مجموعه‌ای از هدرها به یک پاسخ قبل از ارسال آن به مرورگر کاربر استفاده کرد:return response($content)            -&gt;header('Content-Type', $type)            -&gt;header('X-Header-One', 'Header Value')            -&gt;header('X-Header-Two', 'Header Value');همچنین، می‌توان از متد withHeaders برای تعیین آرایه‌ای از هدرها، برای اضافه کردن به پاسخ استفاده کرد:return response($content)            -&gt;withHeaders([                'Content-Type' =&gt; $type,                'X-Header-One' =&gt; 'Header Value',                'X-Header-Two' =&gt; 'Header Value',            ]);الحاق کوکی‌ها به HTTP response در لاراولمتد cookie در نمونه کلاس response، الحاق کوکی‌ها به پاسخ‌ها را به سادگی امکان‌پذیر می‌سازد. برای مثال، می‌توان از متد cookie برای ایجاد یک کوکی استفاده کرد و به سادگی آن را به یک نمونه کلاس response به صورت مثال زیر الحاق کرد:return response($content)                -&gt;header('Content-Type', $type)                -&gt;cookie('name', 'value', $minutes);متد cookie چند آرگومان دیگر را نیز می‌پذیرد که به نسبت کمتری استفاده می‌شوند.-&gt;cookie($name, $value, $minutes, $path, $domain, $secure, $httpOnly)همچنین، از facade مربوط به Cookie می‌توان برای صف بندی کوکی‌ها جهت الحاق به یک پاسخ خروجی از برنامه استفاده کرد. متد queue ، یک نمونه Cookie یا آرگومان‌های موردنیاز جهت ایجاد یک نمونه Cookie را می‌پذیرد. این کوکی‌ها به پاسخ خروجی، قبل از ارسال به مرورگر کاربر متصل می‌شوند:Cookie::queue(Cookie::make('name', 'value', $minutes));Cookie::queue('name', 'value', $minutes);کوکی‌ها و رمزگذاری در لاراول Cookies &amp; Encryptionدر حالت پیش‌فرض، تمام کوکی‌هایی که در لاراول ایجاد می‌شوند، رمزگذاری و امضا می‌شوند، بنابراین توسط کلاینت قابل تغییر یا خواندن نیستند. اگر می‌خواهید عملیات رمزگذاری را برای زیرمجموعه‌ای از کوکی‌هایی که توسط برنامه ایجاد شده‌اند غیرفعال کنید، می‌توانید از خصوصیت $except در middleware مربوط به رمزگذاری کوکی‌ها یا App\\Http\\Middleware\\EncryptCookis که در دایرکتوری app/Http/Middleware قرار دارد، استفاده کنید:/** * The names of the cookies that should not be encrypted. * * @var array */protected $except = [    'cookie_name',];تغییر مسیرها (redirects) در لاراولپاسخ‌های redirect، نمونه‌هایی از کلاس Illuminate\\Http\\RedirectResponse هستند که هدرهای موردنیاز مناسب جهت هدایت کاربر به یک URL دیگر را ارائه می‌دهند. چند متد برای ایجاد نمونه کلاس RedirectResponse وجود دارد. ساده‌ترین متد استفاده از تابع کمکی redirect عمومی به صورت زیر است:Route::get('dashboard', function () {    return redirect('home/dashboard');});گاهی اوقات، ممکن است بخواهید کاربر را به موقعیت قبلی‌ هدایت کنید، مثلاً زمانی که فرم ارسال شده به سرور نامعتبر است. این کار را می‌توان با استفاده از تابع کمکی back عمومی انجام داد. از آنجا که این ویژگی از session استفاده می‌کند، اطمینان حاصل کنید که مسیر فراخوانی تابع کمکی back از گروه middleware web  استفاده می‌کند یا اینکه تمام middlewareهای مربوط به session اعمال شده باشند:Route::post('user/profile', function () {    // Validate the request...    return back()-&gt;withInput();});تغییر مسیر (redirect) به مسیرهای نامگذاری شده در لاراولزمانی که تابع کمکی redirect بدون هیچ پارامتری فراخوانی می‌شود، نمونه ای از Illuminate\\Routing\\Redirector برگردانده می‌شود که این امکان را می‌دهد که بتوانید، هر متدی را در نمونه کلاس Redirector فراخوانی کنید. برای مثال، برای ایجاد RedirectResponse به یک مسیر نام‌گذاری شده در لاراول، می‌توانید از متد route استفاده کنید:return redirect()-&gt;route('login');اگر مسیر موردنظر دارای پارامتر باشد، می‌توانید آن‌ها را به عنوان آرگومان دوم به متد route انتقال دهید:// For a route with the following URI: profile/{id}return redirect()-&gt;route('profile', ['id' =&gt; 1]);پرکردن پارامترها از مدل‌های Eloquent در لاراولبرای هدایت به مسیری با پارامتر ID که داده‌‌های درون آن از طریق یک مدل Eloquent در آن قرار داده می‌شوند، به سادگی می‌توانید خود مدل را انتقال دهید. داده مربوط به فیلد ID به صورت خودکار از مدل استخراج می‌شود:// For a route with the following URI: profile/{id}return redirect()-&gt;route('profile', [$user]);اگر می‌خواهید مقدار را در پارامتر مسیر قرار دهید، باید متد getRouteKey را در مدل Eloquent خود بازنویسی کنید:/** * Get the value of the model's route key. * * @return mixed */public function getRouteKey(){    return $this-&gt;slug;}تغییر مسیر (redirect) به اکشن‌های کنترلر ل Redirecting To Controller Actionsمی‌توانید تغییر مسیر به اکشن‌های کنترلر ایجاد کنید. برای انجام این کار، باید نام کنترلر و اکشن را به متد action انتقال دهید. توجه کنید که لازم نیست، فضای نامی کامل را برای کنترلر مشخص کنید؛ زیرا RouteServiceProvider در لاراول به صورت خودکار فضای نامی پایه کنترلر را مشخص می‌کند:return redirect()-&gt;action('HomeController@index');اگر مسیر کنترلر نیاز به انتقال پارامتر داشته باشد، می‌توانید آن‌ها را به عنوان آرگومان دوم به متد action انتقال دهید:return redirect()-&gt;action(    'UserController@profile', ['id' =&gt; 1]);تغییر مسیر (redirect) به دامنه‌های خارجی (Redirecting To External Domains)گاهی ممکن است نیاز به تغییر مسیر به یک دامنه خارج از برنامه خود داشته باشید. این کار را می‌توان با فراخوانی متد away انجام داد که یک RedirectResponse را بدون رمزگذاری، اعتبار سنجی یا تأیید اضافی URL ایجاد می‌کند:return redirect()-&gt;away('https://www.google.com');تغییر مسیر (redirect) به داده‌های قرار داده شده در sessionتغییر مسیر به یک URL جدید و انتقال اطلاعات به session معمولاً به صورت همزمان انجام می‌گیرد. معمولاً این کار بعد از انجام موفقیت‌آمیز یک اکشن انجام می‌شود و یک پیغام موفقیت‌آمیز در session قرار داده می‌شود. برای راحتی کار، می‌توانید یک نمونه RedirectResponse ایجاد کنید و با اتصال متدها به یکدیگر، اطلاعات را در session قرار دهید:Route::post('user/profile', function () {    // Update the user's profile...    return redirect('dashboard')-&gt;with('status', 'Profile updated!');});بعد از اینکه کاربر بهURL جدید هدایت شد، می‌توانید پیغام‌های قرار داده شده در session را نمایش دهید. این کار را می‌توان با استفاده از سینتکس Blade مانند مثال زیر انجام داد:@if (session('status'))    &lt;div class=\"alert alert-success\"&gt;        {{ session('status') }}    &lt;/div&gt;@endifانواع پاسخ‌‌های دیگر در لاراولاز تابع کمکی response می‌توان برای ایجاد انواع دیگری از نمونه response استفاده کرد. زمانی که تابع کمکی response را بدون آرگومان فراخوانی می‌کنید، پیاده سازی قرارداد Illuminate\\Contracts\\Routing\\ResponseFactory برگردانده می‌شود. این قرارداد چند متد مفید برای ایجاد پاسخ ارائه می‌دهد.پاسخ‌های View Responsesاگر نیاز به کنترل وضعیت و هدر یک پاسخ دارید و همچنین باید یک view را به عنوان محتوای پاسخ برگردانید، باید از متد view استفاده کنید:return response()            -&gt;view('hello', $data, 200)            -&gt;header('Content-Type', $type);البته، اگر نیازی به انتقال کد وضعیت HTTP یا هدرهای سفارشی ندارید، باید از تابع کمکی view عمومی استفاده کنید.پاسخ‌های JSON Responsesمتد json به صورت خودکار هدر Content-Type را به application/json تنظیم می‌کند و همچنین، با استفاده از تابع json_encode در PHP آرایه داده شده را به JSON تبدیل می‌کند:return response()-&gt;json([    'name' =&gt; 'Abigail',    'state' =&gt; 'CA']);اگر می‌خواهید یک پاسخ JSONP ایجاد کنید، می‌توانید از متد json با ترکیب متد withCallback استفاده کنید:return response()            -&gt;json(['name' =&gt; 'Abigail', 'state' =&gt; 'CA'])            -&gt;withCallback($request-&gt;input('callback'));دانلود فایل File Downloadsمتد download پاسخی ایجاد می‌کند که مرورگر کاربر را وادار به دانلود فایل در مسیر داده شده می‌کند. متد download نام فایل را به عنوان آرگومان دوم در متد می‌پذیرد که نام فایل مشاهده شده توسط کاربری که فایل را دانلود کرده است را مشخص می‌کند. در آخر، می‌توانید آرایه ای از هدرهای HTTP را به عنوان آرگومان سوم به متد انتقال دهید:return response()-&gt;download($pathToFile);return response()-&gt;download($pathToFile, $name, $headers);return response()-&gt;download($pathToFile)-&gt;deleteFileAfterSend(true);Symfony HttpFoundation، که دانلود فایل‌ها را مدیریت می‌کند، نیاز دارد که فایل دانلود شده دارای یک نام فایل به صورت ASCII باشد.پاسخ‌های Streamed Downloadsگاهی اوقات  ممکن است بخواهید پاسخ رشته یک عملیات داده شده را به یک پاسخ قابل بارگیری بدون نیاز به نوشتن محتویات عملیات روی دیسک تبدیل کنید. شما می توانید از روش streamDownload در این سناریو استفاده کنید. این روش یک callback، نام فایل و یک آرایه اختیاری از هدر ها را به عنوان استدلال های آن می پذیرد:return response()-&gt;streamDownload(function () {    echo GitHub::api('repo')                -&gt;contents()                -&gt;readme('laravel', 'laravel')['contents']}, 'laravel-readme.md');پاسخ‌های فایل File Responsesبرای نمایش یک فایل، مانند یک تصویر یا PDF به طور مستقیم در مرورگر کاربر به جای دانلود آن فایل، می‌توانید از متد file استفاده کنید. این متد مسیر فایل را به عنوان آرگومان اول و یک آرایه هدر را به عنوان آرگومان دوم می‌پذیرد:return response()-&gt;file($pathToFile);return response()-&gt;file($pathToFile, $headers);ماکروهای پاسخ یا response در لاراولاگر بخواهید یک پاسخ سفارشی ایجاد کنید که بتوانید استفاده مجدد از آن در بسیاری از مسیرها و کنترلرهای خود داشته باشید، می‌توانید از متد macro در facade مربوط به Response استفاده کنید. مثال زیر، تعریف ماکرو در متد boot از service provider را نشان می‌دهد:&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\ServiceProvider;use Illuminate\\Support\\Facades\\Response;class ResponseMacroServiceProvider extends ServiceProvider{    /**     * Register the application's response macros.     *     * @return void     */    public function boot()    {        Response::macro('caps', function ($value) {            return Response::make(strtoupper($value));        });    }}تابع macro یک اسم به عنوان آرگومان اول و یک Closure به عنوان آرگومان دوم می‌پذیرد. در زمان فراخوانی نام ماکرو از پیاده‌سازی ResponseFactory یا تابع کمکی response این Closure مربوط به ماکرو اجرا می‌شود:return response()-&gt;caps('foo');",
            "url": "/documentation/laravel/The-Basics/responses"
          }
          ,
        
          "documentation-laravel-the-basics-urls" :{
            "title": "تولید URL در لاراول",
            "content": "لاراول چند تابع کمکی (helper) برای تولید URLها در برنامه در اختیار ما قرار داده است. البته، استفاده از این توابع عمدتا در زمان ایجاد لینک‌ها‌ در قالب‌های HTML و پاسخ‌های API، یا در زمان ایجاد پاسخ‌های redirect شده به قسمت‌های دیگر برنامه، مفید خواهد بود.ایجاد URLهای اصلیGenerating Basic URLshelper یا تابع کمکی url برای ایجاد URLهای دلخواه در برنامه استفاده می‌شود. URL ایجاد شده به صورت خودکار از طرح HTTP یا HTTPS استفاده می‌کند و از درخواست فعلی میزبانی می‌کند:$post = App\\Post::find(1);echo url(\"/posts/{$post-&gt;id}\");// http://example.com/posts/1دسترسی به اطلاعات URL فعلیاگر هیچ مسیری برای تابع کمکی url وجود نداشته باشد، یک نمونه کلاس Illuminate\\Routing\\UrlGenerator بازگردانده می‌شود، که امکان می‌دهد به اطلاعات مربوط به URL فعلی دسترسی داشته باشیم:// Get the current URL without the query string...echo url()-&gt;current();// Get the current URL including the query string...echo url()-&gt;full();// Get the full URL for the previous request...echo url()-&gt;previous();همچنین، هر یک از این متدها می‌تواند از طریق fasade URL نیز قابل دسترسی باشد:echo URL::current();URLهای مسیرهای نامگذاری شدهبرای تولید URL به مسیرهای نامگذاری شده، می‌توان از تابع کمکی route استفاده کرد. مسیرهای نامگذاری شده به شما امکان می‌دهد که URLها را بدون اتصال به URL واقعی تعیین شده در مسیر، ایجاد کنید. بنابراین، اگر URL مسیر تغییر کند، هیچ تغییری در فراخوانی‌ تابع route صورت نمی‌گیرد. برای مثال، فرض کنید برنامه دارای یک مسیر تعریف شده مانند مثال زیر است:Route::get('/post/{post}', function () {    //})-&gt;name('post.show');برای تولید یک URL برای این مسیر، می‌توانید از تابع کمکی route مانند مثال زیر استفاده کنید:echo route('post.show', ['post' =&gt; 1]);// http://example.com/post/1اغلب URLها را می‌توان با استفاده از کلید اولیه مدل‌های Eloquent ایجاد کرد. به همین دلیل، می‌توان مدل‌های Eloquent را به عنوان مقادیر پارامتر به تابع کمکی انتقال داد. تابع کمکی route به صورت خودکار کلید اصلی در مدل را استخراج می‌کند:echo route('post.show', ['post' =&gt; $post]);تولید URLها برای اکشن‌های کنترلر از تابع action می‌توان جهت تولید URL برای یک اکشن کنترلر استفاده کرد. در این صورت، لازم نیست فضای نامی کامل کنترلر را انتقال داد. به جای آن، می توان نام کلاس کنترلر را نسبت به فضای نامی App\\Http\\Controllers انتقال داد:$url = action('HomeController@index');اگر متد کنترلر پارامترهای مسیر را می‌پذیرد، می‌توانید آن‌ها را به عنوان آرگومان دوم به این تابع انتقال دهید:$url = action('UserController@profile', ['id' =&gt; 1]);انتقال مقادیر  پیش‌فرض به URL برای برخی از برنامه‌ها، ممکن است بخواهید مقادیر پیش‌فرض درخواستی را برای پارامترهای خاص URL تعیین کنید. برای مثال، فرض کنید بسیاری از مسیرها دارای یک پارامتر  {locale} باشند:Route::get('/{locale}/posts', function () {    //})-&gt;name('post.index');زمانی که تابع کمکی route را فراخوانی می‌کنید، انتقال locale ممکن است کمی کار را دشوار کند. بنابراین، می‌توانید از متد URL::defaults برای تعریف یک مقدار پیش‌فرض برای این پارامتر که همیشه در طول درخواست فعلی اعمال می‌شود، استفاده کنید. می‌توانید این متد را از middleware مسیر فراخوانی کنید تا بتوانید به درخواست فعلی دسترسی داشته باشید:&lt;?phpnamespace App\\Http\\Middleware;use Closure;use Illuminate\\Support\\Facades\\URL;class SetDefaultLocaleForUrls{    public function handle($request, Closure $next)    {        URL::defaults(['locale' =&gt; $request-&gt;user()-&gt;locale]);        return $next($request);    }}زمانی که مقدار پیش‌فرض برای پارامتر locale تنظیم شده باشد، دیگر نیازی به انتقال مقدار آن در زمان ایجاد URLها از طریق تابع کمکی route نیست.",
            "url": "/documentation/laravel/The-Basics/urls"
          }
          ,
        
          "documentation-laravel-the-basics-validation" :{
            "title": "validation یا اعتبارسنجی در لاراول",
            "content": "جهت اعتبارسنجی داده‌های ورودی در برنامه، روش‌های مختلفی توسط لاراول ارائه شده است. در حالت پیش‌فرض، کلاس کنترلر پایه لاراول از یک خصوصیت ValidatesRequests استفاده می‌کند که یک متد مناسب ارائه می‌دهد که با قوانین اعتبارسنجی قدرتمند برای اعتبارسنجی درخواست‌های HTTP ورودی استفاده می‌شود.شروع اعتبارسنجی در لاراولبرای اطلاع از ویژگی‌های قدرتمند اعتبارسنجی در لاراول، توجه شما را به یک نمونه کامل از اعتبارسنجی فرم و پیام‌های خطایی که به کاربر نمایش داده می‌شود، جلب می‌کنیم:تعریف مسیرهاابتدا فرض می‌کنیم، مسیرهای زیر در فایل routes/web.php تعریف شده‌اند:Route::get('post/create', 'PostController@create');Route::post('post', 'PostController@store');مسیر GET یک فرم برای کاربر نمایش می‌دهد که بتواند یک پست جدید ایجاد کند، در حالی که، مسیر POST پست جدید را در پایگاه داده ذخیره می‌کند.ایجاد کنترلرپس، یک کنترلر ساده که این مسیرها را مدیریت می‌کند را در نظر می‌گیریم. فعلاً، متد store را به صورت خالی نگه می‌‌داریم:&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;use App\\Http\\Controllers\\Controller;class PostController extends Controller{    /**     * Show the form to create a new blog post.     *     * @return Response     */    public function create()    {        return view('post.create');    }    /**     * Store a new blog post.     *     * @param  Request  $request     * @return Response     */    public function store(Request $request)    {        // Validate and store the blog post...    }}پیاده سازی منطق اعتبارسنجیاکنون می‌توانیم، متد store را با کدهای اعتبارسنجی جهت تأیید اعتبار پست جدید کاربر پر کنیم. برای انجام این کار، از متد validate که توسط شئ Illuminate\\Http\\Request ارائه شده، استفاده می‌کنیم.اگر قوانین اعتبارسنجی تصویب شوند، کد در حالت نرمال به اجرا ادامه می‌دهد؛ با این حال، اگر اعتبارسنجی با خطا روبرو شود، یک استثنا یا exception پرتاب شده و به صورت خودکار پاسخ خطای مناسب به کاربر ارسال می‌شود. در مورد درخواست‌های HTTP سنتی، یک پاسخ redirect تولید می‌شود و کاربر را به صفحه قبل بازگشت می‌دهد، در حالی که در مورد درخواست‌های AJAX یک پاسخ JSON به کاربر ارسال می‌شود.برای درک بهتر متد validate ، اجازه دهید نگاهی دوباره به متد store بیاندازیم:/** * Store a new blog post. * * @param  Request  $request * @return Response */public function store(Request $request){    $validatedData = $request-&gt;validate([        'title' =&gt; 'required|unique:posts|max:255',        'body' =&gt; 'required',    ]);    // The blog post is valid...}همانطور که مشاهده می‌کنید، می‌توانیم به راحتی قوانین اعتبارسنجی دلخواه را به متد validate انتقال دهیم. در این صورت، اگر عملیات اعتبارسنجی ناموفق باشد، پاسخ مناسب به صورت خودکار تولید می‌شود. اگر اعتبارسنجی با موفقیت انجام بگیرد، کنترلر به صورت نرمال به اجرای خود ادامه خواهد داد.توقف اجرا در اولین شکست اعتبارسنجیگاهی اوقات ممکن است بخواهید، پس از اولین شکست در عملیات اعتبارسنجی یک صفت، اجرای قوانین اعتبارسنجی بعدی را بر روی آن صفت متوقف کنید. برای انجام این کار، باید قانون bail را به آن صفت اختصاص دهید:$request-&gt;validate([    'title' =&gt; 'bail|required|unique:posts|max:255',    'body' =&gt; 'required',]);در این مثال، اگر قانون unique در صفت title با شکست مواجه شود، قانون max بررسی نخواهد شد. قوانین به ترتیبی که مشخص شده‌اند، اعتبارسنجی می‌شوند.صفت‌های تودرتو (nested attributes) در پارامترهای درخواستاگر درخواست HTTP، شامل پارامترهای تودوتو (nested) باشد، در قوانین اعتبارسنجی می‌توان آن‌ها را با استفاده از علامت «نقطه» مشخص کرد:$request-&gt;validate([    'title' =&gt; 'required|unique:posts|max:255',    'author.name' =&gt; 'required',    'author.description' =&gt; 'required',]);نمایش خطاهای اعتبارسنجی اگر پارامترهای درخواست ورودی با قوانین اعتبارسنجی داده شده مطابقت نداشته باشند، چکار باید کرد؟ همانطور که قبلاً ذکر شد، لاراول به صورت خودکار کاربر را به مکان قبلی هدایت خواهد کرد. علاوه بر این، تمام خطاهای اعتبارسنجی به صورت خودکار در سشن نوشته می‌شوند.نباید به صورت صریح پیام‌های خطا را در مسیر GET به view بایند کنیم. به این دلیل که لاراول خطاها را در داده‌های سشن بررسی می‌کند و اگر آن‌ها در دسترس باشند، به صورت خودکار آن‌ها را به view بایند می‌کند. متغیر $errors یک نمونه از کلاس Illuminate\\Support\\MessageBag است. متغیر $errors توسط میدلور Illuminate\\View\\Middleware\\ShareErrorsFromSession به view بایند می‌شود که به وسیله گروه middleware web  ارائه می‌شود. زمانی که این middleware اعمال می‌شود متغیر $errors همواره در view در دسترس خواهد بود و در هر زمانی می‌توان از آن استفاده کرد.بنابراین، در این مثال، زمانی که اعتبارسنجی ناموفق باشد، کاربر به متد create کنترلر برگردانده می‌شود و می‌توانیم پیام‌های خطا را در view به کاربر نمایش دهیم:&lt;!-- /resources/views/post/create.blade.php --&gt;&lt;h1&gt;Create Post&lt;/h1&gt;@if ($errors-&gt;any())    &lt;div class=\"alert alert-danger\"&gt;        &lt;ul&gt;            @foreach ($errors-&gt;all() as $error)                &lt;li&gt;{{ $error }}&lt;/li&gt;            @endforeach        &lt;/ul&gt;    &lt;/div&gt;@endif&lt;!-- Create Post Form --&gt;فیلدهای اختیاری در اعتبارسنجیلاراول به صورت پیش‌فرض شامل میدلورهای TrimStrings و ConvertEmptyStringsToNull در پشته middleware عمومی برنامه است. این middlewarelها توسط کلاس App\\Http\\Kernel در پشته لیست شده‌اند. به همین دلیل، اگر بخواهید مقادیر null توسط عملیات اعتبارسنجی یک مقدار نامعتبر در نظر گرفته نشوند، باید فیلد‌های درخواست اختیاری را به عنوان nullable علامتگذاری کنید. به مثال زیر توجه کنید:$request-&gt;validate([    'title' =&gt; 'required|unique:posts|max:255',    'body' =&gt; 'required',    'publish_at' =&gt; 'nullable|date',]);در این مثال، فیلد publish_at مشخص شده است که می‌تواند شامل یک مقدار null یا یک نمایش تاریخ معتبر باشد. اگر اصلاح کننده nullable به تعریف قانون اعتبارسنجی اضافه نشود، validator مقدار null را یک تاریخ نامعتبر در نظر می‌گیرد.درخواست‌های AJAX در اعتبارسنجیدر این مثال، ما از یک فرم سنتی استفاده کردیم. با این حال، بسیاری از برنامه‌های کاربردی از درخواست‌های AJAX برای ارسال داده‌ها به برنامه استفاده می‌کنند. هنگام استفاده از متد validate در طول یک درخواست AJAX، لاراول یک پاسخ redirect به صفحه قبل ایجاد نمی‌کند. به جای این کار، لاراول یک پاسخ JSON شامل تمام خطاهای اعتبارسنجی ایجاد می‌کند. این پاسخ JSON با یک کد وضعیت 422 HTTP به کاربر ارسال می‌شود.اعتبارسنجی توسط form requestبرای نوشتن سناریوهای پیچیده جهت اعتبارسنجی داده‌ها، می‌توانید یک درخواست فرم یا form request ایجاد کنید. درخواست‌های فرم، کلاس‌های درخواست سفارشی هستند که منطق اعتبارسنجی را در درون خود جای می‌دهند. برای ایجاد یک کلاس form request، می‌توان از دستور آرتیسان make:request به صورت زیر استفاده کرد:php artisan make:request StoreBlogPostکلاس ایجاد شده در دایرکتوری app/Http/Requests قرار می‌گیرد. اگر این دایرکتوری موجود نباشد، در زمان اجرای دستور make:request ایجاد خواهد شد. اجازه دهید، چند قانون اعتبارسنجی را به متد rules اضافه کنیم:/** * Get the validation rules that apply to the request. * * @return array */public function rules(){    return [        'title' =&gt; 'required|unique:posts|max:255',        'body' =&gt; 'required',    ];}چگونه می‌توان قوانین اعتبارسنجی را ارزیابی کرد؟ تمام آن چیزی که باید انجام داد، این است که form request را در متد کنترلر اعلان نوع یا type-hint کنید. درخواست فرم ورودی قبل از فراخوانی متد کنترلر اعتبارسنجی می‌شود. به ایم معنی که دیگر نیازی به وارد کردن منطق اعتبارسنجی خود در درون کلاس کنترلر نخواهید داشت:/** * Store the incoming blog post. * * @param  StoreBlogPost  $request * @return Response */public function store(StoreBlogPost $request){    // The incoming request is valid...}اگر عملیات اعتبارسنجی ناموفق باشد، یک پاسخ redirect ایجاد شده و کاربر را به صفحه قبل برمی‌‌گرداند. خطاها نیز در سشن flash می‌شوند (نوشته می‌شوند) تا برای نمایش دادن به کاربر در دسترس قرا گیرند. اگر درخواست ورودی یک درخواست AJAX باشد، یک پاسخ HTTP با کد وضعیت 422، شامل یک نمایش JSON از خطاهای اعتبارسنجی به کاربر نمایش داده خواهد شد.اضافه کردن after hook به form requestاگر بخواهید یک hook after را به form request اضافه کنید، می‌توانید از متد withValidator استفاده کنید. این متد اعتبارسنجی ایجاد شده را به صورت کامل دریافت می‌کند و این امکان را می‌دهد که قبل از ارزیابی قوانین اعتبارسنجی به صورت واقعی، بتوانید متدهایش را فراخوانی کنید:/** * Configure the validator instance. * * @param  \\Illuminate\\Validation\\Validator  $validator * @return void */public function withValidator($validator){    $validator-&gt;after(function ($validator) {        if ($this-&gt;somethingElseIsInvalid()) {            $validator-&gt;errors()-&gt;add('field', 'Something is wrong with this field!');        }    });}احراز هویت Form Requestکلاس form request نیز شامل یک متد authorize است. می‌توانید در این متد، مجوز کاربر احراز هویت شده به ویرایش یک منبع داده شده را بررسی کنید. برای مثال، می‌توانید تعیین کنید که آیا کاربر کامنتی بر روی یک پست دارد که می‌خواهد آن را ویرایش کند؟/** * Determine if the user is authorized to make this request. * * @return bool */public function authorize(){    $comment = Comment::find($this-&gt;route('comment'));    return $comment &amp;&amp; $this-&gt;user()-&gt;can('update', $comment);}از آنجایی که تمام form requestها، از کلاس request لاراول ارث‌ بری می‌کنند، می‌توان از متد user برای دسترسی به کاربری که در حال حاضر احراز هویت شده است، استفاده کرد. به فراخوانی متد route در مثال بالا توجه کنید، این متد امکان می‌دهد که به پارامترهای URI تعریف شده در فراخوانی مسیر مانند پارامتر {comment} در مثال زیر دسترسی داشته باشید:Route::post('comment/{comment}');اگر متد authorize مقدار false را برگرداند، یک پاسخ HTTP با کد وضعیت 403 به صورت خودکار بازگردانده می‌شود و متد کنترلر اجرا نمی‌شود.اگر قصد دارید منطق احراز هویت را در قسمت دیگری از برنامه خود بگنجانید، می‌‌توانید به راحتی مقدار true را از متد authorize برگردانید:/** * Determine if the user is authorized to make this request. * * @return bool */public function authorize(){    return true;}سفارشی سازی پیام‌های خطای اعتبارسنجی می‌توان پیام‌های خطای مورد استفاده در form request را با بازنویسی متد messages سفارشی کرد. این متد باید آرایه‌ای از صفت و قانون اعتبارسنجی آن و همچنین پیام‌های خطای مربوط به آن‌ها را بازگرداند:/** * Get the error messages for the defined validation rules. * * @return array */public function messages(){    return [        'title.required' =&gt; 'A title is required',        'body.required'  =&gt; 'A message is required',    ];}ایجاد اعتبارسنجی به صورت دستی در لاراولاگر نمی‌خواهید از متد validate در درخواست استفاده کنید، می‌توانید یک نمونه اعتبارسنجی را به صورت دستی با استفاده از facade Validator  ایجاد کنید. متد make در facade یک نمونه validator جدید ایجاد می‌کند:&lt;?phpnamespace App\\Http\\Controllers;use Validator;use Illuminate\\Http\\Request;use App\\Http\\Controllers\\Controller;class PostController extends Controller{    /**     * Store a new blog post.     *     * @param  Request  $request     * @return Response     */    public function store(Request $request)    {        $validator = Validator::make($request-&gt;all(), [            'title' =&gt; 'required|unique:posts|max:255',            'body' =&gt; 'required',        ]);        if ($validator-&gt;fails()) {            return redirect('post/create')                        -&gt;withErrors($validator)                        -&gt;withInput();        }        // Store the blog post...    }}اولین آرگومانی که به متد make انتقال داده می شود، داده‌ای است که باید اعتبارسنجی شود. آرگومان دوم قوانین اعتبارسنجی است که باید بر روی داده‌ها اعمال شوند.پس از بررسی داده، اگر اعتبارسنجی ناموفق باشد؛ می‌توان از متد withErrors برای flash کردن پیام‌های خطا در session استفاده کرد. هنگام استفاده از این متد متغیر $errors به صورت خودکار با viewهای برنامه پس از redirect شدن، به اشتراک گذاشته می‌شود که امکان می‌دهد به سادگی بتوانید، آن‌ها را به کاربر نمایش دهید. متد withErrors یک validator، MessageBag یا یک array می‌پذیرد.تغییر مسیر اتوماتیک (automatic redirection) در اعتبارسنجی لاراولاگر می‌خواهید، به صورت دستی یک نمونه validator ایجاد کنید، اما هنوز هم از تغییرمسیر (redirect) خودکار ارائه شده توسط متد validate درخواست استفاده می‌کنید، می‌توانید متد validate را بر روی نمونه validator موجود فراخوانی کنید. اگر اعتبارسنجی ناموفق باشد، کاربر به صورت خودکار redirect می‌شود (به صفحه قبلی برمی‌گردد) و یا در صورت استفاده از درخواست AJAX یک پاسخ JSON به شما ارائه خواهد داد:Validator::make($request-&gt;all(), [    'title' =&gt; 'required|unique:posts|max:255',    'body' =&gt; 'required',])-&gt;validate();بسته‌های خطای نامگذاری شده (Named Error Bags) اگر چند فرم در یک صفحه داشته باشید، می‌توانید MessageBag خطاها را نامگذاری کنید که امکان اینکه پیام‌های خطا را برای یک فرم خاص بازیابی کنید را فراهم می‌کند. جای نگرانی نیست، می‌توانید نام مشخص شده را به عنوان آرگومان دوم به withErrors انتقال دهید:return redirect('register')            -&gt;withErrors($validator, 'login');پس از آن، می‌توانید به نمونه MessageBag از متغیر $errors دسترسی داشته باشید:{{ $errors-&gt;login-&gt;first('email') }}After Validation Hookهمچنین validator اجازه می‌دهد تا پس از کامل شدن عملیات اعتبارسنجی، attach callbacks را اجرا کنید. این موضوع این امکان را می‌دهد که بتوانید به راحتی اعتبارسنجی بیشتری انجام دهید و حتی پیام‌های خطای بیشتری را به مجموعه پیام‌‌های خطا اضافه کنید. برای شروع کار، می‌توانید از متد after بر روی یک نمونه validator استفاده کنید:$validator = Validator::make(...);$validator-&gt;after(function ($validator) {    if ($this-&gt;somethingElseIsInvalid()) {        $validator-&gt;errors()-&gt;add('field', 'Something is wrong with this field!');    }});if ($validator-&gt;fails()) {    //}کار با پیام‌های خطا در اعتبارسنجی لاراولپس از فراخوانی متد errors بر روی یک نمونه Validator ، یک نمونه کلاس Illuminate\\Support\\MessageBag دریافت خواهید کرد که متدهای مختلفی را برای کار با پیام‌های خطا ارائه می‌دهد. متغیر $errors که به صورت خودکار برای همه viewها در دسترس است نیز نمونه‌ای از کلاس MessageBag است.بازیابی اولین پیام خطا برای یک فیلدبرای بازیابی اولین پیام خطا برای یک فیلد، می‌توانید از متد first استفاده کنید:$errors = $validator-&gt;errors();echo $errors-&gt;first('email');بازیابی تمام پیام‌های خطا برای یک فیلداگر نیاز به بازیابی یک آرایه از تمام پیام‌های خطا برای یک فیلد دارید، می‌توانید از متد get استفاده کنید:foreach ($errors-&gt;get('email') as $message) {    //}اگر یک فیلد فرم آرایه را اعتبارسنجی می‌کنید، می‌توانید تمام پیام‌های خطا را برای هر عنصر آرایه با استفاده از کاراکتر * بازیابی کنید.foreach ($errors-&gt;get('attachments.*') as $message) {    //}بازیابی تمام پیام‌های خطا برای تمام فیلدهابرای بازیابی آرایه‌ای از تمام پیام‌های خطا برای تمام فیلدها، می‌توانید از متد all استفاده کنید:foreach ($errors-&gt;all() as $message) {    //}تعیین وجود پیام خطا برای یک فیلدمتد has برای تعیین اینکه آیا پیام‌ خطا برای یک فیلد مشخص وجود دارد یا خیر، استفاده می‌شود:if ($errors-&gt;has('email')) {    //}پیام‌های خطای سفارشی در اعتبارسنجی لاراولدر صورت نیاز، می‌توانید به جای استفاده از حالت پیش‌فرض، پیام‌های خطای اعتبارسنجی را به صورت سفارشی ایجاد کنید. چندین راه برای ایجاد پیام‌های خطا به صورت سفارشی وجود دارد. در روش اول، می‌توانید پیام‌های خطای سفارشی را به عنوان آرگومان سوم به Validator::make انتقال دهید:$messages = [    'required' =&gt; 'The :attribute field is required.',];$validator = Validator::make($input, $rules, $messages);در این مثال، بخش :attribute با نام واقعی فیلدی که اعتبارسنجی ‌می‌شود جایگزین می‌شود. همچنین می‌توانید از نام‌‌های دیگر در پیام‌های اعتبارسنجی استفاده کنید.$messages = [    'same'    =&gt; 'The :attribute and :other must match.',    'size'    =&gt; 'The :attribute must be exactly :size.',    'between' =&gt; 'The :attribute value :input is not between :min - :max.',    'in'      =&gt; 'The :attribute must be one of the following types: :values',];تعیین پیام خطای سفارشی برای یک صفت مشخصگاهی اوقات ممکن است بخواهید، فقط برای یک فیلد خاص پیام‌های خطای سفارشی ایجاد کنید. این کار را می‌توانید با استفاده از علامت «نقطه» انجام دهید. ابتدا، اسم صفت را مشخص کنید و به دنبال آن از قانون اعتبارسنجی استفاده کنید:$messages = [    'email.required' =&gt; 'We need to know your e-mail address!',];تعیین پیام‌های خطای سفارشی در فایل‌های languageدر اغلب موارد، به جای انتقال مستقیم پیام‌های خطای سفارشی خود به validator می‌توانید آن‌ها را در یک فایل language قرار دهید. برای انجام این کار، پیام‌های خود را به آرایه custom در فایل resources/lang/xx/validation.php اضافه کنید.'custom' =&gt; [    'email' =&gt; [        'required' =&gt; 'We need to know your e-mail address!',    ],],مشخص کردن صفت سفارشی در فایل‌های languageاگر بخواهید بخش :attribute از پیام اعتبارسنجی با یک نام attribute سفارشی جایگزین شود، می‌توانید نام سفارشی خود را در آرایه attributes از فایل resources/lang/xx/validation.php مشخص کنید:'attributes' =&gt; [    'email' =&gt; 'email address',],Available Validation Rules در این فهرست، لیستی از قوانین اعتبارسنجی موجود در لاراول و توابع آن‌ها را مشاهده می‌کنید:AcceptedActive URLAfter (Date)After Or Equal (Date)AlphaAlpha DashAlpha NumericArrayBefore (Date)Before Or Equal (Date)BetweenBooleanConfirmedDateDate EqualsDate FormatDifferentDigitsDigits BetweenDimensions (Image Files)DistinctE-MailExists (Database)FileFilledImage (File)InIn ArrayIntegerIP AddressJSONMaxMIME TypesMIME Type By File ExtensionMinNullableNot InNumericPresentRegular ExpressionRequiredRequired IfRequired UnlessRequired WithRequired With AllRequired WithoutRequired Without AllSameSizeStringTimezoneUnique (Database)URLacceptedفیلدی که اعتبارسنجی می‌شود، باید دارای مقادیر yes ، on ، 1 ، یا true باشد. این قانون برای اعتبارسنجی پذیرش «شرایط استفاده از خدمات» مفید است.active_urlفیلدی که اعتبارسنجی می‌شود، باید دارای یک رکورد معتبر A یا AAAA براساس تابع پی اچ پی dns_get_record باشد.after:dateفیلدی که اعتبارسنجی می‌شود، باید دارای یک مقدار پس از یک تاریخ معین باشد. تاریخ‌ها به تابع پی اچ پی strtotime  منتقل می‌شوند:'start_date' =&gt; 'required|date|after:tomorrow'به جای انتقال یک رشته شامل تاریخ که توسط تابع strtotime ارزیابی می‌شود، می‌توانید یک فیلد دیگر برای مقایسه با تاریخ معین، مشخص کنید:'finish_date' =&gt; 'required|date|after:start_date'after_or_equal:dateفیلدی که اعتبارسنجی می‌شود، باید یک مقدار برابر یا پس از یک تاریخ معین باشد. برای اطلاعات بیشتر، قانون after را مطالعه کنید.alphaفیلدی که اعتبارسنجی می‌شود، باید به صورت کامل شامل حروف الفبا باشد.alpha_dashفیلدی که اعتبارسنجی می‌شود، می‌تواند دارای کاراکترهای عددی و حروف باشد، همچنین خط تیره و زیر خط را نیز می‌تواند شامل شود.alpha_numفیلدی که اعتبارسنجی می‌شود، باید به صورت کامل دارای کاراکترهای حروف و عدد باشد.arrayفیلدی که اعتبارسنجی می‌شود، باید یک آرایه PHP باشد.before:dateفیلدی که اعتبارسنجی می‌شود، باید یک مقدار قبل از تاریخ معین باشد. تاریخ‌ها به تابع پی اچ پی strtotime منتقل می‌شوند.before_or_equal:dateفیلدی که اعتبارسنجی می‌شود، باید یک مقدار قبل یا برابر یک تاریخ معین باشد. تاریخ‌ها به تابع پی اچ پی strtotime منتقل می‌شوند.between:min,maxاندازه فیلدی که اعتبارسنجی می‌شود، باید بین مقادیر min و max باشد. رشته‌ها، اعداد، آرایه‌ها، و فایل‌ها با همان روش قانون size ارزیابی می‌شوند.booleanفیلدی که اعتبارسنجی می‌شود، باید قابل تبدیل به یک مقدار boolean باشد. ورودی قابل قبول می‌تواند مقادیر true ، false ، 1 ، 0 ، “ 1 ” و “ 0 ” باشد.confirmedفیلدی که اعتبارسنجی می‌شود، باید با فیلد foo_confirmation مطابقت داشته باشد. برای مثال، اگر فیلدی که اعتبارسنجی می‌شود، فیلد password باشد، باید یک فیلد password_confirmation  مربوط به آن در ورودی باشد.dateفیلدی که اعتبارسنجی می‌شود، باید یک تاریخ معتبر براساس تابع پی اچ پی strtotime باشد.date_equals:dateفیلدی که اعتبارسنجی می‌شود، باید یک مقدار برابر با تاریخ معین باشد. تاریخ‌ها به تابع پی اچ پی strtotime منتقل می‌شوند.date_format:formatفرمت فیلد تاریخ مورد اعتبارسنجی، باید با فرمت داده شده مطابقت داشته باشد. هنگام اعتبارسنجی یک فیلد، باید از date یا date_format استفاده کنید، نمی‌توان از هر دو آن‌ها به صورت همزمان استفاده کرد.different:fieldفیلدی که اعتبارسنجی می‌شود، باید دارای مقدار متفاوتی از فیلد معین باشد.digits:valueفیلدی که اعتبارسنجی می‌شود، باید عددی باشد و باید دارای طول دقیق براساس value باشد.digits_between:min,maxطول فیلدی که اعتبارسنجی می‌شود، باید بین min و max باشد.dimensionsفیلدی که اعتبارسنجی می‌شود، باید یک تصویر باشد و محدودیت‌های ابعادی اعمال شده توسط پارامترهای قانون اعتبارسنجی را رعایت کند.'avatar' =&gt; 'dimensions:min_width=100,min_height=200'محدودیت‌های موجود عبارتند از: min_width، max_width، min_height، max_height، width، height، ratio.محدودیت ratio باید به صورت عرض تقسیم بر ارتفاع باشد. این را می‌توان با یک عبارت مانند 3/2 یا یک مقدار اعشاری مانند 1.5 مشخص کرد:'avatar' =&gt; 'dimensions:ratio=3/2'از آنجا که این قانون مستلزم دریافت چند آرگومان است، می‌توانید از متد Rule::dimensions استفاده کنید تا به راحتی بتوانید قانون اعتبارسنجی خود را بسازید:use Illuminate\\Validation\\Rule;Validator::make($data, [    'avatar' =&gt; [        'required',        Rule::dimensions()-&gt;maxWidth(1000)-&gt;maxHeight(500)-&gt;ratio(3 / 2),    ],]);distinctدر هنگام کار با آرایه‌ها، فیلدی که اعتبارسنجی می‌شود، نباید دارای مقادیر تکراری باشد.'foo.*.id' =&gt; 'distinct'emailفرمت فیلدی که اعتبارسنجی می‌شود، باید براساس فرمت یک آدرس ایمیل باشد.exists:table,columnفیلدی که اعتبارسنجی می‌شود، باید در جدول پایگاه داده معین موجود باشد.مثالی ساده از قانون اعتبارسنجی exists'state' =&gt; 'exists:states'مشخص کردن نام سفارشی برای یک ستون'state' =&gt; 'exists:states,abbreviation'می‌توان یک database connection خاص مشخص کرد که می‌توان از آن در کوئری exists استفاده کرد. این کار را می‌توان با اضافه کردن نام connection توسط علامت «نقطه» به نام جدول انجام داد:'email' =&gt; 'exists:connection.staff,email'اگر بخواهید، اجرای کوئری را توسط قانون اعتبارسنجی سفارشی کنید، می‌توانید از کلاس Rule استفاده کنید تا به راحتی قانون مورد نظر را تعریف کنید. در این مثال، به جای آنکه از کاراکتر | برای ایجاد محدودیت در قوانین اعتبارسنجی استفاده کنیم، آن‌ها را به صورت یک آرایه مشخص کردیم:use Illuminate\\Validation\\Rule;Validator::make($data, [    'email' =&gt; [        'required',        Rule::exists('staff')-&gt;where(function ($query) {            $query-&gt;where('account_id', 1);        }),    ],]);fileفیلد فایلی که اعتبارسنجی می‌شود، باید با موفقیت آپلود شود.filledفیلدی که اعتبارسنجی می‌شود، در صورت وجود نباید خالی باشد.imageفیلدی که اعتبارسنجی می‌شود، باید یک تصویر با فرمت‌های (jpeg، png، bmp، gif، svg) باشد.in:foo,bar,...فیلدی که اعتبارسنجی می‌شود، باید در لیست داده‌های موجود قرار گیرد. از آنجا که این قاعده نیاز دارد که یک آرایه را implode کنید، متد Rule::in کمک می‌کند تا به سادگی این قانون را بسازید:use Illuminate\\Validation\\Rule;Validator::make($data, [    'zones' =&gt; [        'required',        Rule::in(['first-zone', 'second-zone']),    ],]);in_array:anotherfieldفیلدی که اعتبارسنجی می‌شود، باید در مقادیر anotherfield نیز وجود داشته باشد.integerفیلدی که اعتبارسنجی می‌شود، باید یک عدد صحیح یا integer باشد.ipفیلدی که اعتبارسنجی می‌شود، باید یک آدرس IP باشد.ipv4فیلدی که اعتبارسنجی می‌شود، باید یک آدرس IPv4 باشد.ipv6فیلدی که اعتبارسنجی می‌شود، باید یک آدرس IPv6 باشد.jsonفیلدی که اعتبارسنجی می‌شود، باید یک رشته معتبر JSON باشد.max:valueفیلدی که اعتبارسنجی می‌شود، باید کمتر یا برابر با بیشترین مقدار باشد. رشته‌ها، اعداد، آرایه‌ها، و فایل‌ها با همان روش قانون size ارزیابی می‌شوند.mimetypes:text/plain,...فایلی که اعتبارسنجی می‌شود، باید با یکی از انواع MIME مشخص شده مطابقت داشته باشد:'video' =&gt; 'mimetypes:video/avi,video/mpeg,video/quicktime'برای تعیین نوع MIME فایل آپلود شده، محتویات فایل خوانده می‌شود و فریم ورک تلاش می‌کند تا نوع MIME را حدس بزند که ممکن است با نوع MIME ارائه شده توسط کلاینت متفاوت باشد.mimes:foo,bar,...فایلی که اعتبارسنجی می‌شود، باید دارای یک نوع MIME مربوط به یکی از پسوند‌های لیست شده باشد.Basic Usage Of MIME Rule'photo' =&gt; 'mimes:jpeg,bmp,png'با اینکه فقط پسوند فایل را برای اعتبارسنجی مشخص کردیم، ولی این قانون در واقع با خواندن محتویات فایل و حدس زدن نوع MIME آن، اعتبارسنجی را انجام می‌دهد.لیست کامل انواع MIME و پسوند مربوط به آن‌ها را می‌توانید در لینک زیر مشاهده کنید: https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.typesmin:valueفیلدی که اعتبارسنجی می‌شود، باید حداقل مقدار را داشته باشد. رشته‌ها، اعداد، آرایه‌ها، و فایل‌ها با همان روش قانون size ارزیابی می‌شوند.nullableفیلدی که اعتبارسنجی می‌شود، می‌تواند مقدار null داشته باشد. این قانون در هنگام اعتبارسنجی اولیه مانند رشته‌ها و اعداد صحیح که می‌توانند مقادیر null را داشته باشند، مفید باشد.not_in:foo,bar,...فیلدی که اعتبارسنجی می‌شود، نباید در لیست داده‌های موجود قرار گیرد. از متد Rule::notIn می‌توان استفاده کرد و به سادگی این قانون را ایجاد کرد:use Illuminate\\Validation\\Rule;Validator::make($data, [    'toppings' =&gt; [        'required',        Rule::notIn(['sprinkles', 'cherries']),    ],]);numericفیلدی که اعتبارسنجی می‌شود، باید عددی باشد.presentفیلدی که اعتبارسنجی می‌شود، باید در داده‌ ورودی موجود باشد، اما می‌تواند خالی نیز باشد.regex:patternفیلدی که اعتبارسنجی می‌شود، باید با عبارات منظم (regular expression) داده شده مطابقت داشته باشد.نکته: در هنگام استفاده از الگوریتم regex ، می‌توانید به جای استفاده از pipe delimiter، قوانین را در آرایه مشخص کنید، به خصوص اگر عبارات منظم شامل یک کاراکتر pipe باشند.requiredفیلدی که اعتبارسنجی می‌شود، باید در داده ورودی موجود باشد و خالی نیز نباشد. در صورتی یک فیلد empty یا خالی محسوب می‌شود که یکی از شرایط زیر را دارا باشد:مقدار null است.مقدار یک رشته خالی است.مقدار یک آرایه خالی یا شئ Countable خالی است.مقدار یک فایل آپلود شده بدون مسیر است.required_if:anotherfield,value,...اگر فیلد anotherfield برابر با هر مقداری باشد، فیلدی که اعتبارسنجی می‌شود، باید موجود باشد و خالی نیز نباشد.required_unless:anotherfield,value,...فیلدی که اعتبارسنجی می‌شود، باید موجود باشد و خالی نیز نباشد، مگر اینکه فیلد anotherfield برابر با هر مقداری باشد.required_with:foo,bar,...تنها اگر هر یک از فیلدهای مشخص شده دیگر موجود باشند، فیلدی که اعتبارسنجی می‌شود، باید موجود باشد و خالی نیز نباشد.required_with_all:foo,bar,...تنها اگر تمام فیلدهای مشخص شده دیگر موجود باشند، فیلدی که اعتبارسنجی می‌شود، باید موجود باشد و خالی نیز نباشد.required_without:foo,bar,...تنها زمانی که هر یک از فیلدهای مشخص شده دیگر موجود نباشند، فیلدی که اعتبارسنجی می‌شود، باید موجود باشد و خالی نیز نباشد.required_without_all:foo,bar,...تنها زمانی که تمام فیلدهای مشخص شده دیگر موجود نباشند، فیلدی که اعتبارسنجی می‌شود، باید موجود باشد و خالی نیز نباشد.same:fieldفیلد داده شده باید با فیلدی که اعتبارسنجی می‌شود، مطابق باشد.size:valueاندازه فیلدی که اعتبارسنجی می‌شود، باید مطابق با مقدار مشخص شده باشد. برای داده‌های رشته‌ای، این مقدار تعداد کاراکترها را تعیین می‌کند. برای داده‌های عددی، این مقدار یک عدد صحیح را تعیین می‌کند. برای آرایه‌ها، این اندازه به count آرایه اشاره می‌‌کند. برای فایل‌ها، این اندازه به اندازه فایل در کیلوبایت اشاره می‌کند.stringفیلدی که اعتبارسنجی می‌شود، باید یک رشته باشد. اگر بخواهید این فیلد بتواند مقدار null را نیز داشته باشد، باید قانون اعتبارسنجی nullable را نیز به این فیلد اختصاص دهید.timezoneفیلدی که اعتبارسنجی می‌شود، باید یک شناسه منطقه زمانی معتبر براساس تابع پی اچ پی ‍ timezone_identifiers_list باشد.unique:table,column,except,idColumnفیلدی که اعتبارسنجی می‌شود، باید در جدول پایگاه داده مشخص، یکتا باشد. اگر گزینه column مشخص نشده باشد، نام فیلد مورد استفاده قرار می‌گیرد.مشخص کردن یک نام ستون سفارشی'email' =&gt; 'unique:users,email_address'مشخص کردن اتصال پایگاه داده (database connection) سفارشیگاهی اوقات ممکن است نیاز باشد که یک connection سفارشی برای کوئری‌های پایگاه داده که توسط Validator ایجاد شده‌اند، تنظیم کنید. همانطور که در مثال بالا مشاهده کردید، تنظیم unique:users به عنوان یک قانون اعتبارسنجی از کانکشن پیش‌فرض پایگاه داده برای ایجاد کوئری از پایگاه داده استفاده می‌کند. به جای این کار می‌توان، کانکشن سفارشی و نام جدول را با استفاده از علامت «نقطه» مشخص کرد:'email' =&gt; 'unique:connection.users,email_address'وادار نمودن قانون Unique برای نادیده گرفتن یک ID مشخص گاهی اوقات ممکن است بخواهید، یک ID مشخص را در طول بررسی قانون اعتبارسنجی unique نادیده بگیرید. برای مثال، یک صفحه «ویرایش مشخصات کاربر» را که شامل نام کاربر، آدرس ایمیل و مکان است را در نظر بگیرید. می‌خواهید مشخص کنید که فیلد آدرس ایمیل یکتا است. با این حال، اگر کاربر تنها فیلد نام را تغییر دهد و فیلد آدرس ایمیل تغییری نکند؛ در این صورت، به دلیل اینکه کاربر از قبل صاحب این آدرس ایمیل بوده است، ممکن است نخواهید یک خطای اعتبارسنجی صادر کنید.برای نادیده گرفتن شناسه کاربر توسط این قانون اعتبارسنجی، می‌توانیم از کلاس Rule استفاده کنیم تا بتوانیم به سادگی این قانون را بسازیم. در این مثال، همچنین به جای مشخص کردن قوانین اعتبارسنجی با کاراکتر | می‌توانیم از یک آرایه برای ایجاد محدودیت در قوانین اعتبارسنجی استفاده ‌کنیم:use Illuminate\\Validation\\Rule;Validator::make($data, [    'email' =&gt; [        'required',        Rule::unique('users')-&gt;ignore($user-&gt;id),    ],]);اگر جدول از یک نام ستون به غیر از id برای کلید اصلی استفاده می‌کند، می‌توانید نام ستون را در هنگام فراخوانی متد ignore مشخص کنید:'email' =&gt; Rule::unique('users')-&gt;ignore($user-&gt;id, 'user_id')اضافه کردن بندهای اضافی با whereمی‌توان با استفاده از متد where ، محدودیت‌های پرس و جوی اضافی را برای سفارشی سازی یک query ایجاد کرد. برای مثال، اجازه دهید یک محدودیت اضافه کنیم که account_id با مقدار 1 را مشخص می‌کند:'email' =&gt; Rule::unique('users')-&gt;where(function ($query) {    return $query-&gt;where('account_id', 1);})urlفیلدی که اعتبارسنجی می‌شود، باید یک URL معتبر باشد.افزودن قوانین اعتبارسنجی به صورت شرطیاعتبارسنجی در صورت وجوددر برخی موارد ممکن است بخواهید، تنها اگر فیلد در آرایه ورودی موجود باشد، بررسی‌های اعتبارسنجی را بر روی آن فیلد اجرا کنید. برای انجام سریع این کار، می‌توانید قانون sometimes را به لیست قوانین خود اضافه کنید:$v = Validator::make($data, [    'email' =&gt; 'sometimes|required|email',]);در مثال بالا، فیلد email تنها در صورتی که در آرایه $data موجود باشد، اعتبارسنجی می‌شود.اگر بخواهید فیلدی را که همیشه باید وجود داشته باشد، همچنین ممکن است خالی نیز باشد را اعتبارسنجی کنید، این یادداشت در مورد فیلدهای اختیاری را بررسی کنید.اعتبارسنجی شرطی پیچیدهگاهی اوقات ممکن است بخواهید، منطق شرطی پیچیده‌تری را به قوانین اعتبارسنجی اضافه کنید. برای مثال، ممکن است به یک فیلد مشخص فقط در صورتی که فیلد دیگری دارای مقدار بیشتر از 100 باشد، نیاز داشته باشید. یا ممکن است تنها زمانی که فیلد دیگری موجود باشد، به دو فیلد با یک مقدار معین نیاز داشته باشید. افزودن این قوانین اعتبارسنجی در لاراول کار سختی نیست. ابتدا یک نمونه Validator با قوانین استاتیک که هرگز تغییر نمی‌کند، ایجاد کنید:$v = Validator::make($data, [    'email' =&gt; 'required|email',    'games' =&gt; 'required|numeric',]);برای مثال فرض می‌کنیم، برنامه ما برای جمع آوری مجموعه بازی ساخته شده است. اگر یک جمع آوری کننده بازی در برنامه ثبت نام کرده و بیش از 100 بازی داشته باشد، از او می‌خواهیم توضیح دهد که چرا تعداد بازی‌های زیادی دارد. برای مثال، شاید فروشگاه مجازی بازی اجرا می‌کند یا شاید فقط از جمع آوری بازی لذت می‌برد. برای اضافه کردن این موارد به صورت شرطی، می‌توان از متد sometimes در نمونه Validator استفاده کرد.$v-&gt;sometimes('reason', 'required|max:500', function ($input) {    return $input-&gt;games &gt;= 100;});آرگومان اولی که به متد sometimes منتقل می‌شود، نام فیلدی است که می‌خواهیم به صورت شرطی اعتبارسنجی کنیم. آرگومان دوم قوانین اعتبارسنجی است که قصد اضافه کردن آن‌ها را داریم. در صورتی که Closure به عنوان آرگومان سوم منتقل شده، مقدار true را برگرداند، این قوانین اضافه خواهند شد. این متد این امکان را می‌دهد که به سادگی بتوانیم اعتبارسنجی شرطی پیچیده را اعمال کنیم. حتی می‌توانید اعتبار‌سنجی شرطی را برای چند فیلد به صورت همزمان اضافه کنید:$v-&gt;sometimes(['reason', 'cost'], 'required', function ($input) {    return $input-&gt;games &gt;= 100;});پارامتر $input ارسال شده به Closure نمونه‌ای از Illuminate\\Support\\Fluent است و می‌توان از آن برای دسترسی به ورودی و فایل‌ها نیز استفاده کرد.اعتبارسنجی آرایه‌هااعتبارسنجی آرایه‌ها براساس فیلدهای ورودی نباید کار سختی باشد. می‌توان از علامت «نقطه» برای اعتبارسنجی صفات درون یک آرایه استفاده کرد. برای مثال، اگر درخواست HTTP ورودی دارای فیلد photos[profile] باشد، می‌توان آن را به صورت زیر اعتبارسنجی کرد:$validator = Validator::make($request-&gt;all(), [    'photos.profile' =&gt; 'required|image',]);همچنین می‌توان هر عنصری در درون آرایه را اعتبارسنجی کرد. برای مثال، برای اعتبارسنجی اینکه هر ایمیل در یک فیلد ورودی آرایه، منحصر به فرد است، می‌توان به صورت زیر عمل کرد:$validator = Validator::make($request-&gt;all(), [    'person.*.email' =&gt; 'email|unique:users',    'person.*.first_name' =&gt; 'required_with:person.*.last_name',]);به همین ترتیب، هنگام مشخص کردن پیام‌های اعتبار‌سنجی خود در فایل‌های language، می‌توانید از کاراکتر * استفاده کنید، که در این صورت به راحتی می‌توان از یک پیام اعتبارسنجی واحد را برای فیلدهای آرایه استفاده کرد.'custom' =&gt; [    'person.*.email' =&gt; [        'unique' =&gt; 'Each person must have a unique e-mail address',    ]],ایجاد قوانین اعتبارسنجی سفارشیاستفاده از Rule Objectsلاراول انواع مختلفی از قوانین اعتبارسنجی را ارائه می‌دهد؛ با این حال ممکن است بخواهید برخی از قوانین را به صورت سفارشی ایجاد کنید. یک متد ثبت قوانین اعتبارسنجی سفارشی از اشیاء rule استفاده می‌کند. برای ایجاد یک شئ جدید rule، می‌توانید از دستور آرتیسان make:rule استفاده کنید. بیایید از این دستور برای تولید یک قانون یا rule استفاده کنیم، این قانون باید مشخص کند که یک رشته دارای حروف بزرگ است. لاراول rule جدید را در دایرکتوری app/Rules قرار می‌دهد:php artisan make:rule Uppercaseهنگامی که قانون جدید ایجاد شد، می‌توانیم رفتار آن را نیز تعریف کنیم. یک شئ rule دارای دو متد است: passes و message . متد passes مقدار صفت و نام را دریافت می‌کند و بسته به اینکه آیا مقدار صفت معتبر است یا خیر، باید مقدار true یا false را بازگرداند. متد message پیام خطای اعتبارسنجی را که باید در هنگام ناموفق بودن اعتبارسنجی صادر شود، بازمی‌گرداند.&lt;?phpnamespace App\\Rules;use Illuminate\\Contracts\\Validation\\Rule;class Uppercase implements Rule{    /**     * Determine if the validation rule passes.     *     * @param  string  $attribute     * @param  mixed  $value     * @return bool     */    public function passes($attribute, $value)    {        return strtoupper($value) === $value;    }    /**     * Get the validation error message.     *     * @return string     */    public function message()    {        return 'The :attribute must be uppercase.';    }}اگر می‌خواهید یک پیام خطا را از فایل‌های translation خود بازگردانید، می‌توانید تابع کمکی trans را از متد message فراخوانی کنید:/** * Get the validation error message. * * @return string */public function message(){    return trans('validation.uppercase');}هنگامی که این قانون تعریف شد، می‌توانید با انتقال یک نمونه از شئ rule با سایر قوانین اعتبارسنجی خود، آن‌ها را به validator پیوست کنید.use App\\Rules\\Uppercase;$request-&gt;validate([    'name' =&gt; ['required', new Uppercase],]);استفاده از extension برای ثبت قوانین اعتبار‌سنجی سفارشیروش دیگر برای ثبت قوانین اعتبار‌سنجی سفارشی، استفاده از متد extend در facade مربوط به Validator است. می‌توان از این روش در یک service provider استفاده کرد تا یک قانون اعتبارسنجی سفارشی را ثبت کرد:&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\ServiceProvider;use Illuminate\\Support\\Facades\\Validator;class AppServiceProvider extends ServiceProvider{    /**     * Bootstrap any application services.     *     * @return void     */    public function boot()    {        Validator::extend('foo', function ($attribute, $value, $parameters, $validator) {            return $value == 'foo';        });    }    /**     * Register the service provider.     *     * @return void     */    public function register()    {        //    }}validator Closure سفارشی چهار آرگومان دریافت می‌کند:نام $attribute  که اعتبارسنجی می‌شود، $value مربوط به صفت، آرایه‌ای از $parameters ارسال شده به قانون اعتبارسنجی و یک نمونه Validator .همچنین، می‌توان به جای انتقال یک Closure، یک کلاس و متد را به متد extend انتقال داد:Validator::extend('foo', 'FooValidator@validate');تعریف پیام خطا برای قوانین اعتبارسنجی سفارشیهمچنین، باید یک پیام خطا را برای قانون سفارشی خود تعریف کنید. این کار را می‌توان با استفاده از یک آرایه inline پیام سفارشی یا با اضافه کردن یک ورودی در فایل اعتبارسنجی language انجام داد. این پیام باید در سطح اول آرایه قرار گیرد، نباید این پیام‌ها را در آرایه custom که مختص پیام‌های خطای attribute است، قرار داد:\"foo\" =&gt; \"Your input was invalid!\",\"accepted\" =&gt; \"The :attribute must be accepted.\",// The rest of the validation error messages...هنگام ایجاد یک قانون اعتبارسنجی سفارشی، ممکن است نیاز به جایگزینی یک place-holder سفارشی برای پیام‌های خطا داشته باشید. می‌توانید با ایجاد یک Validator سفارشی همانطور که در مثال بالا توضیح داده شد، یک فراخوانی به متد replacer در facade مربوط به Validato r انجام دهید. می‌توان این کار را در متد boot  یک service provider انجام داد:/** * Bootstrap any application services. * * @return void */public function boot(){    Validator::extend(...);    Validator::replacer('foo', function ($message, $attribute, $rule, $parameters) {        return str_replace(...);    });}Implicit Extensionsدر حالت پیش‌فرض، در هنگام اعتبارسنجی یک attribute که موجود نیست یا مقدار آن خالی است، همانطور که در قانون required تعریف شده است، قوانین اعتبارسنجی نرمال، مانند extension سفارشی، اجرا نمی‌شود. برای مثال، قانون unique در برابر یک مقدار null اجرا نمی‌شود:$rules = ['name' =&gt; 'unique'];$input = ['name' =&gt; null];Validator::make($input, $rules)-&gt;passes(); // trueبرای اجرای یک قانون، حتی زمانی که یک attribute خالی باشد، قانون یا rule باید اشاره کند که این attribute موردنیاز است. برای ایجاد این extension implicit می‌توانید از متد Validator::extendImplicit() استفاده کنید:Validator::extendImplicit('foo', function ($attribute, $value, $parameters, $validator) {    return $value == 'foo';});extension implicit تنها مشخص می‌کند که attribute موردنیاز است. اینکه آیا یک attribute ناموجود یا خالی نامعتبر است یا خیر، به خودتان بستگی دارد.",
            "url": "/documentation/laravel/The-Basics/validation"
          }
          ,
        
          "documentation-laravel-the-basics-errors" :{
            "title": "مدیریت Errors &amp; Logging",
            "content": "زمانی که یک پروژه جدید در لاراول ایجاد می‌کنید، مدیریت خطاها و استثناها از قبل برای شما پیکربندی می‌شود. کلاس App\\Exceptions\\Handler مکانی است که تمام استثناهای ایجاد شده توسط برنامه در آن ثبت (log) می‌شوند و پس از آن، دوباره به کاربر نمایش داده می‌شوند. در ادامه مقاله، نحوه مدیریت خطاها و استثناها در لاراول را بیشتر مورد بررسی قرار خواهیم داد.لاراول برای عملیات ثبت وقایع یا logging، از کتابخانه Monolog استفاده می‌کند، که از چند نوع log handler کارآمد پشتیبانی می‌کند. لاراول تعدادی از این handlerها را تنظیم کرده است که این امکان را می‌دهد که بتوانید از بین یک فایل log واحد، فایل‌های log چرخشی یا نوشتن اطلاعات خطا در سیستم log، یکی را انتخاب کنید.پیکربندی جزئیات خطا در لاراولError Detailگزینه debug در فایل پیکربندی config/app.php مشخص می‌کند که چه اطلاعاتی درباره یک خطا به کاربر نمایش داده شود. در حالت پیش‌فرض، این گزینه به این صورت تنظیم شده است که بتواند مقدارش را از متغیر محیطی APP_DEBUG که در فایل .env ذخیره می‌شود، دربافت کند.در هنگام توسعه محلی برنامه، باید متغیر محیطی APP_DEBUG را با مقدار true تنظیم کنید. در محیط تولید برنامه (در زمان استفاده از برنامه در محیط تجاری)، همواره باید این متغیر را با مقدار false تنظیم کنید. در صورتی که در این مرحله، این متغیر با مقدار true تنظیم شده باشد، ممکن است مقادیر مهم پیکربندی برنامه در معرض دید کاربران نهایی قرار گیرد.ذخیره سازی Log در مدیریت خطاهادر حالت پیش‌فرض، لاراول از نوشتن داده‌های log به فایل‌های daily ، single ، syslog و errorlog پشتیبانی می‌کند. جهت تنظیم اینکه لاراول از کدام مکانیزم ذخیره سازی برای log استفاده کند، می‌توانید گزینه log را در فایل پیکربندی config/app.php خود تغییر دهید. برای مثال، اگر مایل به استفاده از فایل‌های log روزانه به جای یک فایل واحد هستید، باید در فایل پیکربندی app ، مقدار log  را به daily تنظیم کنید:'log' =&gt; 'daily'تعیین ماکزیمم نگهداری فایل‌های log روزانهدر هنگام استفاده از حالت ثبت daily ، لاراول در حالت پیش‌فرض، تنها پنج روز از فایل‌های log نگهداری می‌کند. اگر بخواهید، تعداد روزهای نگهداری فایل‌های log را تنظیم کنید، می‌توانید این تعداد را به عنوان یک مقدار پیکربندی log_max_files در فایل پیکربندی app اضافه کنید:'log_max_files' =&gt; 30سطوح log در مدیریت خطاهای لاراولدر هنگام استفاده از کتابخانه Monolog، پیغام‌های log می‌توانند دارای سطوح مختلفی باشند. در حالت پیش‌فرض، لاراول همه لایه‌های log را در حافظه می‌نویسد. با این حال، ممکن است بخواهید در زمان استفاده از برنامه در محیط تولید، حداقل سطوح را برای آن تنظیم کنید؛ با افزودن گزینه log_level در فایل پیکربندی app.php خود، می‌توانید این کار را انجام دهید.زمانی که این گزینه پیکربندی شد، لاراول همه سطوحی را که بالاتر یا برابر آن باشند، ثبت (log) می‌کند. برای مثال، یک log_level پیش‌فرض از error ، پیام‌های error، critical، alert و پیام‌های emergency را ثبت می‌کند:'log_level' =&gt; env('APP_LOG_LEVEL', 'error'),Monolog سطوح log زیر را به رسمیت می‌شناسد که از کمترین سطح تا بیشترین سطح عبارتند از:debug ،info ،notice ،warning ،error ،critical ،alert ،emergencyپیکربندی سفارشی کتابخانه Monologاگر بخواهید کنترل کاملی بر چگونگی پیکربندی کتابخانه Monolog برای برنامه خود داشته باشید، می‌توانید از متد configureMonologUsing برنامه استفاده کنید. درست قبل از اینکه متغیر $app توسط فایل بازگردانده شود، بایستی فراخوانی این متد را در فایل bootstrap/app.php خود قرار دهید:$app-&gt;configureMonologUsing(function ($monolog) {    $monolog-&gt;pushHandler(...);});return $app;سفارشی کردن نام channel در مدیریت خطادر حالت پیش‌فرض، Monolog با نامی مطابق با محیط فعلی مانند محیط توسعه محلی ( local ) یا محیط استفاده از برنامه ( production ) تنظیم شده است. برای تغییر این مقدار، می‌توانید گزینه log_channel را در فایل پیکربندی app.php اضافه کنید:'log_channel' =&gt; env('APP_LOG_CHANNEL', 'my-app-name'),مدیریت استثنا و متد reportThe Report Methodتمام استثناها (exception) توسط کلاس App\\Exceptions\\Handler مدیریت می‌شوند. این کلاس شامل دو متد report و render است. در ادامه، هر یک از این متدها را به طور دقیق مورد بررسی قرار خواهیم داد؛ متد report جهت ثبت استثناها یا ارسال آن‌ها به یک سرویس خارجی مانند Bugsnag یا Sentry استفاده می‌شود. در حالت پیش‌فرض، متد report استثناها را به کلاس پایه‌ای که استثنا در آن ثبت می‌شود، ارسال می‌کند. با این حال، می‌توانید استثناها را به هر روشی که می‌خواهید ثبت کنید.برای مثال، اگر بخواهید انواع استثناها را به روش‌های مختلف گزارش کنید، می‌توانید از عملگر مقایسه‌ای instanceof زبان PHP به صورت زیر استفاده کنید./** * Report or log an exception. * * This is a great spot to send exceptions to Sentry, Bugsnag, etc. * * @param  \\Exception  $exception * @return void */public function report(Exception $exception){    if ($exception instanceof CustomException) {        //    }    return parent::report($exception);}The report Helperگاهی اوقات، ممکن است بخواهید یک استثنا را گزارش کنید، اما مدیریت درخواست فعلی همچنان ادامه داشته باشد. تابع کمکی report  امکانی را فراهم می‌کند که بتوانید بدون اینکه یک صفحه خطا نمایش داده شود، سریعاً یک استثنا را با استفاده از متد report مربوط به exception handler خود گزارش کنید:public function isValid($value){    try {        // Validate the value...    } catch (Exception $e) {        report($e);        return false;    }}نادیده گرفتن استثناها بر‌اساس نوع در مدیریت خطایخصوصیت $dontReport از exception handler آرایه‌ای از انواع استثناها که ثبت نشده‌اند را شامل می‌شود. برای مثال، استثناهایی که از خطاهای 404 نتیجه می‌شوند و چند نوع دیگر از خطاها که در فایل‌های log نوشته نشده‌اند. می‌توان انواع استثناهای دیگر را به این آرایه اضافه کرد:/** * A list of the exception types that should not be reported. * * @var array */protected $dontReport = [    \\Illuminate\\Auth\\AuthenticationException::class,    \\Illuminate\\Auth\\Access\\AuthorizationException::class,    \\Symfony\\Component\\HttpKernel\\Exception\\HttpException::class,    \\Illuminate\\Database\\Eloquent\\ModelNotFoundException::class,    \\Illuminate\\Validation\\ValidationException::class,];متد render در مدیریت خطامتد render مسئول تبدیل یک استثنا به یک پاسخ HTTP است که باید به مرورگر کاربر ارسال شود. در حالت پیش‌فرض، استثنا به کلاس پایه‌ای که پاسخ HTTP را ایجاد می‌کند، منتقل می‌شود. با این وجود، می‌توانید نوع استثنا خود را بررسی کرده و پاسخ سفارشی خود را به مرورگر برگردانید:/** * Render an exception into an HTTP response. * * @param  \\Illuminate\\Http\\Request  $request * @param  \\Exception  $exception * @return \\Illuminate\\Http\\Response */public function render($request, Exception $exception){    if ($exception instanceof CustomException) {        return response()-&gt;view('errors.custom', [], 500);    }    return parent::render($request, $exception);}استثنا قابل گزارش‌گیری و قابل نمایشبه جای بررسی نوع استثنا در متدهای report و render در exception handler، می‌توانید متدهای report و render را مستقیماً در استثنا سفارشی خود تعریف کنید. وقتی این متدها موجود باشند، به صورت خودکار توسط فریم ورک فراخوانی می‌شوند:&lt;?phpnamespace App\\Exceptions;use Exception;class RenderException extends Exception{    /**     * Report the exception.     *     * @return void     */    public function report()    {        //    }    /**     * Render the exception into an HTTP response.     *     * @param  \\Illuminate\\Http\\Request     * @return \\Illuminate\\Http\\Response     */    public function render($request)    {        return response(...);    }}HTTP Exceptionsبرخی از استثناها کد خطاهای HTTP از سرور را توصیف می‌کنند؛ به عنوان مثال، می‌تواند یک پیغام «صفحه موردنظر یافت نشد» با خطای (404) یا پیغام «خطای غیر مجاز بودن» با خطای (401) یا حتی یک خطای 500 تولید شده توسط توسعه دهنده برنامه باشد. برای تولید این پاسخ از هر جایی در برنامه، می‌توانید از تابع کمکی abort استفاده کنید:abort(404);تابع کمکی abort بلافاصله یک استثنا ایجاد می‌کند که پس از آن توسط exception handler به مرورگر رندر می‌شود. در صورت تمایل، می‌توانید متن پاسخ را به صورت زیر مشخص کنید:abort(403, 'Unauthorized action.');سفارشی سازی صفحات خطای HTTPلاراول این امکان را می‌دهد که برای هر یک از کدهای وضعیت HTTP یک صفحه خطای سفارشی ایجاد کرده و نمایش دهید. برای مثال، اگر می‌خواهید یک صفحه خطای سفارشی برای کد وضعیت 404 HTTP ایجاد کنید، بایستی ابتدا یک فایل resources/views/errors/404.blade.php  ایجاد کنید. این فایل با هر خطای 404 ایجاد شده در برنامه نمایش داده می‌شود. نام viewهای موجود در این دایرکتوری باید با نام کد مربوط به HTTP مطابقت داشته باشند. نمونه HttpException ایجاد شده توسط تابع abort به عنوان یک متغیر $exception به view انتقال داده می‌شود.&lt;h2&gt;{{ $exception-&gt;getMessage() }}&lt;/h2&gt;&lt;/code&gt;&lt;/pre&gt;logging در مدیریت خطالاراول یک لایه انتزاعی ساده را از کتابخانه قدرتمند Monolog ارائه می‌دهد. در حالت پیش‌فرض، لاراول یک فایل log در دایرکتوری storage/logs برای برنامه ایجاد می‌کند. می‌توان اطلاعات را در logs توسط facade Logوشت:&lt;?phpnamespace App\\Http\\Controllers;use App\\User;use Illuminate\\Support\\Facades\\Log;use App\\Http\\Controllers\\Controller;class UserController extends Controller{    /**     * Show the profile for the given user.     *     * @param  int  $id     * @return Response     */    public function showProfile($id)    {        Log::info('Showing user profile for user: '.$id);        return view('user.profile', ['user' =&gt; User::findOrFail($id)]);    }}ثبت کننده وقایع (Logger) هشت سطح logging را که در RFC 5424 تعریف شده است، ارائه می‌دهد:debug ،info ،notice ،warning ،error ،critical ،alert ،emergencyLog::emergency($message);Log::alert($message);Log::critical($message);Log::error($message);Log::warning($message);Log::notice($message);Log::info($message);Log::debug($message);اطلاعات contextual در مدیریت خطای لاراولمی‌توان آرایه‌ای از داده‌های contextual را به متدهای log انتقال داد. این داده‌های contextual با پیغام log قالب بندی شده و نمایش داده می‌شوند:Log::info('User failed to login.', ['id' =&gt; $user-&gt;id]);دسترسی به نمونه پایه MonologMonolog دارای تعدادی از handlerهای اضافی است که ممکن است بخواهید از آن‌ها برای عملیات logging استفاده کنید. در صورت لزوم، می‌توانید به صورت زیر به نمونه پایه Monolog که توسط لاراول استفاده می‌شود، دسترسی داشته باشید.$monolog = Log::getMonolog();",
            "url": "/documentation/laravel/The-Basics/errors"
          }
          ,
        
          "documentation-laravel-frontend-blade" :{
            "title": "Blade Templates",
            "content": "Blade یک موتور قالب بندی ساده و کارآمد است که به همراه لاراول ارائه می‌شود. بر خلاف دیگر موتورهای محبوب قالب بندی PHP،  موتور قالب بندی Blade محدودیتی برای شما در استفاده از کدهای ساده PHP در view ایجاد نمی‌کند. در واقع، تمام ویوهای Blade به کد PHP ساده تبدیل شده و تا زمانی که تغییر نکرده‌اند در حافظه کش ذخیره می‌شوند؛ در این حالت می‌توان گفت که Blade هیچ سرباری به برنامه شما اضافه نمی‌کند. فایل‌های ویوی Blade از پسوند فایل .blade.php استفاده می‌کنند و معمولاً در دایرکتوری resources/views ذخیره می‌شوند.ارث بری قالب view در لاراولتعریف یک Layoutدو مزیت اصلی استفاده از Blade، ارث بری قالب و بخش‌ها است. برای شروع کار، یک مثال ساده را در نظر می‌گیریم؛ در ابتدا، یک صفحه master را در نظر می‌گیریم. از آنجایی که اکثر برنامه‌های کاربردی وب از یک layout کلی برای صفحات مختلف استفاده می‌کنند، برای راحتی کار می‌توان این layout را به عنوان یک ویو Blade به صورت زیر تعریف کرد:&lt;!-- Stored in resources/views/layouts/app.blade.php --&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;App Name - @yield('title')&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        @section('sidebar')            This is the master sidebar.        @show        &lt;div class=\"container\"&gt;            @yield('content')        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;همانطور که مشاهده می‌کنید، این فایل شامل عبارت‌های HTML است. با این حال، به دستورات @section و @yield توجه داشته باشید. دستورالعمل @section ، همانطور که از نامش پیداست، قسمتی از محتوا را تعریف می‌کند، در حالی که دستورالعمل @yield جهت نمایش محتوای یک بخش خاص استفاده می‌شود.پس از اینکه یک layout برای برنامه ایجاد کردیم، اجازه دهید یک صفحه فرزند که از layout ارث بری می‌کند، ایجاد کنیم.ارث بری از یک Layout در لاراولدر زمان تعریف یک ویو فرزند، جهت تعیین اینکه ویو فرزند از کدام layout ارث بری کند، می‌توانیم از دستور @extends استفاده کنیم. ویوهایی که از layout Blade ارث بری می‌کنند، می‌توانند با استفاده از دستور @section محتوای خاصی را به قسمت‌های مختلف layout تزریق کنند. توجه داشته باشید، همان طور که در مثال بالا مشاهده کردید، می‌توان با استفاده از دستور @yield محتویات این قسمت‌ها را در layout نمایش داد:&lt;!-- Stored in resources/views/child.blade.php --&gt;@extends('layouts.app')@section('title', 'Page Title')@section('sidebar')    @parent    &lt;p&gt;This is appended to the master sidebar.&lt;/p&gt;@endsection@section('content')    &lt;p&gt;This is my body content.&lt;/p&gt;@endsectionدر این مثال، قسمت sidebar از دستور @parent برای افزودن محتوا (به جای بازنویسی) به قسمت sidebar در layout استفاده می‌کند. زمانی که ویو نمایش داده می‌شود، دستورالعمل @parent با محتوای layout کلی جایگزین می‌شود.برخلاف مثال قبلی، در این مثال sidebar به جای show@ با endsection@ به پایان می‌رسد. دستور endsection@ فقط یک بخش را تعریف می‌کند در حالی که دستور show@ یک بخش را تعریف کرده و بلافاصله اجرا می‌کند.ویوهای blade می‌توانند توسط تابع کمکی view عمومی به صورت زیر از مسیرها بازگردانده شوند:Route::get('blade', function () {    return view('child');});کامپوننت ‌ها و اسلات ‌ها در view لاراولکامپوننت‌ها و اسلات‌ها روش‌ مناسبی برای تعریف بخش‌ها و layoutها ارائه می‌دهند؛ شاید برای برخی افراد درک ذهنی کامپوننت‌ها و اسلات‌ها ساده‌تر باشد. در ابتدا، اجازه دهید یک کامپوننت «alert» را در نظر بگیریم که قصد داریم توسط برنامه از آن استفاده مجدد کنیم:&lt;!-- /resources/views/alert.blade.php --&gt;&lt;div class=\"alert alert-danger\"&gt;    {{ $slot }}&lt;/div&gt;متغیر {{ $slot }} دارای محتوایی است که می‌خواهید به کامپوننت تزریق کنید. می‌توان از دستور @component برای ساختن این کامپوننت استفاده کرد:@component('alert')    &lt;strong&gt;Whoops!&lt;/strong&gt; Something went wrong!@endcomponentگاهی اوقات، تعریف چند اسلات برای یک کامپوننت می‌تواند مفید باشد. اجازه دهید ماژول alert را تغییر دهیم تا امکان تزریق «title» را نیز داشته باشیم. اسلات‌های نامگذاری شده ممکن است با متغیری که با نام آن مطابقت دارد نمایش داده شوند:&lt;!-- /resources/views/alert.blade.php --&gt;&lt;div class=\"alert alert-danger\"&gt;    &lt;div class=\"alert-title\"&gt; {{ $title }}  &lt;/div&gt;    {{ $slot }}  &lt;/div&gt;اکنون می‌توانیم محتوا را به اسلات نامگذاری شده با استفاده از دستور @slot تزریق کنیم. هر محتوایی که در دستور @slot نیست، در درون متغیر $slot به کامپوننت منتقل می‌شود:@component('alert')    @slot('title')        Forbidden    @endslot    You are not allowed to access this resource!@endcomponentانتقال داده های اضافی به کامپوننت‌های view در لاراولگاهی اوقات، ممکن است بخواهید داده‌های اضافی دیگری را به یک کامپوننت انتقال دهید. به همین دلیل، می‌توانید آرایه‌ای از داده‌ها را به عنوان آرگومان دوم به دستور @component منتقل کنید. تمام داده‌های آرایه به عنوان متغیر در قالب کامپوننت در دسترس خواهند بود:@component('alert', ['foo' =&gt; 'bar'])    ...@endcomponentAliasing ComponentsIf your Blade components are stored in a sub-directory, you may wish to alias them for easier access. For example, imagine a Blade component that is stored at resources/views/components/alert.blade.php. You may use the component method to alias the component from components.alert to alert. Typically, this should be done in the boot method of your AppServiceProvider:use Illuminate\\Support\\Facades\\Blade;Blade::component('components.alert', 'alert');Once the component has been aliased, you may render it using its alias:@alert('alert', ['type' =&gt; 'danger'])    You are not allowed to access this resource!@endalertOr, if the component has no additional slots, you may use the component's name as a Blade directive:@alert    You are not allowed to access this resource!@endalertنمایش داده‌ها در view لاراولبرای نمایش داده‌های منتقل شده به ویوهای Blade می‌توان متغیر را در درون {{ }} قرار داد. برای مثال، به مسیر زیر توجه کنید:Route::get('greeting', function () {    return view('welcome', ['name' =&gt; 'Samantha']);});می‌توان محتویات متغیر name را به صورت زیر نمایش داد:Hello, {{ $name }}  .البته، کار شما تنها به نمایش محتویات متغیرهای منتقل شده به ویو محدود نمی‌شود؛ بلکه، می‌توانید نتیجه حاصل از هر تابع PHP را نیز نمایش دهید. می‌توانید هر کد PHP را که بخواهید درون یک عبارت Blade echo قرار دهید:The current UNIX timestamp is  {{ time() }}  .عبارت‌های {{ }} Blade، جهت جلوگیری از حملات XSS به صورت خودکار توسط تابع پی اچ پی htmlspecialchars ارسال می‌شوند.نمایش داده های unescaped در viewبه صورت پیش‌فرض، عبارت‌های {{ }} Blade، جهت جلوگیری از حملات XSS به صورت خودکار توسط تابع پی اچ پی htmlspecialchars ارسال می‌شوند. اگر نخواهید داده‌هایتان را escaped کنید، می‌توانید از سینتکس زیر استفاده کنید:Hello, {!! $name !!}.در هنگام بازخوانی محتوا که توسط کاربران برنامه ارائه شده‌اند، بسیار دقت کنید. جهت جلوگیری از حملات XSS هنگام نمایش داده‌های ارائه شده توسط کاربران از {{ }}  استفاده کنید.نمایش JSONگاهی اوقات، می‌توانید یک آرایه را به ویو خود انتقال دهید تا بتوانید آن را به عنوان یک JSON ارائه دهید و به عنوان یک متغیر جاوا اسکریپت از آن استفاده کنید. برای مثال:&lt;script&gt;    var app = &lt;?php echo json_encode($array); ?&gt;;&lt;/script&gt;با این حال، به جای اینکه به صورت دستی json_encode را فراخوانی کنید، می‌توانید از دستور @json استفاده کنید:&lt;script&gt;    var app = @json($array);&lt;/script&gt;HTML Entity Encodingdddnamespace App\\Providers;use Illuminate\\Support\\Facades\\Blade;use Illuminate\\Support\\ServiceProvider;class AppServiceProvider extends ServiceProvider{    /**     * Bootstrap any application services.     *     * @return void     */    public function boot()    {        Blade::withoutDoubleEncoding();    }}Blade و فریم ورک های جاوا اسکریپت در لاراولاز آنجایی که بسیاری از فریم ورک‌های جاوا اسکریپت نیز از {{ }} برای نمایش یک عبارت در مرورگر استفاده می‌کنند، می‌توانید از نماد @  استفاده کنید تا به موتور رندر Blade اعلان کنید که عبارت داخل آن را تفسیر نکند. برای مثال:&lt;h1&gt;Laravel&lt;/h1&gt;Hello, @ {{ name }}  .در این مثال، نماد @ توسط Blade حذف می‌شود؛ با این حال، عبارت {{ name }} توسط موتور Blade تفسیر نمی‌شود و این کار مستقیماً توسط فریم ورک جاوا اسکریپت انجام می‌شود.The دستور @verbatim در Blade لاراولاگر متغیرهای جاوا اسکریپت را در بخش بزرگی از قالب خود نمایش می‌دهید، می‌توانید عبارت‌های HTML را در دستور @verbatim قرار دهید، بنابراین لازم نیست که پیش از هر عبارت Blade echo علامت @ قرار دهید:@verbatim    &lt;div class=\"container\"&gt;        Hello, {{ name }}  .    &lt;/div&gt;@endverbatimاستفاده از ساختارهای کنترلی در Blade لاراولعلاوه بر ارث بری قالب‌ها و نمایش داده‌ها در ویو، Blade لاراول میانبرهای مناسبی را نیز ارائه می‌دهد که می‌توان از آن‌ها جهت ایجاد ساختارهای کنترلی رایج PHP مانند دستورات شرطی و حلقه‌ها در ویوهای Blade استفاده کرد. این میانبرها یک روش بسیار ساده و کارآمد برای کار با ساختارهای کنترلی PHP ارائه می‌دهند، در حالی که همچنان، شباهت خود را با معادل‌های PHP حفظ می‌کنند.استفاده از عبارات If در Blade لاراولبرای ساخت عبارات if در یک ویوی Blade، می‌توانید از دستوالعمل‌های @if و @elseif و @else و @endif استفاده کنید. این دستورالعمل‌ها بسیار شبیه به معادل‌های PHP خود عمل می‌کنند:@if (count($records) === 1)    I have one record!@elseif (count($records) &gt; 1)    I have multiple records!@else    I don't have any records!@endifبرای راحتی کار، Blade یک دستورالعمل @unless نیز ارائه می‌دهد:@unless (Auth::check())    You are not signed in.@endunlessعلاوه بر دستورالعمل‌های شرطی که اشاره شد، دستورالعمل‌های @isset و @empty نیز ممکن است به عنوان میانبرهای مناسب برای توابع PHP مربوط به آن‌ها در یک ویوی Blade مورد استفاده قرار گیرند:@isset($records)    // $records is defined and is not null...@endisset@empty($records)    // $records is \"empty\"...@endemptyدستورالعمل‌های احراز هویت (authentication) در Blade لاراولجهت تعیین فوری اینکه کاربر جاری یک کاربر تایید شده است یا یک کاربر مهمان، می‌توان از دستورالعمل‌های احراز هویت @auth و @guest به صورت زیر استفاده کرد:@auth    // The user is authenticated...@endauth@guest    // The user is not authenticated...@endguestدر صورت لزوم، می‌توانید مسئول احراز هویت را به عنوان پارامتر مشخص کنید که در زمان استفاده از دستورات @auth و @guest جهت تعیین اینکه کاربر از طریق مسئول احراز هویت وارد سیستم شده است، بررسی می‌شود:@auth('admin')    // The user is authenticated...@endauth@guest('admin')    // The user is not authenticated...@endguestاستفاده از دستورالعمل‌های section در Blade لاراولمی‌توانید محتوای یک section را با استفاده از دستور @hasSection بررسی نمایید:@hasSection('navigation')    &lt;div class=\"pull-right\"&gt;        @yield('navigation')    &lt;/div&gt;    &lt;div class=\"clearfix\"&gt;&lt;/div&gt;@endifاستفاده از عبارت‌های switch در Blade لاراولعبارات switch می‌توانند با استفاده از دستورالعمل‌های @switch و @case و @default و @endswitch ایجاد شوند:@switch($i)    @case(1)        First case...        @break    @case(2)        Second case...        @break    @default        Default case...@endswitchاستفاده از دستورات حلقه‌ در Blade لاراولعلاوه بر دستورات شرطی، Blade دستورالعمل‌های ساده‌ای را نیز برای کار با ساختارهای حلقه‌ای زبان PHP ارائه می‌دهد. در این مورد هم، هر کدام از این دستورات مشابه معادل‌های خود در زبان PHP عمل می‌کنند:@for ($i = 0; $i &lt; 10; $i++)    The current value is  {{ $i }}  @endfor@foreach ($users as $user)    &lt;p&gt;This is user  {{ $user-&gt;id }}  &lt;/p&gt;@endforeach@forelse ($users as $user)    &lt;li&gt; {{ $user-&gt;name }}  &lt;/li&gt;@empty    &lt;p&gt;No users&lt;/p&gt;@endforelse@while (true)    &lt;p&gt;I'm looping forever.&lt;/p&gt;@endwhileدر زمان کار با حلقه‌ها، می‌توانید از متغیر حلقه برای بدست آوردن اطلاعات مهم در مورد حلقه موردنظر استفاده کنید، اطلاعاتی مانند اینکه در اولین یا آخرین گام تکرار حلقه قرار دارید.همچنین، هنگام استفاده از حلقه‌ها می‌توانید حلقه را پایان دهید یا گام تکرار فعلی را حفظ کنید:@foreach ($users as $user)    @if ($user-&gt;type == 1)        @continue    @endif    &lt;li&gt; {{ $user-&gt;name }}  &lt;/li&gt;    @if ($user-&gt;number == 5)        @break    @endif@endforeachهمچنین، می‌توانید شرط اجرای حلقه را با اعلان دستور حلقه در یک خط کد قرار دهید:@foreach ($users as $user)    @continue($user-&gt;type == 1)    &lt;li&gt; {{ $user-&gt;name }}  &lt;/li&gt;    @break($user-&gt;number == 5)@endforeachمتغیر حلقه در Blade لاراولهنگام استفاده از حلقه‌ها، یک متغیر $loop در داخل حلقه در دسترس است که این متغیر اطلاعات مهمی مانند گام تکرار فعلی و اینکه آیا در اولین یا آخرین گام تکرار حلقه قرار دارید را مشخص می‌کند:@foreach ($users as $user)    @if ($loop-&gt;first)        This is the first iteration.    @endif    @if ($loop-&gt;last)        This is the last iteration.    @endif    &lt;p&gt;This is user  {{ $user-&gt;id }}  &lt;/p&gt;@endforeachاگر در یک حلقه تکرار تو در تو باشید، می‌توانید به متغیر $loop حلقه والد از طریق خصوصیت parent دسترسی داشته باشید:@foreach ($users as $user)    @foreach ($user-&gt;posts as $post)        @if ($loop-&gt;parent-&gt;first)            This is first iteration of the parent loop.        @endif    @endforeach@endforeachهمچنین، متغیر $loop خصوصیت‌های مفید دیگری را نیز شامل می‌شود که در جدول زیر لیست شده اند:PropertyDescription$loop-&gt;indexThe index of the current loop iteration (starts at 0).$loop-&gt;iterationThe current loop iteration (starts at 1).$loop-&gt;remainingThe iteration remaining in the loop.$loop-&gt;countThe total number of items in the array being iterated.$loop-&gt;firstWhether this is the first iteration through the loop.$loop-&gt;lastWhether this is the last iteration through the loop.$loop-&gt;depthThe nesting level of the current loop.$loop-&gt;parentWhen in a nested loop, the parent's loop variable.نحوه ثبت کامنت‌ در ‌Blade لاراولBlade این امکان را می‌دهد که بتوانید در ویوهای خود کامنت‌ها را تعریف کنید. با این حال، بر خلاف کامنت‌های HTML، کامنت‌های Blade در ساختار HTML که توسط برنامه برگردانده می‌شود، قرار نمی‌‌گیرند: {{-- This comment will not be present in the rendered HTML --}}  PHP استفاده از کددر برخی موارد، لازم است که از کد PHP در ویوهای ‌Blade خود استفاده کنید. برای این کار، می‌توانید از دستورالعمل @php برای اجرای یک بلوک ساده از کد PHP در قالب ویو خود استفاده کنید:@php    //@endphpدر حالی که Blade امکان استفاده از این ویژگی را فراهم کرده است ولی با این حال استفاده از این ویژگی می‌تواند نشان دهنده این باشد که شما در گنجاندن منطق در قالب ویو خود زیاده روی کرده‌اید.sub-view نحوه استفاده ازدستور @include این امکان را می‌دهد که بتوانید یک ویو Blade را در داخل یک ویو دیگر اضافه کنید. تمام متغیرهایی که در ویو والد موجود هستند در ویو فرزند نیز قابل دسترس خواهند بود:&lt;div&gt;    @include('shared.errors')    &lt;form&gt;        &lt;!-- Form Contents --&gt;    &lt;/form&gt;&lt;/div&gt;با اینکه ویو فرزند تمام داده‌های موجود در ویو والد را به ارث می‌برد؛ با این حال، می‌توانید یک آرایه شامل داده‌های اضافی را به این ویو انتقال دهید:@include('view.name', ['some' =&gt; 'data'])البته، اگر سعی در اضافه کردن یک ویو با دستور @include داشته باشید که موجود نیست، لاراول یک خطا صادر می‌کند. اگر بخواهید یک ویو را با احتمال موجود بودن یا موجود نبودن آن اضافه کنید، بایستی از دستور @includeIf به صورت زیر استفاده کنید:@includeIf('view.name', ['some' =&gt; 'data'])اگر بخواهید یک sub-view را براساس یک عبارت شرطی بولین با دستور @include اضافه کنید، می‌توانید از دستورالعمل @includeWhen به صورت زیر استفاده کنید:@includeWhen($boolean, 'view.name', ['some' =&gt; 'data'])جهت اضافه کردن اولین ویو موجود در آرایه‌ای از ویو‌ها، می‌توانید از دستورالعمل includeFirst به صورت زیر استفاده کنید:@includeFirst(['custom.admin', 'admin'], ['some' =&gt; 'data'])از بکار بردن ثابت‌های __DIR__ و __FILE__ در ویوهای Blade خود اجتناب کنید، زیرا به مکان ویو کامپایل شده و کش شده اشاره می‌کنند.رندر کردن view با مجموعه‌‌ها در Bladeمی‌توانید حلقه‌ها و includeها را با دستورالعمل @each در یک خط کد ترکیب کنید:@each('view.name', $jobs, 'job')اولین آرگومان، view partial جهت رندر کردن هر آیتم موجود در آرایه یا مجموعه است. آرگومان دوم، آرایه یا مجموعه‌ای است که می‌خواهید آن را تکرار کنید. سومین آرگومان، نام متغیری است که به گام تکرار فعلی در ویو نسبت داده می‌شود. برای مثال، اگر درون یک آرایه از jobها از حلقه استفاده می‌کنید، ممکن است به هر job به عنوان یک متغیر job در view partial خود دسترسی داشته باشید. کلید گام تکرار فعلی به عنوان متغیر key  در ویو در دسترس خواهد بود.همچنین، می‌توانید چهارمین آرگومان را نیز به دستور @each انتقال دهید. در صورتی که آرایه داده شده خالی بود، این آرگومان مشخص می‌کند که کدام ویو نمایش داده شود:@each('view.name', $jobs, 'job', 'view.empty')ویوهای نمایش داده شده از طریق دستور each@ متغیرها را از ویو والد به ارث نمی‌برند. اگر ویو فرزند به این متغیرها نیاز داشته باشد، می‌توانید به جای آن از دستور foreach@ و include@ استفاده کنید.پشته Stacks‌Blade این امکان را می‌دهد تا پشته‌های نامگذاری شده را push کنید که در جایی دیگر در داخل یک ویو یا layout رندر شود. این موضوع می‌تواند جهت تعیین کتابخانه جاوا اسکریپت موردنیاز ویوهای فرزند مفید باشد.@push('scripts')    &lt;script src=\"/example.js\"&gt;&lt;/script&gt;@endpushمی‌توانید یک پشته موردنیاز را چندین مرتبه push کنید. برای ارائه کامل محتویات پشته، نام پشته را به دستور @stack انتقال دهید:&lt;head&gt;    &lt;!-- Head Contents --&gt;    @stack('scripts')&lt;/head&gt;تزریق خدمات یا service Injection در Bladeخروجی دستور @inject می‌تواند برای بازیابی یک سرویس از service container لاراول مورد استفاده قرار گیرد. اولین آرگومان ارسالی به @inject ، نام متغیری است که سرویس در آن قرار داده می‌شود؛ در حالی که، دومین آرگومان نام کلاس یا رابط سرویسی است که قصد دارید آن را resolve کنید.@inject('metrics', 'App\\Services\\MetricsService')&lt;div&gt;    Monthly Revenue:  {{ $metrics-&gt;monthlyRevenue() }}  .&lt;/div&gt;گسترش دستورالعمل‌های Blade در لاراولBlade این امکان را می‌دهد که بتوانید دستورالعمل‌های سفارشی خود را با استفاده از متد directive تعریف کنید. زمانی که کامپایلر Blade با دستورالعمل سفارشی مواجه می‌شود، تابع callback ارائه شده را با پارامترهای آن فراخوانی می‌کند.مثال زیر یک دستور @datetime($var) ایجاد می‌کند که یک متغیر $var را فرمت دهی می‌کند که باید یک نمونه از DateTime باشد:namespace App\\Providers;use Illuminate\\Support\\Facades\\Blade;use Illuminate\\Support\\ServiceProvider;class AppServiceProvider extends ServiceProvider{    /**     * Perform post-registration booting of services.     *     * @return void     */    public function boot()    {        Blade::directive('datetime', function ($expression) {            return \"format('m/d/Y H:i'); ?>\";        });    }    /**     * Register bindings in the container.     *     * @return void     */    public function register()    {        //    }}همانطور که مشاهده می‌کنید، ما متد format  را بر روی هر عبارت به ترتیبی که در دستورالعمل قرار دارد، اعمال می‌کنیم. بنابراین، در این مثال کد PHP تولید شده توسط این دستور به این صورت خواهد بود:format('m/d/Y H:i'); ?>پس از بروز رسانی منطق یک دستورالعمل Blade، باید تمام ویوهای Blade کش شده را حذف کنید. می‌توانید با استفاده از دستور آرتیسان view:clear ویوهای Blade کش شده را پاک کنید.عبارات if سفارشی در Bladeبرنامه نویسی یک دستورالعمل سفارشی، پیچیده‌تر از تعیین عبارات شرطی ساده به صورت سفارشی است. به همین دلیل Blade متد Blade::if را ارائه می‌دهد که توسط آن می‌توانید به سرعت دستورات شرطی سفارشی خود را با استفاده از Closure تعریف کنید. برای مثال، اجازه دهید یک دستور شرطی سفارشی را تعریف کنیم که محیط برنامه فعلی را بررسی می‌کند. می‌توانیم این کار را در متد boot از AppServiceProvider خود انجام دهیم:use Illuminate\\Support\\Facades\\Blade;/** * Perform post-registration booting of services. * * @return void */public function boot(){    Blade::if('env', function ($environment) {        return app()-&gt;environment($environment);    });}زمانی که دستور شرطی سفارشی ایجاد شد، می‌توانیم به راحتی از آن در قالب‌های ویو خود استفاده کنیم:@env('local')    // The application is in the local environment...@elseenv('testing')    // The application is in the testing environment...@else    // The application is not in the local or testing environment...@endenv",
            "url": "/documentation/laravel/Frontend/blade"
          }
          ,
        
          "documentation-laravel-frontend-localization" :{
            "title": "اصول localization",
            "content": "امکان localization در فریم ورک Laravel به شما این اجازه را می دهد تا رشته ها را به زبان های مختلف در اپلیکیشن خود ترجمه و بازیابی کنید.متغیرهای رشته ای language داخل فایل هایی در پوشه ی resources/lang ذخیره می شود. در این پوشه بایستی به ازای هر زبان که اپلیکیشن پشتیبانی می کند، یک subdirectory وجود داشته باشد:/resources    /lang        /en            messages.php        /es            messages.phpتمامی فایل های language صرفا یک آرایه از رشته های با کلید (keyed strings) را به عنوان خروجی برمی گردانند. مثال:&lt;?phpreturn [    'welcome' =&gt; 'Welcome to our application'];تنظیم زبان جاری (locale)زبان پیش فرض اپلیکیشن داخل فایل تنظیمات config/app.php ذخیره می شود. البته شما می توانید این مقدار را مطابق نیازهای اپلیکیشن خود ویرایش نمایید. همچنین می توانید با فراخوانی متد setLocale در App facade زبان فعلی برنامه را در زمان اجرا (runtime) تغییر دهید:Route::get('welcome/{locale}', function ($locale) {    App::setLocale($locale);    //});همچنین می توانید یک زبان جایگزین (fallback) تنظیم کنید. این زبان جایگزین زمانی بکار می رود که زبان فعلی دربردارنده ی رشته مورد نظر نباشد. زبان جایگزین نیز مانند زبان فعلی برنامه در فایل تنظیمات config/app.php قابل دسترسی و تنظیم می باشد:'fallback_locale' =&gt; 'en',تعیین محل فعلیمی توانید با استفاده از متدهای getLocale و isLocale مرتبط با فاساد App، مکان فعلی تنظیم شده را بررسی نمایید :$locale = App::getLocale();if (App::isLocale('en')) {    //}Defining Translation StringsUsing Short Keysبه طور معمول، رشته های ترجمه در فایل ها در دایرکتوری resources / lang ذخیره می شوند. در این فهرست باید یک زیرپوشه برای هر زبان پشتیبانی شده توسط برنامه وجود داشته باشد:/resources    /lang        /en            messages.php        /es            messages.phpتمام فایل های زبان یک آرایه از رشته های کلید می گیرند. مثلا:&lt;?php// resources/lang/en/messages.phpreturn [    'welcome' =&gt; 'Welcome to our application'];Using Translation Strings As Keysبرای برنامه های با نیازهای ترجمه سنگین، تعریف هر رشته با \"کلید کوتاه\" می تواند به سرعت در هنگام اشاره به آنها در نظرات شما گیج کننده باشد. به همین دلیل، Laravel همچنین پشتیبانی از تعریف رشته های ترجمه را با استفاده از «پیش فرض» ترجمه رشته به عنوان کلید ارائه می دهد.فایل های ترجمه که از رشته های ترجمه به عنوان کلید استفاده می کنند، به عنوان فایل های JSON در دایرکتوری resource / lang ذخیره می شوند. به عنوان مثال، اگر درخواست شما یک ترجمه اسپانیایی باشد، باید یک فایل resource / lang / es.json ایجاد کنید:{    \"I love programming.\": \"Me encanta programar.\"}Retrieving Translation Stringsمی توانید با بهره گیری از تابع کمکی __ رشته هایی را از فایل های language بازیابی کنید. متد __ فایل و کلید مربوط به رشته ی زبان مورد نظر را به عنوان آرگوامان اول می پذیرد. در زیر با فراخوانی تابع مذکور رشته ی welcome را از فایل مربوط به زبانresources/lang/messages.php خوانده و بازیابی می کنیم.echo __('messages.welcome');echo __('I love programming.');البته در صورتی که از موتور تولید قالب Blade استفاده می کنید، می توانید از سینتکس{{ }} برای چاپ {{ }}مورد نظر به زبان معین استفاده نمایید:{{ __('messages.welcome') }}@lang('messages.welcome')در صورتی که رشته ی مورد نظر در فایل language وجود نداشت، تابع trans کلید آن رشته را برمی گرداند. حال با توجه به مثال قبلی می توان نتیجه گرفت که در صورت عدم وجود رشته ی مورد نظر تابع نام برده messages.welcome را به عنوان خروجی برمی گرداند.جایگزین کردن پارامترها در رشته های زبان placeholder ها (مکان نگهدارها) ابزاری کارامدی هستند که می توانید در رشته های متنی زبان خود نیز از آن ها استفاده کنید. برای درجplaceholder کافی است ابتدا کاراکتر دو نقطه و سپس اسم مکان نگهدار دلخواه را مشخص نمایید. در زیر با استفاده از placeholder ای به نامname یک پیغام خوش آمدگویی نمایش می دهیم:'welcome' =&gt; 'Welcome, :name',به منظور جایگذاری مقدار مورد نظر در مکان نگهدار تعریف شده، در زمان بازیابی خط زبان (رشته ی متنی زبان)، آرایه ای از مقادیر جایگزین را به عنوان آرگومان دوم به تابع __ ارسال نمایید:echo __('messages.welcome', ['name' =&gt; 'dayle']);اگر دارنده مکان شما حاوی تمام حروف بزرگ است، یا فقط اولین حرف خود را با حروف بزرگ می نویسد، ارزش ترجمه شده به ترتیب به ترتیب سرمایه گذاری می شود:'welcome' =&gt; 'Welcome, :NAME', // Welcome, DAYLE'goodbye' =&gt; 'Goodbye, :Name', // Goodbye, DaylePluralizationاز آنجایی که هر زبانی قواعد خاص خود را برای جمع بندی دارد، pluralizationمشکل پیچیده ای را در چند زبانه کردن اپلیکیشن به وجود آورده است. با بهره گیری از کاراکتر \" | \" می توان فرم های جمع و مفرد یک رشته را از هم تمایز بخشید:'apples' =&gt; 'There is one apple|There are many apples',مترجم Laravel توسط کامپوننت ترجمه ی Symphony طراحی و پشتیبانی می شود، بنابراین می توانید قواعد پیچیده تری برای جمع بندی رشته ها تعریف کنید:'apples' =&gt; '{0} There are none|[1,19] There are some|[20,*] There are many',پس از آن می توانید به وسیله ی تابع trans choice رشته مورد نظر را با توجه به آرگومان دوم (تعداد کلمات مشخص شده) ترجمه و بازیابی کنید. در این مثال، از آنجایی که مقدار آرگومان دوم از 1 بزرگتر است، فرم جمع رشته برگردانده می شود:echo trans_choice('messages.apples', 10);You may also define place-holder attributes in pluralization strings. These place-holders may be replaced by passing an array as the third argument to the trans_choice function:'minutes_ago' =&gt; '{1} :value minute ago|[2,*] :value minutes ago',echo trans_choice('time.minutes_ago', 5, ['value' =&gt; 5]);Overriding Package Language Filesبرخی از پکیج ها همراه با فایل های language اختصاصی خود ارائه می شوند. بجای اینکه فایل های اصلی پکیج را هک کرده و اقدام به ویرایش خط ها و رشته های متنی زبان کنید، می توانید با قرار دادن فایل های خود در پوشه ی resources/lang/vendor/{package}/{locale} به طور کامل آن ها را بازنویسی یا به اصطلاح override نمایید.برای مثال اگر بخواهید متن های زبان انگلیسی را در فایل messages.php پکیج ای به نام skyrim/hearthfire بازنویسی کنید، در آن صورت بایستی فایل language دلخواه را در آدرس resources/lang/vendor/hearthfire/en/messages.php جایگذاری نمایید. یادآور می شویم که در این فایل فقط می بایست آن دسته از رشته های متنی (خط های زبان) که می خواهید بازنویسی شوند را تعریف کنید. هر رشته ی متنی یا خط زبانی (language line) که بازنویسی نکنید، از فایل های language اصلی پکیج خوانده و لود می شوند.",
            "url": "/documentation/laravel/Frontend/localization"
          }
          ,
        
          "documentation-laravel-frontend-frontend" :{
            "title": "JavaScript &amp; CSS Scaffolding",
            "content": "CSSLaravel Mix provides a clean, expressive API over compiling SASS or Less, which are extensions of plain CSS that add variables, mixins, and other powerful features that make working with CSS much more enjoyable. In this document, we will briefly discuss CSS compilation in general; however, you should consult the full Laravel Mix documentation for more information on compiling SASS or Less.JavaScriptLaravel does not require you to use a specific JavaScript framework or library to build your applications. In fact, you don't have to use JavaScript at all. However, Laravel does include some basic scaffolding to make it easier to get started writing modern JavaScript using the Vue library. Vue provides an expressive API for building robust JavaScript applications using components. As with CSS, we may use Laravel Mix to easily compile JavaScript components into a single, browser-ready JavaScript file.Removing The Frontend ScaffoldingIf you would like to remove the frontend scaffolding from your application, you may use the preset Artisan command. This command, when combined with the none option, will remove the Bootstrap and Vue scaffolding from your application, leaving only a blank SASS file and a few common JavaScript utility libraries:php artisan preset noneWriting CSSLaravel's package.json file includes the bootstrap package to help you get started prototyping your application's frontend using Bootstrap. However, feel free to add or remove packages from the package.json file as needed for your own application. You are not required to use the Bootstrap framework to build your Laravel application - it is provided as a good starting point for those who choose to use it.Before compiling your CSS, install your project's frontend dependencies using the Node package manager (NPM):npm installOnce the dependencies have been installed using npm install, you can compile your SASS files to plain CSS using Laravel Mix. The npm run dev command will process the instructions in your webpack.mix.js file. Typically, your compiled CSS will be placed in the public/css directory:npm run devThe default webpack.mix.js included with Laravel will compile the resources/assets/sass/app.scss SASS file. This app.scss file imports a file of SASS variables and loads Bootstrap, which provides a good starting point for most applications. Feel free to customize the app.scss file however you wish or even use an entirely different pre-processor by configuring Laravel Mix.Writing JavaScriptAll of the JavaScript dependencies required by your application can be found in the package.json file in the project's root directory. This file is similar to a composer.json file except it specifies JavaScript dependencies instead of PHP dependencies. You can install these dependencies using the Node package manager (NPM):npm install By default, the Laravel package.json file includes a few packages such as vue and axios to help you get started building your JavaScript application. Feel free to add or remove from the package.json file as needed for your own application.Once the packages are installed, you can use the npm run dev command to compile your assets. Webpack is a module bundler for modern JavaScript applications. When you run the npm run dev command, Webpack will execute the instructions in your webpack.mix.js file:npm run devBy default, the Laravel webpack.mix.js file compiles your SASS and the resources/assets/js/app.js file. Within the app.js file you may register your Vue components or, if you prefer a different framework, configure your own JavaScript application. Your compiled JavaScript will typically be placed in the public/js directory. The app.js file will load the resources/assets/js/bootstrap.js file which bootstraps and configures Vue, Axios, jQuery, and all other JavaScript dependencies. If you have additional JavaScript dependencies to configure, you may do so in this file.Writing Vue ComponentsBy default, fresh Laravel applications contain an ExampleComponent.vue Vue component located in the resources/assets/js/components directory. The ExampleComponent.vue file is an example of a single file Vue component which defines its JavaScript and HTML template in the same file. Single file components provide a very convenient approach to building JavaScript driven applications. The example component is registered in your app.js file:Vue.component(    'example-component',    require('./components/ExampleComponent.vue'));To use the component in your application, you may drop it into one of your HTML templates. For example, after running the make:auth Artisan command to scaffold your application's authentication and registration screens, you could drop the component into the home.blade.php Blade template:@extends('layouts.app')@section('content')    @endsection Remember, you should run the npm run dev command each time you change a Vue component. Or, you may run the npm run watch command to monitor and automatically recompile your components each time they are modified.Of course, if you are interested in learning more about writing Vue components, you should read the Vue documentation, which provides a thorough, easy-to-read overview of the entire Vue framework.Using ReactIf you prefer to use React to build your JavaScript application, Laravel makes it a cinch to swap the Vue scaffolding with React scaffolding. On any fresh Laravel application, you may use the preset command with the react option:php artisan preset reactThis single command will remove the Vue scaffolding and replace it with React scaffolding, including an example component.",
            "url": "/documentation/laravel/Frontend/frontend"
          }
          ,
        
          "documentation-vuejs-essentials-the-vue-instance" :{
            "title": "ایجاد نمونه Vue",
            "content": "  ایجاد نمونه Vue (Creating a Vue Instance)هر برنامه Vue با ایجاد یک نمونه جدید از Vue با استفاده از تابع Vue شروع می شود:var vm = new Vue({  // options})اگرچه کاملاً با الگوی MVVM مطابقت ندارد ، اما طراحی Vue تا حدی از آن الهام گرفته شده است. به عنوان یک قرارداد ، ما اغلب از متغیر vm (کوتاه برای ViewModel) برای مراجعه به نمونه Vue استفاده می کنیم.برنامه Vue شامل یک نمونه root Vue  است که با new Vue ایجاد شده و به صورت اختیاری در یک درخت از اجزای تودرتو و قابل استفاده مجدد قرار گرفته است. به عنوان مثال ، ممکن است درخت کامپوننت یک برنامه todo مانند زیر باشد:Root Instance└─ TodoList   ├─ TodoItem   │  ├─ DeleteTodoButton   │  └─ EditTodoButton   └─ TodoListFooter      ├─ ClearTodosButton      └─ TodoListStatisticsبعداً در مورد سیستم کامپوننت صحبت خواهیم کرد. در حال حاضر ، فقط بدانید که همه کامپوننت های Vue نیز نمونه های Vue هستند   اصول دیتا و متد (Data and Methods)هنگامی که یک نمونه Vue ایجاد شد ، تمام خصوصیاتی را که در شیء داده آن یافت می شود به سیستم واکنش پذیری Vue اضافه می شود. هنگامی که مقادیر آن خصوصیات تغییر می کند ، لایه view \"واکنش\" می دهد و به روز می شود تا با مقادیر جدید مطابقت داشته باشد.// Our data objectvar data = { a: 1 }// The object is added to a Vue instancevar vm = new Vue({  data: data})// Getting the property on the instance// returns the one from the original datavm.a == data.a // =&gt; true// Setting the property on the instance// also affects the original datavm.a = 2data.a // =&gt; 2// ... and vice-versadata.a = 3vm.a // =&gt; 3با تغییر این داده ها ، view  مجددا رندر می شود. لازم به ذکر است که خواص موجود در data تنها در صورتی واکنش نشان می دهند که در زمان ایجاد نمونه وجود داشته باشند. این بدان معناست که اگر یک ویژگی جدید اضافه کنید ، مانند:vm.b = 'hi'تغییرات در b باعث بروز رسانی در  view نمی شود. اگر بدانید بعداً به یک خاصیت احتیاج دارید ، اما در ابتداخالی یا غیر موجود است ، شما در ابتدا باید مقداری اولیه تعیین کنید. برای مثال:data: {  newTodoText: '',  visitCount: 0,  hideCompletedTodos: false,  todos: [],  error: null}تنها استثنا در این مورد استفاده از ()Object.freeze  است که از تغییر خصوصیات موجود جلوگیری می کند و این بدان معنی است که سیستم واکنش پذیری نمی تواند تغییرات را ردیابی کند.var obj = {  foo: 'bar'}Object.freeze(obj)new Vue({  el: '#app',  data: obj})&#x3C;div id=&#x22;app&#x22;&#x3E;  &#x3C;p&#x3E;&#123;&#123; foo &#125;&#125;&#x3C;/p&#x3E;  &#x3C;!-- this will no longer update &#x60;foo&#x60;! --&#x3E;  &#x3C;button v-on:click=&#x22;foo = &#x27;baz&#x27;&#x22;&#x3E;Change it&#x3C;/button&#x3E;&#x3C;/div&#x3E;علاوه بر خواص داده ، نمونه های Vue دارای تعدادی از خصوصیات و متد های مفید می باشند. آنها دارای پیشوند $ می باشند تا از ویژگیهای تعریف شده توسط کاربر متمایز شوند. مثلا:var data = { a: 1 }var vm = new Vue({  el: '#example',  data: data})vm.$data === data // =&gt; truevm.$el === document.getElementById('example') // =&gt; true// $watch is an instance methodvm.$watch('a', function (newValue, oldValue) {  // This callback will be called when `vm.a` changes})می توانید برای داشتن لیست کاملی از خصوصیات و متدها ،  به   API reference مراجعه نمایید.  چرخه سیستم (Instance Lifecycle Hooks)هر نمونه Vue هنگام ایجاد یک سری مراحل اولیه سازی را طی می کند - برای مثال ، باید data را تنظیم کند ، قالب را کامپایل کند ، نمونه را روی DOM سوار کند و در هنگام تغییر داده ها DOM را به روز کند. در طی مسیر ، توابعی به نام  lifecycle hooks نیز فراخوانی می شوند و به کاربران این امکان را می دهد تا در مراحل خاص کد مخصوص خود را اضافه کنند.به عنوان مثال ، هاک created می تواند پس از ایجاد نمونه ، برای اجرای کد استفاده شود:new Vue({  data: {    a: 1  },  created: function () {    // `this` points to the vm instance    console.log('a is: ' + this.a)  }})// =&gt; \"a is: 1\"Hook های دیگری نیز وجود دارد که در مراحل مختلف چرخه حیات مانند mounted (نصب و سوار شدن)  ، updated ( به روزرسانی) و destroyed (از بین رفتن) فراخوانی می شوند.از arrow functions در property و callback همانند زیر استفاده نکنیدcreated: () =&gt; console.log(this.a)vm.$watch('a', newValue =&gt; this.myMethod())باعث خطاهایی نظیر زیر می شود:Uncaught TypeError: Cannot read property of undefinedUncaught TypeError: this.myMethod is not a function  دیاگرام چرخه سیستم (Lifecycle Diagram)چرخه سیستم را بصورت دیاگرام در زیر نمایش داده شده است :",
            "url": "/documentation/vuejs/Essentials/The-Vue-Instance"
          }
          ,
        
          "documentation-vuejs-essentials-template-syntax" :{
            "title": "اصول قالب در Vue",
            "content": "  ایجاد نمونه  (Creating a Vue Instance)Vue.js از نحو قالب مبتنی بر HTML استفاده می کند که به شما امکان می دهد DOM رندر شده را به داده های نمونه ایجاد شده Vue  متصل کنید. همه قالب های Vue.js دارای HTML معتبری هستند که می تواند توسط مرورگرهای خاص و سازگار با آن تجزیه و تحلیل شود.Vue قالبها را به توابع DOM مجازی کامپایل می کند. همراه با سیستم واکنش پذیری ، Vue قادر است هوشمندانه به حداقل تعداد کامپوننت ها جهت رندر مجدد و اعمال حداقل دستکاری DOM هنگام تغییر وضعیت برنامه ، پی برد.  متن (Text)معمول ترین شکل اتصال داده ها استفاده از نحو Mustache (دابل براکت) می باشد :&#x3C;span&#x3E;Message: &#123;&#123; msg &#125;&#125;&#x3C;/span&#x3E;متن Mustache با مقدار ویژگی msg در شی داده مربوطه جایگزین می شود. همچنین هرگاه مقدار ویژگی خاصیت داده شی تغییر کند متن آن نیز بروزرسانی می شود.شما همچنین می توانید عمل جایگذاری را یک بار انجام دهید که با استفاده از دستورالعمل v-once داده ها بیش از یکبار بروزرسانی نمی شود ، اما در نظر داشته باشید که این امر می تواند بر روی اتصال داده در سایر گره ها (node) نیز تأثیرگذار باشد:&#x3C;span v-once&#x3E;This will never change: &#123;&#123; msg &#125;&#125;&#x3C;/span&#x3E; داده نوع (Raw HTML)استفاده از نحو (mustaches) برای داده های متنی کاربرد دارد. جهت داده های HTML شما می توانید از دایرکتیو v-html استفاده نمایید :&#x3C;div id=&#x22;app-1&#x22;&#x3E;&#x3C;p&#x3E;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&#x3C;/p&#x3E;&#x3C;p&#x3E;Using v-html directive: &#x3C;span v-html=&#x22;rawHtml&#x22;&#x3E;&#x3C;/span&#x3E;&#x3C;/p&#x3E;&#x3C;/div&#x3E; var app1 = new Vue({    el: '#app-1',    data: {    rawHtml: '&#x3C;span style=&#x22;color: red&#x22;&#x3E;This should be red.&#x3C;/span&#x3E;'    } })   Using mustaches: &#123;&#123; rawHtml &#125;&#125;   Using v-html directive: رندر داینامیکی HTML دلخواه در وب سایت شما می تواند بسیار خطرناک باشد زیرا به راحتی می تواند منجر به آسیب پذیری XSS شود. فقط از جایگذاری HTML بر روی محتوای قابل اعتماد استفاده شود و هرگز در محتوای ارائه شده توسط کاربر استفاده نکنید.   صفات (Attributes)نحو(Mustaches) را نمی توان در صفات HTML استفاده کرد. در عوض می توانید از دستورالعمل v-bind استفاده نمایید:&#x3C;div v-bind:id=&#x22;dynamicId&#x22;&#x3E;&#x3C;/div&#x3E;در مورد صفات boolean ، جایی که شرط  آنها منتهی بر true  می شود ، v-bind کمی متفاوت عمل می کند. در این مثال:&#x3C;button v-bind:disabled=&#x22;isButtonDisabled&#x22;&#x3E;Button&#x3C;/button&#x3E;اگر isButtonDisabled مقدار null،  undefined یا false داشته باشد ، ویژگی disabled حتی در عنصر &#x3C;button&#x3E;  نیز درج نخواهد شد.    استفاداه از عبارات جاوااسکریپت(Using JavaScript Expressions)Vue.js  از تمام عبارات جاوا اسکریپت در کلیه اتصالات داده پشتیبانی می کند:  &#123;&#123; number + 1 &#125;&#125;  &#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;  &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;  &#x3C;div v-bind:id=&#x22;&#x27;list-&#x27; + id&#x22;&#x3E;&#x3C;/div&#x3E;  یک محدودیت این است که هر اتصال فقط می تواند یک عبارت واحد داشته باشد ، بنابراین موارد زیر کار نمی کند:   &#x3C;!-- this is a statement, not an expression: --&#x3E;  &#123;&#123; var a = 1 &#125;&#125;    &#x3C;!-- flow control won&#x27;t work either, use ternary expressions --&#x3E;  &#123;&#123; if (ok) { return message } &#125;&#125;    عبارات قالب  فقط به لیست سفید از توابع مانند Math و Date دسترسی دارند و شما نباید سعی کنید در عبارات به توابع  تعریف شده توسط کاربر دسترسی داشته باشید      استفاداه از دایرکتیو(Directives)  دایرکتیوها  ویژگی های خاصی با پیشوند -v هستند و مقدار آن،  یک عبارت جاوا اسکریپت واحد  می باشد(به استثنای v-for ، که بعداً مورد بحث قرار خواهد گرفت).  کار یک دایرکتیو این است که وقتی مقدار یک عبارت تغییر کرد ، تاثیر آن را روی DOM اعمال نماید. بیایید مثالی را که در مقدمه دیدیم مرور کنیم:  &#x3C;p v-if=&#x22;seen&#x22;&#x3E;Now you see me&#x3C;/p&#x3E;    در اینجا ، دستورالعمل v-if عنصر &#x3C;p&#x3E; را براساس نتیجه عبارتی که دیده می شود ، حذف یا درج می کند.      آرگومان ها در دایرکتیو(Arguments)  برخی از دایرکتیوها می توانند یک آرگومان دریافت کنند ، که پس از نام دایرکتیو توسط کاراکتر :  مشخص شده اند. به عنوان مثال ، دستورالعمل v-bind برای به روزرسانی واکنشی یک ویژگی HTML استفاده می شود:  &#x3C;a v-bind:href=&#x22;url&#x22;&#x3E; ... &#x3C;/a&#x3E;      در اینجا href آرگومانی است که به دایرکتیو v-bind می گوید ویژگی href عنصر را به مقدار عبارت url متصل کند.      مثال دیگر دایرکتیو v-on است که به رویدادهای DOM گوش می دهد:   &#x3C;a v-on:click=&#x22;doSomething&#x22;&#x3E; ... &#x3C;/a&#x3E;      در اینجا آرگومان، نام رویدادی جهت گوش دادن به است. ما در مورد جزئیات رویدادها نیز با جزئیات بیشتری صحبت خواهیم کرد.       آرگومان های داینامیک(Dynamic Arguments) از نسخه 2.6.0 ، همچنین می توانید از یک عبارات جاوا اسکریپت  به عنوان یک آرگومان دایرکتیو  در درون [] استفاده نمایید:   &#x3C;!--  Note that there are some constraints to the argument expression, as explained  in the &#x22;Dynamic Argument Expression Constraints&#x22; section below.  --&#x3E;  &#x3C;a v-bind:[attributeName]=&#x22;url&#x22;&#x3E; ... &#x3C;/a&#x3E;  var vm = new Vue({     el: '#app',     data: {         attributename : 'href',         url : 'http://farhadnote.ir'     } })  در اینجا  attributeName به صورت پویا به عنوان یک عبارت جاوا اسکریپت ارزیابی می شود و از مقدار ارزیابی شده آن به عنوان مقدار نهایی برای آرگومان استفاده می شود. به عنوان مثال ، اگر نمونه Vue شما دارای ویژگی داده attributename باشد و مقدار آن برابر \"href\" است ، این معادل است با v-bind: href.    به طور مشابه ، می توانید از آرگومان های پویا برای پیوند دادن یک کنترل کننده به نام یک رویداد پویا استفاده کنید:  &#x3C;a v-on:[eventName]=&#x22;doSomething&#x22;&#x3E; ... &#x3C;/a&#x3E;  var vm = new Vue({     el: '#app',     data: {         eventname : 'click'     },     methods: {         doSomething : function(){             alert('hello world');         }     } })  در این مثال، زمانیکه مقدار eventname برابر \"click\" باشد آنگاه v-on:[eventName]  معادل v-on:click خواهد شد.  محدودیت های مقدار  (Dynamic Argument Value Constraints)    انتظار می رود آرگومان های پویا ، یک رشته را به استثنای null ارزیابی کنند. از مقدار ویژه  null می توان جهت حذف صریح اتصال استفاده کرد. هر مقدار غیر رشته ای دیگر باعث ایجاد اخطار می گردد.  محدودیت های عبارات  (Dynamic Argument Expression Constraints)    عبارات آرگومان پویا محدودیت های نحوی دارند زیرا برخی از کاراکترها ها مانند فضاها و نقل قول ها در نام های ویژگی های HTML نامعتبر هستند. به عنوان مثال موارد زیر نامعتبر است:  &#x3C;!-- This will trigger a compiler warning. --&#x3E;   &#x3C;a v-bind:[&#x27;foo&#x27; + bar]=&#x22;value&#x22;&#x3E; ... &#x3C;/a&#x3E;     راه حل این است که یا از عبارات بدون فاصله یا نقل قول استفاده کنید ، یا عبارت پیچیده را با یک ویژگی computed جایگزین کنید.    هنگام استفاده از قالب ها در DOM (قالب هایی که مستقیماً در یک فایل HTML نوشته شده اند) ، باید از نامگذاری کلیدها با کاراکترهای بزرگ خودداری کنید ، زیرا مرورگرها اسم ویژگی ها را به حروف کوچک محدود می کنند:  &#x3C;!-- This will be converted to v-bind:[someattr] in in-DOM templates. Unless you have a &#x22;someattr&#x22; property in your instance, your code won&#x27;t work. --&#x3E; &#x3C;a v-bind:[someAttr]=&#x22;value&#x22;&#x3E; ... &#x3C;/a&#x3E;        اصلاح کننده ها(Modifiers)Modifiers (اصلاح کننده) پسوندهای خاصی هستند که با یک نقطه مشخص می شوند  و  بیانگر این است که یک دایرکتیو باید به روشی خاص محدود شود. به عنوان مثال ، اصلاح کننده prevent به دایرکتیو v-on می گوید  تابع ()preventDefault را در هنگام  آغاز رویداد فراخوانی کند:   &#x3C;form v-on:submit.prevent=&#x22;onSubmit&#x22;&#x3E; ... &#x3C;/form&#x3E;      در آینده  این ویژگیها را بررسی کرده و نمونه های دیگری از اصلاح کننده ها را برای مدل v-on و v-model مشاهده خواهید کرد.       مختصرنویسی(Shorthands)پیشوند -v به عنوان یک نشانه بصری برای شناسایی ویژگی های خاص Vue در قالب های شما استفاده می شود. این زمانی مفید است که از Vue.js برای اعمال رفتار پویا در برخی از نشانه های(markup) موجود استفاده می کنید ، اما می تواند موجب طولانی شدن  برای برخی از دایرکتیوهایی که اغلب استفاده می شود  گردد. در عین حال نیاز به پیشوند v-، هنگام ساختن SPA ، جایی که Vue هر الگویی را مدیریت می کند اهمیت کمتری می یابد. بنابراین ، Vue برای دو مورد از دایرکتیوهای متداول ، v-bind و v-on اصلاحات ویژه ای را ارائه می دهد:    اختصار v-bind&#x3C;!-- full syntax --&#x3E;   &#x3C;a v-bind:href=&#x22;url&#x22;&#x3E; ... &#x3C;/a&#x3E;      &#x3C;!-- shorthand --&#x3E;   &#x3C;a :href=&#x22;url&#x22;&#x3E; ... &#x3C;/a&#x3E;      &#x3C;!-- shorthand with dynamic argument (2.6.0+) --&#x3E;   &#x3C;a :[key]=&#x22;url&#x22;&#x3E; ... &#x3C;/a&#x3E;    اختصار v-on&#x3C;!-- full syntax --&#x3E;&#x3C;a v-on:click=&#x22;doSomething&#x22;&#x3E; ... &#x3C;/a&#x3E;&#x3C;!-- shorthand --&#x3E;&#x3C;a @click=&#x22;doSomething&#x22;&#x3E; ... &#x3C;/a&#x3E;&#x3C;!-- shorthand with dynamic argument (2.6.0+) --&#x3E;&#x3C;a @[event]=&#x22;doSomething&#x22;&#x3E; ... &#x3C;/a&#x3E;   آنها ممکن است کمی متفاوت از HTML نرمال به نظر برسند ، اما: و @ کاراکترهای برای نام ویژگی ها هستند و همه مرورگرهای دارای پشتیبانی Vue می توانند آن را به درستی تجزیه کنند. علاوه بر این ، آنها در مارک نهایی رندر شده ظاهر نمی شوند. نحو shorthand کاملاً اختیاری است.",
            "url": "/documentation/vuejs/Essentials/Template-Syntax"
          }
          ,
        
          "documentation-vuejs-essentials-computed-properties-and-watchers" :{
            "title": "خاصیت Computed و Watchers",
            "content": "  بررسی (Computed Properties)استفاده از عبارات در قالب ها بسیار راحت است ، اما بیشتر برای عملیات ساده مورد استفاده قرار می گیرند. قرار دادن منطق بیش از حد در الگوها نگه داری آن را سخت می کند. مثلا:&#x3C;div id=&#x22;example&#x22;&#x3E;   &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&#x3C;/div&#x3E;در این مثال ، قالب دیگر ساده و اعلامی نیست. وقتی می خواهید پیام معکوس شده را در الگوی خود بیش از یک بار بگنجانید این مشکل بدتر می شود.به همین دلیل برای هر منطق پیچیده ، باید از یک خاصیت computed  (محاسبه شده) استفاده کنید.مثال ساده :&#x3C;div id=&#x22;example&#x22;&#x3E;  &#x3C;p&#x3E;Original message: &#x22; &#123;&#123; message &#125;&#125;&#x22;&#x3C;/p&#x3E;  &#x3C;p&#x3E;Computed reversed message: &#x22; &#123;&#123; reversedMessage &#125;&#125;&#x22;&#x3C;/p&#x3E;&#x3C;/div&#x3E;var vm = new Vue({  el: '#example',  data: {    message: 'Hello'  },  computed: {    // a computed getter    reversedMessage: function () {      // `this` points to the vm instance      return this.message.split('').reverse().join('')    }  }})نتیجه:  Original message: \"&#123;&#123; message &#125;&#125;\"  Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"در اینجا ما یک  خاصیت computed  به نام reversedMessage اعلان کرده ایم. تابعی که ارائه دادیم به عنوان تابع getter  برای ویژگی vm.reversedMessage استفاده خواهد شد:console.log(vm.reversedMessage) // =&gt; 'olleH'vm.message = 'Goodbye'console.log(vm.reversedMessage) // =&gt; 'eybdooG'می توانید console را باز کرده و با مثال vm خود کار کنید. مقدار vm.reversedMessage همیشه به مقدار vm.message بستگی دارد.شما  می توانید داده ها را به  خاصیت های computed در قالب ها دقیقاً همانند یک ویژگی معمولی متصل کنید.  Vue می داند که vm.reversedMessage به vm.message بستگی دارد ، بنابراین هر اتصالی که وابسته به vm.reversedMessage  باشد را زمانیکه   vm.message تغییر کند به روز رسانی می کند. بهترین قسمت کار این است که ما این رابطه وابستگی را بصورت اعلانی ایجاد کرده ایم و این باعث می شود تست و درک آن آسان تر شود.  مقایسه Computed Caching  با  Methodsشاید متوجه شده باشید که با استفاده از method در عبارت می توانیم به نتیجه مشابه برسیم:&#x3C;p&#x3E;Reversed message: &#x22;&#123;&#123; reverseMessage() &#125;&#125;&#x22;&#x3C;/p&#x3E;// in componentmethods: {  reverseMessage: function () {    return this.message.split('').reverse().join('')  }}به جای یک خاصیت computed ، می توانیم همان عملکرد را به عنوان یک method تعریف کنیم. نتایج برای هردو یکسان است. با این حال ، تفاوت در این است که خاصیت های computed بر اساس وابستگی واکنشی آنها  ذخیره موقت (cached)  می شوند. یک خاصیت computed  فقط در صورت تغییر برخی از وابستگی های واکنشی آن ، دوباره ارزیابی می شود.  این بدان معنی است تا زمانی که پیام تغییر نکرده ، دسترسی چندگانه به خاصیت computed (محاسبه شده)  reversedMessage بلافاصله بدون نیاز به اجرای دوباره عملکرد ، نتیجه قبلاً محاسبه شده را برمی گرداند.این همچنین بدان معنی است که ویژگی computed  زیر هرگز به روز نمی شود ، زیرا  ()Date.now یک وابستگی واکنشی نیست:computed: {  now: function () {    return Date.now()  }}در مقایسه ،  method هر زمان که یک رندر دوباره(re-render) رخ دهد عملکرد را انجام می دهد.چرا ما نیاز به ذخیره سازی موقت محاسبات داریم؟ تصور کنید که ما یک خاصیت  computed  به نام A  با محاسبات سنگین داشته باشیم  که نیاز به حلقه زدن در یک Array عظیم و انجام محاسبات زیادی دارد. بنابراین ممکن است ما خاصیت های  computed  دیگری داشته باشیم که به نوبه خود به A بستگی داشته باشند . بدون ذخیره کردن ، چند بار بیشتر از حد لازم A را اجرا  می کنیم! در مواردی که نمی خواهید حافظه پنهانی داشته باشید ، به جای آن از method استفاده کنید.  مقایسه  Computed  با  watchVue روشی عمومی تر برای مشاهده و واکنش به تغییرات داده ها در یک نمونه فراهم می کند به نام خاصیت watch. چنانچه داده هایی دارید که بر اساس برخی داده های دیگر تغییر می کنند ، استفاده از watch می تواند بسیار وسوسه انگیز باشد  به خصوص اگر قبلا با محیط کار AngularJS  کار کرده باشید. با این حال ، اغلب ایده بهتر استفاده از خاصیت computed  می باشد. این مثال را در نظر بگیرید:&#x3C;div id=&#x22;demo&#x22;&#x3E;&#123;&#123; fullName &#125;&#125;&#x3C;/div&#x3E;var vm = new Vue({  el: '#demo',  data: {    firstName: 'Foo',    lastName: 'Bar',    fullName: 'Foo Bar'  },  watch: {    firstName: function (val) {      this.fullName = val + ' ' + this.lastName    },    lastName: function (val) {      this.fullName = this.firstName + ' ' + val    }  }})کد بالا ضروری و تکراری است.حال آن را با یک نسخه  computed مقایسه کنید:var vm = new Vue({  el: '#demo',  data: {    firstName: 'Foo',    lastName: 'Bar'  },  computed: {    fullName: function () {      return this.firstName + ' ' + this.lastName    }  }})خیلی بهتر است ، اینطور نیست؟ افزودن Setter به Computedویژگی های Computed به صورت پیش فرض فقط دارای getter می باشند ، اما می توانید در صورت نیاز به آن یک setter نیز اضافه نمایید:// ...computed: {  fullName: {    // getter    get: function () {      return this.firstName + ' ' + this.lastName    },    // setter    set: function (newValue) {      var names = newValue.split(' ')      this.firstName = names[0]      this.lastName = names[names.length - 1]    }  }}// ...اکنون وقتی vm.fullName = 'John Doe' را اجرا کردید ،setter فراخوانی می شود و vm.firstName و vm.lastName به همین ترتیب به روز می شوند. بررسی Watchersدر حالی که خاصیت های computed  در بیشتر موارد مناسب تر هستند ، مواقعی وجود دارد که یک watcher (مشاهده گر) سفارشی می تواند ضرورت داشته باشد. به همین دلیل است که Vue یک روش عمومی تر برای واکنش به تغییرات داده ها از طریق watch  ارائه می دهد. بیشترین کاربرد زمانیست که بخواهید عملیات ناهمزمان (asynchronous) در پاسخ به تغییر داده ها ، داشته باشید.برای مثال:&#x3C;div id=&#x22;watch-example&#x22;&#x3E;  &#x3C;p&#x3E;    Ask a yes/no question:    &#x3C;input v-model=&#x22;question&#x22;&#x3E;  &#x3C;/p&#x3E;  &#x3C;p&#x3E;&#123;&#123; answer &#125;&#125;&#x3C;/p&#x3E;&#x3C;/div&#x3E;&#x3C;!-- Since there is already a rich ecosystem of ajax libraries    --&#x3E;&#x3C;!-- and collections of general-purpose utility methods, Vue core --&#x3E;&#x3C;!-- is able to remain small by not reinventing them. This also   --&#x3E;&#x3C;!-- gives you the freedom to use what you&#x27;re familiar with.      --&#x3E;&#x3C;script src=&#x22;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&#x22;&#x3E;&#x3C;/script&#x3E;&#x3C;script src=&#x22;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&#x22;&#x3E;&#x3C;/script&#x3E;&#x3C;script&#x3E;var watchExampleVM = new Vue({  el: &#x27;#watch-example&#x27;,  data: {    question: &#x27;&#x27;,    answer: &#x27;I cannot give you an answer until you ask a question!&#x27;  },  watch: {    // whenever question changes, this function will run    question: function (newQuestion, oldQuestion) {      this.answer = &#x27;Waiting for you to stop typing...&#x27;      this.debouncedGetAnswer()    }  },  created: function () {    // _.debounce is a function provided by lodash to limit how    // often a particularly expensive operation can be run.    // In this case, we want to limit how often we access    // yesno.wtf/api, waiting until the user has completely    // finished typing before making the ajax request. To learn    // more about the _.debounce function (and its cousin    // _.throttle), visit: https://lodash.com/docs#debounce    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)  },  methods: {    getAnswer: function () {      if (this.question.indexOf(&#x27;?&#x27;) === -1) {        this.answer = &#x27;Questions usually contain a question mark. ;-)&#x27;        return      }      this.answer = &#x27;Thinking...&#x27;      var vm = this      axios.get(&#x27;https://yesno.wtf/api&#x27;)        .then(function (response) {          vm.answer = _.capitalize(response.data.answer)        })        .catch(function (error) {          vm.answer = &#x27;Error! Could not reach the API. &#x27; + error        })    }  }})&#x3C;/script&#x3E;در این حالت ، استفاده از گزینه Watch به ما این امکان را می دهد تا عملیاتی asynchronous  (ناهمزمان) (دسترسی به یک API) را انجام دهیم ، تعداد دفعات عملیات را می توان محدود و حالت های واسطه را تنظیم کنیم تا پاسخ نهایی را بدست آوریم. هیچ یک از این موارد با خاصیت computed  امکان پذیر نیست.علاوه بر گزینه Watch ، می توانید از vm.$watch API  نیز استفاده کنید.",
            "url": "/documentation/vuejs/Essentials/Computed-Properties-and-Watchers"
          }
          ,
        
          "documentation-vuejs-essentials-class-and-style-bindings" :{
            "title": "اتصال Class و Style",
            "content": " بررسی (Class and Style Bindings)یک نیاز مشترک برای اتصال داده ها ، دستکاری در لیست class المان ها و style  درون خطی آن است. از آنجا که هر دو صفت هستند ، می توانیم از v-bind برای دستکاری آنها استفاده کنیم: ما فقط نیاز داریم که رشته نهایی را با عبارات خود ایجاد کنیم. با این حال ، استفاده از  اتصال رشته ها  خسته کننده و مستعد خطا است. به همین دلیل ، Vue ابزار ویژه ای را جهت  استفاده از v-bind  در class و style ارائه می دهد.Binding HTML Classesاستفاده از روش Object Syntaxما می توانیم یک object  را از طریف v-bind:class منتقل کنیم:&#x3C;div v-bind:class=&#x22;{ active: isActive }&#x22;&#x3E;&#x3C;/div&#x3E;نحو فوق به این معنی است که فعل بودن کلاس active  توسط مقدار boolean  خاصیت  isActive مشخص خواهد شد.همچنین جهت اتصال چندین کلاس می توانیم  بدینصورت عمل کنیم:&#x3C;div  class=&#x22;static&#x22;  v-bind:class=&#x22;{ active: isActive, &#x27;text-danger&#x27;: hasError }&#x22;&#x3E;&#x3C;/div&#x3E;و داده های زیر:data: {  isActive: true,  hasError: false}و بدینصورت  رندر خواهد شد:&#x3C;div class=&#x22;static active&#x22;&#x3E;&#x3C;/div&#x3E;زمانیکه مقدار isActive  یا hasError تغییر می کند، لیست class براین اساس بروزرسانی می گردد. برای مثال اگر مقدار  hasError برابر true باشد،  لیست class  بدین صورت خواهد بود : \"static active text-danger\".لازم نیست object بصورت inline محدود گردد:&#x3C;div v-bind:class=&#x22;classObject&#x22;&#x3E;&#x3C;/div&#x3E;data: {  classObject: {    active: true,    'text-danger': false  }}این نتیجه همان نتیجه را خواهد داد. ما همچنین می توانیم به یک خاصیت computed  که یک شی را برمی گرداند متصل شویم که الگوی رایج و مناسبی است:&#x3C;div v-bind:class=&#x22;classObject&#x22;&#x3E;&#x3C;/div&#x3E;data: {  isActive: true,  error: null},computed: {  classObject: function () {    return {      active: this.isActive &amp;&amp; !this.error,      'text-danger': this.error &amp;&amp; this.error.type === 'fatal'    }  }}استفاده از روش Array Syntaxما می توانیم یک آرایه رابه v-bind:class  انتقال دهیم تا یک لیست از کلاس ایجاد نماییم :&#x3C;div v-bind:class=&#x22;[activeClass, errorClass]&#x22;&#x3E;&#x3C;/div&#x3E;data: {  activeClass: 'active',  errorClass: 'text-danger'}که بصووت زیر رندر می شود:&#x3C;div class=&#x22;active text-danger&#x22;&#x3E;&#x3C;/div&#x3E;اگر بخواهید یک کلاس را بصورت  مشروط از یک لیست انتخاب نمایید می توانید بصورت زیر عمل  نمایید:&#x3C;div v-bind:class=&#x22;[isActive ? activeClass : &#x27;&#x27;, errorClass]&#x22;&#x3E;&#x3C;/div&#x3E;چنانچه isActive برابر true باشد مقدار class برابر activeClass  در غیر اینصورت errorClass خواهد بود.با این وجود ، اگر چندین کلاس مشروط داشته باشید ، می تواند کمی طولانی گردد. به همین دلیل امکان استفاده از object syntax در ترکیب با array syntax نیز وجود دارد:&#x3C;div v-bind:class=&#x22;[{ active: isActive }, errorClass]&#x22;&#x3E;&#x3C;/div&#x3E;استفاده از Componentsدر این بخش فرض بر این است که شما با مبحث  Vue Component آشنا باشید. زمانیکه شما از صفت class در یک کامپوننت سفارشی استفاده می کنید، آن کلاس ها به عنصر root کامپوننت اضافه می گردند. کلاس های موجود در این عنصر بازنویسی نخواهند شد.برای مثال چنانچه کامپوننت زیر را اعلام کنیم:Vue.component('my-component', {  template: '&#x3C;p class=&#x22;foo bar&#x22;&#x3E;Hi&#x3C;/p&#x3E;'})چنانچه داشته باشیم:&#x3C;my-component class=&#x22;baz boo&#x22;&#x3E;&#x3C;/my-component&#x3E;HTML رندر شده بدین صورت خواهد بود:&#x3C;p class=&#x22;foo bar baz boo&#x22;&#x3E;Hi&#x3C;/p&#x3E;در مورد اتصال کلاس نیز همین موضوع صادق است:&#x3C;my-component v-bind:class=&#x22;{ active: isActive }&#x22;&#x3E;&#x3C;/my-component&#x3E;زمانیکه isActive برابر true باشد، HTML رندر شده بدین صورت خواهد بود:&#x3C;p class=&#x22;foo bar active&#x22;&#x3E;Hi&#x3C;/p&#x3E;اتصال  Inline Stylesاستفاده از Object Syntaxاستفاده از object syntax برای  v-bind:style کاملاً ساده است - تقریباً شبیه CSS است ، با این تفاوت که یک شیء JavaScript است. می توانید جهت نامگذاری خاصیت های CSS از هریک از روش های  camelCase و یا kebab-case استفاده نمایید :&#x3C;div v-bind:style=&#x22;{ color: activeColor, fontSize: fontSize + &#x27;px&#x27; }&#x22;&#x3E;&#x3C;/div&#x3E;data: {  activeColor: &#x27;red&#x27;,  fontSize: 30}غالباً ایده ی خوبی است که مستقیماً به یک شیء style   متصل شوید تا قالب تمیزتر شود:&#x3C;div v-bind:style=&#x22;styleObject&#x22;&#x3E;&#x3C;/div&#x3E;data: {  styleObject: {    color: 'red',    fontSize: '13px'  }}روش object syntax اغلب در رابطه با خاصیت های computed  که یک شی را برمی گردانند استفاده می شود.استفاده از Array Syntaxروش array syntax برای  v-bind:style  این اجازه را می دهد تا چندین style objects را اعمال نمایید.&#x3C;div v-bind:style=&#x22;[baseStyles, overridingStyles]&#x22;&#x3E;&#x3C;/div&#x3E;Auto-prefixingزمانیکه شما بخواهید یک خاصیت CSS که شامل  vendor prefixes  را در  v-bind:style استفاده نمایید، برای مثال (-webkit-،transformT)،Vue بصورت اتوماتیک آنها را شناسایی و پیشوندهای مناسب را به آن ها اضافه و به style اعمال می نماید.Multiple Valuesاز نسخه 2.3.0+ شما می توانید آرایه ای از پیشوندها را جهت اعمال در خواص Style فراهم نمایید. برای مثال : &#x3C;div v-bind:style=&#x22;{ display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] }&#x22;&#x3E;&#x3C;/div&#x3E;تنها آخرین مقدار در آرایه که مرورگر از آن پشتیبانی می کند رندر خواهد شد. در این مثال ،display: flex      برای مرورگرهایی که نسخه غیر پیشوند از flexbox را پشتیبانی می کنند رندر خواهد شد.",
            "url": "/documentation/vuejs/Essentials/Class-and-Style-Bindings"
          }
          ,
        
          "documentation-vuejs-essentials-conditional-rendering" :{
            "title": "رندرینگ شرطی  (Conditional Rendering)",
            "content": "دایرکتیو v-if دایرکتیو v-if برای رندر مشروط یک بلوک به کار می رود. این بلوک تنها در صورتیکه عبارت دایرکتیو یک مقدار true  برگرداند رندر می شود.&#x3C;h1 v-if=&#x22;awesome&#x22;&#x3E;Vue is awesome!&#x3C;/h1&#x3E;همچنین می توان \"بلوک  else\" را با v-else اضافه کرد:&#x3C;h1 v-if=&#x22;awesome&#x22;&#x3E;Vue is awesome!&#x3C;/h1&#x3E;&#x3C;h1 v-else&#x3E;Oh no &#x1F622;&#x3C;/h1&#x3E;گروههای شرطی با v-if در &#x3C;template&#x3E;از آنجا که v-if یک دایرکتیو است ، باید به یک عنصر پیوست شود. اما اگر بخواهیم بیش از یک عنصر را تغییر دهیم چه می شود؟ در این حالت می توانیم از v-if در یک عنصر &#x3C;template&#x3E; که بقیه عناصر را در بر می گیرد ، استفاده کنیم. نتیجه ارائه شده نهایی عنصر &#x3C;template&#x3E; را شامل نمی شود.&#x3C;template v-if=&#x22;ok&#x22;&#x3E;  &#x3C;h1&#x3E;Title&#x3C;/h1&#x3E;  &#x3C;p&#x3E;Paragraph 1&#x3C;/p&#x3E;  &#x3C;p&#x3E;Paragraph 2&#x3C;/p&#x3E;&#x3C;/template&#x3E;دایرکتیو v-else می توانید از دایرکتیو v-else  برای نشان دادن \"بلاک else\" برای دایرکتیو v-if استفاده نمایید:&#x3C;div v-if=&#x22;Math.random() &#x3E; 0.5&#x22;&#x3E;  Now you see me&#x3C;/div&#x3E;&#x3C;div v-else&#x3E;  Now you don&#x27;t&#x3C;/div&#x3E;دایرکتیو v-else-if v-other-if ، همانطور که از نام آن پیداست ، جهت بلاک \"else if\" برای دایرکتیو v-if استفاده می شود.این دایرکتیو همچنین بصورت زنجیره ای می تواند بکار رود:&#x3C;div v-if=&#x22;type === &#x27;A&#x27;&#x22;&#x3E;  A&#x3C;/div&#x3E;&#x3C;div v-else-if=&#x22;type === &#x27;B&#x27;&#x22;&#x3E;  B&#x3C;/div&#x3E;&#x3C;div v-else-if=&#x22;type === &#x27;C&#x27;&#x22;&#x3E;  C&#x3C;/div&#x3E;&#x3C;div v-else&#x3E;  Not A/B/C&#x3C;/div&#x3E;کنترل عناصر قابل استفاده مجدد با keyVue سعی می کند عناصر را تا حد ممکن کارآمدتر کند ، و اغلب به جای رها کردن عناصر ، دوباره از آنها استفاده می کند. گذشته از کمکی که به سرعت Vue می کند، این می تواند مزایای مفیدی داشته باشد. به عنوان مثال ، اگر به کاربران اجازه می دهید بین چندین ورود به سیستم جابجا شوند:&#x3C;template v-if=&#x22;loginType === &#x27;username&#x27;&#x22;&#x3E;  &#x3C;label&#x3E;Username&#x3C;/label&#x3E;  &#x3C;input placeholder=&#x22;Enter your username&#x22;&#x3E;&#x3C;/template&#x3E;&#x3C;template v-else&#x3E;  &#x3C;label&#x3E;Email&#x3C;/label&#x3E;  &#x3C;input placeholder=&#x22;Enter your email address&#x22;&#x3E;&#x3C;/template&#x3E;            Username                        Email                        Toggle login type    سپس با تعویض loginType در کد بالا خواهیم دید آنچه را که کاربر قبلاً وارد کرده پاک نخواهد کرد. از آنجا که هر دو قالب از عناصر یکسان استفاده می کنند ، &#x3C;input&#x3E; جایگزین نمی شود – و فقط placeholder  تغییر می کند.این ویژگی همیشه مطلوب نیست ، بنابراین Vue راهی را برای شما فراهم می کند تا بگویید ، \"این دو عنصر کاملاً جدا از هم هستند - از آنها استفاده مجدد نکنید.\" و یک ویژگی key با مقادیر منحصر به فرد اضافه نمایید:&#x3C;template v-if=&#x22;loginType === &#x27;username&#x27;&#x22;&#x3E;  &#x3C;label&#x3E;Username&#x3C;/label&#x3E;  &#x3C;input placeholder=&#x22;Enter your username&#x22; key=&#x22;username-input&#x22;&#x3E;&#x3C;/template&#x3E;&#x3C;template v-else&#x3E;  &#x3C;label&#x3E;Email&#x3C;/label&#x3E;  &#x3C;input placeholder=&#x22;Enter your email address&#x22; key=&#x22;email-input&#x22;&#x3E;&#x3C;/template&#x3E;حالا هر بار که وارد شوید ، این ورودی ها از ابتدا ارائه می شوند. مشاهده کنید:            Username                        Email                        Toggle login type    توجه داشته باشید که عناصر &#x3C;label&#x3E; هنوز به طور مؤثر دوباره مورد استفاده قرار می گیرند ، زیرا آنها ویژگی  key ندارند.دایرکتیو v-show گزینه دیگر برای نمایش مشروط یک عنصر ، استفاده از دایرکتیو v-show است. نحوه استفاده تقریباً یکسان است:&#x3C;h1 v-show=&#x22;ok&#x22;&#x3E;Hello!&#x3C;/h1&#x3E;تفاوت این است که عنصری که با v-show رندر می شود همیشه در DOM باقی می ماند. v-show فقط صفت display   مربوط به  CSS عنصر را ضمیمه می کند.توجه داشته باشید که v-show از عنصر &#x3C;template&#x3E; پشتیبانی نمی کند ، و همچنین با v-else کار نمی کند.مقایسه v-if با  v-show v-ifیک رندر شرطی \"واقعی\" است زیرا تضمین می کند که شنوندگان رویدادها و کامپوننت های فرزند در داخل بلوک شرطی به درستی از بین می روند و در تغییر وضعیت مجدداً ایجاد شوند.v-if همچنین کند است: اگر شرط ارائه اولیه نادرست باشد ، رندری انجام نمی شود - بلوک شرطی رندر نخواهد شد تا زمانی که این شرط برای اولین بار صحیح شود.در مقایسه ، v-show بسیار ساده تر است - این عنصر همیشه بدون در نظر گرفتن شرایط اولیه ، با ایجاد تغییر در CSS پایه رندر می شود.به طور کلی ، v-if هزینه تغییر وضعیت بالاتری دارد در حالی که v-show دارای هزینه های رندر اولیه بالاتری است. بنابراین ، اگر لازم است عنصری را  اغلب تغییر وضعیت دهید ، v-show را ترجیح می دهیم و در صورت عدم احتمال تغییر در زمان اجرا ، v-if را ترجیح می دهیم.استفاده v-if به همراه  v-forاستفاده v-if و v-for با هم توصیه نمی شود. برای اطلاعات بیشتر به   style guide مراجعه کنید.درصورت استفاده همزمان، v-for دارای اواویت بالاتری نسبت به v-if است. برای اطلاعات بیشتر به   list rendering guide مراجعه کنید.",
            "url": "/documentation/vuejs/Essentials/Conditional-Rendering"
          }
          ,
        
          "documentation-vuejs-essentials-list-rendering" :{
            "title": "رندر List (List Rendering)",
            "content": "نگاشت آرایه به عناصر HTML با v-forما می توانیم از دایرکتیو v-for برای تهیه لیست از آیتم های  موجود در آرایه استفاده کنیم. دایرکتیو v-for  به صورت item in items به یک نحو خاص  نیاز دارد ، که در آن items  منبع دیتای آرایه  و item   یک نام مستعار برای عنصر آرایه که در آن تکرار می شود:&#x3C;ul id=&#x22;example-1&#x22;&#x3E;  &#x3C;li v-for=&#x22;item in items&#x22;&#x3E;    &#123;&#123; item.message &#125;&#125;  &#x3C;/li&#x3E;&#x3C;/ul&#x3E;var example1 = new Vue({  el: '#example-1',  data: {    items: [      { message: 'Foo' },      { message: 'Bar' }    ]  }})نتیجه :&#123;&#123; item.message &#125;&#125;در داخل بلوکهای v-for ، دسترسی کامل به ویژگیهای دامنه والدین داریم. v-for همچنین از یک آرگومان دوم اختیاری برای index  آیتم فعلی پشتیبانی می کند.&#x3C;ul id=&#x22;example-2&#x22;&#x3E;  &#x3C;li v-for=&#x22;(item, index) in items&#x22;&#x3E;    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;  &#x3C;/li&#x3E;&#x3C;/ul&#x3E;var example2 = new Vue({  el: '#example-2',  data: {    parentMessage: 'Parent',    items: [      { message: 'Foo' },      { message: 'Bar' }    ]  }})نتیجه :      &#123;&#123; parentMessage &#125;&#125; -  &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;  شما همچنین می توانید از of به جای in استفاده نمایید که به نحو جاوا اسکریپت برای تکرار کنندگان(iterators) نزدیکتر می باشد:&#x3C;div v-for=&#x22;item of items&#x22;&#x3E;&#x3C;/div&#x3E;استفاده از v-for به همراه objectهمچنین می توانید از v-for برای تکرار از طریق خواص یک object استفاده کنید.&#x3C;ul id=&#x22;v-for-object&#x22; class=&#x22;demo&#x22;&#x3E;  &#x3C;li v-for=&#x22;value in object&#x22;&#x3E;    &#123;&#123; value &#125;&#125;  &#x3C;/li&#x3E;&#x3C;/ul&#x3E;new Vue({  el: '#v-for-object',  data: {    object: {      title: 'How to do lists in Vue',      author: 'Jane Doe',      publishedAt: '2016-04-10'    }  }})نتیجه :      &#123;&#123; value &#125;&#125;  همچنین می توانید یک آرگومان دوم برای نام ویژگی ارائه دهید ( a.k.a. key):&#x3C;div v-for=&#x22;(value, name) in object&#x22;&#x3E;  &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&#x3C;/div&#x3E;  &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;و برای  index:&#x3C;div v-for=&#x22;(value, name, index) in object&#x22;&#x3E;  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&#x3C;/div&#x3E;  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;هنگام تکرار از طریق یک object ، مرتب سازی بر اساس ترتیب  ()Object.keys صورت می گیرد ، که تضمینی ندارد مطابق با پیاده سازی موتور جاوا اسکریپت باشد.حفظ وضعیت (Maintaining State)هنگامی که Vue در حال به روزرسانی لیستی از عناصر رندر شده با v-for است ، به طور پیش فرض از استراتژی  \" in-place patch \" استفاده می کند. اگر ترتیب داده ها تغییر کند ، به جای حرکت دادن عناصر DOM جهت تطبیق با ترتیب آیتم ها ، Vue هر عنصر را در جای خود قرار داده و اطمینان می دهد آنچه باید در آن index خاص رندر شود انعکاس یابد. این شبیه به رفتار track-by=\"$index\" در Vue 1.x می باشد.این حالت پیش فرض کارآمد است ، اما تنها در شرایطی مناسب است که خروجی لیست رندر شده شما به وضعیت کامپوننت فرزند  یا وضعیت DOM موقتی متکی نباشد (مثلاً مقادیر ورودی فرم).برای اشاره و راهنمایی به Vue که هویت هر گره را ردیابی کرده  تا بتواند از آن ها استفاده مجدد و عناصر موجود را دوباره مرتب سازی نماید ، نیاز دارید یک ویژگی key منحصر به فرد برای هر آیتم در نظر بگیرید:&#x3C;div v-for=&#x22;item in items&#x22; v-bind:key=&#x22;item.id&#x22;&#x3E;  &#x3C;!-- content --&#x3E;&#x3C;/div&#x3E;توصیه می شود در هر زمان ممکن یک ویژگی key با v-for ارائه دهید ، مگر اینکه محتوای DOM تکرار شونده ساده باشد ، یا عمداً جهت افزایش عملکرد ، بر رفتار پیش فرض تکیه می کنید.از آنجا که این یک مکانیسم عمومی جهت شناسایی گره ها توسط Vue است ، این key دارای کاربردهای دیگری نیز می باشد که به طور خاص با V-for گره خورده اند ، همانطور که بعداً در این راهنما خواهیم دید.از مقادیری همانند اشیاء و آرایه ها به عنوان کلیدهای v-for استفاده نکنید. به جای آن از مقادیر رشته یا عددی استفاده کنید.جهت استفاده دقیق از ویژگی key، به   API documentation   مراجعه نمایید.تشخیص تغییر در آرایه (Array Change Detection) متدهای جهش (Mutation Methods)Vue متدهای mutation  (جهش) آرایه ارائه داده  که باعث بروزرسانی های view نیز می شود. این متدها عبارتند از:push()pop()shift()unshift()splice()sort()reverse()شما می توانید console مرورگر خود را باز کرده و در مثال قبل با متدها کار کنید.برای مثال : example1.items.push({ message: 'Baz' }).جایگیزینی یک آرایه (Replacing an Array)متدهای Mutation ، همانطور که از نام آن مشخص است ، آرایه اصلی مورد نظر را جهش و دگرگون می کنند. در مقایسه ، روشهای غیر جهش نیز وجود دارد ، به عنوان مثال . ()filter(), concat  و ()slice، که آرایه اصلی را جهش نمی دهند ، اما همیشه یک آرایه جدید را برمی گردانند. هنگام کار با روش های غیر جهش ، می توانید آرایه قدیمی را با روش جدید جایگزین کنید:example1.items = example1.items.filter(function (item) {  return item.message.match(/Foo/)})ممکن است فکر کنید این امر باعث خواهد شد که DOM،  Vue موجود را دور بیندازد و مجدداً لیست را ارائه دهد - خوشبختانه ، اینگونه نیست. Vue برای به حداکثر رساندن استفاده مجدد از عناصر DOM برخی از اکتشافات هوشمند را پیاده سازی می کند ، بنابراین جایگزینی یک آرایه با آرایه دیگری که حاوی اشیاء همپوشانی است ، عملیاتی بسیار کارآمد است.هشداربه دلیل محدودیت های موجود در JavaScript ، Vue نمی تواند تغییرات زیر را در یک آرایه تشخیص دهد:زمانیکه یک آیتم را مستقیما با index جایگزاری می کنید ، به عنوان مثال vm.items [indexOfItem] = newValueزمانیکه طول آرایه را تغییر می دهید ، به عنوان مثال vm.items.length = newLengthبرای مثال:var vm = new Vue({  data: {    items: ['a', 'b', 'c']  }})vm.items[1] = 'x' // is NOT reactivevm.items.length = 2 // is NOT reactiveبرای غلبه بر بر هشدار 1 ، هر دو کد زیر کار مشابه با vm.items [indexOfItem] = newValue انجام می دهند ، اما باعث بروزرسانی وضعیت در سیستم واکنش پذیری خواهد شد :// Vue.setVue.set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue)همچنین می توانید از متد نمونه vm.$set  استفاده کنید که یک نام مستعار برای  Vue.set سراسری است:vm.$set(vm.items, indexOfItem, newValue)برای مقابله با هشدار 2 ، می توانید از splice استفاده کنید:vm.items.splice(newLength)Object Change Detection Caveatsمجددا به دلیل محدودیت های JavaScript مدرن ، Vue نمی تواند اضافه و یا حذف ویژگی (property)  را تشخیص دهد. مثلا:var vm = new Vue({  data: {    a: 1  }})// `vm.a` is now reactivevm.b = 2// `vm.b` is NOT reactiveVue اجازه نمی دهد به صورت پویا خصوصیات واکنشی سطح ریشه به یک نمونه ایجاد شده اضافه شود. با این وجود ، می توان با استفاده از روش Vue.set(object, propertyName, value)  ویژگیهای واکنشی را به یک شیء تو در تو اضافه کرد. به عنوان مثال ،var vm = new Vue({  data: {    userProfile: {      name: 'Anika'    }  }})می توانید یک ویژگی جدید سن age  را به شیء userProfile   تودرتو اضافه کنید با:Vue.set(vm.userProfile, 'age', 27)همچنین می توانید از متد نمونه vm.$set  استفاده کنید که یک نام مستعار برای Vue.set سراسری است:vm.$set(vm.userProfile, 'age', 27)بعضی اوقات ممکن است بخواهید تعدادی از ویژگی های جدید را به یک شی موجود اختصاص دهید ، به عنوان مثال با استفاده از ()Object.assign    یا ()extend._ . در چنین مواردی ، شما باید یک شیء تازه را با خصوصیات هر دو شی  ایجاد کنید. بنابراین به جای:Object.assign(vm.userProfile, {  age: 27,  favoriteColor: 'Vue Green'})شما می توانید خصوصیات واکنشی جدید را با:vm.userProfile = Object.assign({}, vm.userProfile, {  age: 27,  favoriteColor: 'Vue Green'})نمایش نتایج  Filtered/Sortedبعضی اوقات می خواهیم نسخه مرتب شده یا فیلتر شده از آرایه را نمایش دهیم بدون اینکه در واقع داده های اصلی را تغییر داده یا مجددا تنظیم کنیم. در این حالت ، می توانید یک ویژگی computed  ایجاد کنید که آرایه فیلتر شده یا مرتب شده را برمی گرداند.برای مثال:&#x3C;li v-for=&#x22;n in evenNumbers&#x22;&#x3E;&#123;&#123; n &#125;&#125;&#x3C;/li&#x3E;data: {  numbers: [ 1, 2, 3, 4, 5 ]},computed: {  evenNumbers: function () {    return this.numbers.filter(function (number) {      return number % 2 === 0    })  }}در شرایطی که ویژگی های computed امکان پذیر نیست (به عنوان مثال در داخل حلقه های تودردتو v-for ) ، می توانید از یک متد استفاده کنید:&#x3C;li v-for=&#x22;n in even(numbers)&#x22;&#x3E;&#123;&#123; n &#125;&#125;&#x3C;/li&#x3E;data: {  numbers: [ 1, 2, 3, 4, 5 ]},methods: {  even: function (numbers) {    return numbers.filter(function (number) {      return number % 2 === 0    })  }}v-for با یک رنجv-for همچنین می تواند یک عدد صحیح را دریافت نماید. در این حالت این قالب را بارها تکرار می کند.&#x3C;div&#x3E;  &#x3C;span v-for=&#x22;n in 10&#x22;&#x3E;&#123;&#123; n &#125;&#125; &#x3C;/span&#x3E;&#x3C;/div&#x3E;نتیجه:1 2 3 4 5 6 7 8 9 10 v-for با &#x3C;template&#x3E;شبیه به الگوی v-if ، می توانید از تگ &#x3C;template&#x3E; با v-for نیز استفاده کنید تا بتوانید از چندین عنصر از یک بلاک را رندر نمایید. مثلا:&#x3C;ul&#x3E;  &#x3C;template v-for=&#x22;item in items&#x22;&#x3E;    &#x3C;li&#x3E;&#123;&#123; item.msg &#125;&#125;&#x3C;/li&#x3E;    &#x3C;li class=&#x22;divider&#x22; role=&#x22;presentation&#x22;&#x3E;&#x3C;/li&#x3E;  &#x3C;/template&#x3E;&#x3C;/ul&#x3E;v-for با v-ifتوجه داشته باشید که توصیه نمی شود از v-if و v-for با هم استفاده کنید. برای جزئیات بیشتر به style guideمراجعه کنید.هنگامی که آنها در همان گره وجود دارند ، v-for دارای اولویت بالاتری نسبت به v-if است. این بدان معنی است که v-if در هر تکرار حلقه به طور جداگانه اجرا می شود. این می تواند زمانی مفید باشد که می خواهید گره ها را فقط برای برخی موارد ، مانند زیر ارائه دهید:&#x3C;li v-for=&#x22;todo in todos&#x22; v-if=&#x22;!todo.isComplete&#x22;&#x3E;  &#123;&#123; todo &#125;&#125;&#x3C;/li&#x3E;موارد فوق فقط todos هایی را که کامل نیستند رندر می شوند.اگر هدف شما از اجرای شرط حلقه بطور شرطی باشد ، می توانید v-if را روی یک عنصر بسته (یا &#x3C;template&#x3E;) قرار دهید. مثلا:&#x3C;ul v-if=&#x22;todos.length&#x22;&#x3E;  &#x3C;li v-for=&#x22;todo in todos&#x22;&#x3E;    &#123;&#123; todo &#125;&#125;  &#x3C;/li&#x3E;&#x3C;/ul&#x3E;&#x3C;p v-else&#x3E;No todos left!&#x3C;/p&#x3E;v-for با Componentشما می توانید به طور مستقیم مانند هر عنصر عادی از v-for در یک کامپوننت سفارشی استفاده کنید:&#x3C;my-component v-for=&#x22;item in items&#x22; :key=&#x22;item.id&#x22;&#x3E;&#x3C;/my-component&#x3E;در 2.2.0+ ، هنگام استفاده از v-for با یک کامپوننت ، یک key لازم است.با این وجود ، داده ها به طور خودکار به کامپوننت منتقل نمی شوند ، زیرا کامپوننت دارای محدوده های جدا شده از خود هستند. برای انتقال داده های تکرار شونده در کامپوننت ، باید از props  نیز استفاده کنیم:&#x3C;my-component  v-for=&#x22;(item, index) in items&#x22;  v-bind:item=&#x22;item&#x22;  v-bind:index=&#x22;index&#x22;  v-bind:key=&#x22;item.id&#x22;&#x3E;&#x3C;/my-component&#x3E;دلیل عدم تزریق خودکار item  به کامپوننت این است که باعث می شود این کامپوننت با نحوه کار v-for  پیوستگی محکمی  ایجاد کند. صریح بودن اطلاعات مربوط به اینکه از کجا تهیه می شود باعث می شود کامپوننت در موقعیت های دیگر قابل استفاده مجدد باشد.در اینجا یک مثال کامل از یک لیست ساده TODO آمده است:&#x3C;div id=&#x22;todo-list-example&#x22;&#x3E;  &#x3C;form v-on:submit.prevent=&#x22;addNewTodo&#x22;&#x3E;    &#x3C;label for=&#x22;new-todo&#x22;&#x3E;Add a todo&#x3C;/label&#x3E;    &#x3C;input      v-model=&#x22;newTodoText&#x22;      id=&#x22;new-todo&#x22;      placeholder=&#x22;E.g. Feed the cat&#x22;    &#x3E;    &#x3C;button&#x3E;Add&#x3C;/button&#x3E;  &#x3C;/form&#x3E;  &#x3C;ul&#x3E;    &#x3C;li      is=&#x22;todo-item&#x22;      v-for=&#x22;(todo, index) in todos&#x22;      v-bind:key=&#x22;todo.id&#x22;      v-bind:title=&#x22;todo.title&#x22;      v-on:remove=&#x22;todos.splice(index, 1)&#x22;    &#x3E;&#x3C;/li&#x3E;  &#x3C;/ul&#x3E;&#x3C;/div&#x3E;توجه داشته باشید که ویژگی is=\"todo-item\"  است. این در الگوهای DOM ضروری است ، زیرا فقط یک عنصر &#x3C;li&#x3E; درون یک &#x3C;ul&#x3E; معتبر است. این همان کار را با &#x3C;todo-item&#x3E; انجام می دهد ، اما در اطراف یک خطای تجزیه مرورگر بالقوه کار می کند. برای کسب اطلاعات بیشتر به الگوی  DOM Template Parsing Caveatsمراجعه کنید.Vue.component('todo-item', {  template: '\\    &#x3C;li&#x3E;\\      &#123;&#123; title &#125;&#125;\\      &#x3C;button v-on:click=&#x22;$emit(\\&#x27;remove\\&#x27;)&#x22;&#x3E;Remove&#x3C;/button&#x3E;\\    &#x3C;/li&#x3E;\\  ',  props: ['title']})new Vue({  el: '#todo-list-example',  data: {    newTodoText: '',    todos: [      {        id: 1,        title: 'Do the dishes',      },      {        id: 2,        title: 'Take out the trash',      },      {        id: 3,        title: 'Mow the lawn'      }    ],    nextTodoId: 4  },  methods: {    addNewTodo: function () {      this.todos.push({        id: this.nextTodoId++,        title: this.newTodoText      })      this.newTodoText = ''    }  }})",
            "url": "/documentation/vuejs/Essentials/List-Rendering"
          }
          ,
        
          "documentation-vuejs-essentials-event-handling" :{
            "title": "کار با رویدادها(Event Handling)",
            "content": "گوش دادن به وقایع (Listening to Events)ما می توانیم از دستورالعمل v-on برای گوش دادن به رویدادهای DOM استفاده کنیم و برخی از کدهای جاوا اسکریپت را در هنگام بروز آنها اجرا کنیم.برای مثال:&#x3C;div id=&#x22;example-1&#x22;&#x3E;  &#x3C;button v-on:click=&#x22;counter += 1&#x22;&#x3E;Add 1&#x3C;/button&#x3E;  &#x3C;p&#x3E;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&#x3C;/p&#x3E;&#x3C;/div&#x3E;var example1 = new Vue({  el: '#example-1',  data: {    counter: 0  }})نتیجه:Add 1  The button above has been clicked &#123;&#123; counter &#125;&#125; times.متدهای کار با رویدادها (Method Event Handlers)منطق برای بسیاری از اداره کنندگان رویدادها پیچیده تر خواهد شد ، بنابراین نگه داشتن کد JavaScript در مقدار  ویژگی v-on امکان پذیر نیست. به همین دلیل v-on می تواند نام متدی را که می خواهید  آن را فراخوانی نیز بپذیرد.برای مثال:&#x3C;div id=&#x22;example-2&#x22;&#x3E;  &#x3C;!-- &#x60;greet&#x60; is the name of a method defined below --&#x3E;  &#x3C;button v-on:click=&#x22;greet&#x22;&#x3E;Greet&#x3C;/button&#x3E;&#x3C;/div&#x3E;var example2 = new Vue({  el: '#example-2',  data: {    name: 'Vue.js'  },  // define methods under the `methods` object  methods: {    greet: function (event) {      // `this` inside methods points to the Vue instance      alert('Hello ' + this.name + '!')      // `event` is the native DOM event      if (event) {        alert(event.target.tagName)      }    }  }})// you can invoke methods in JavaScript tooexample2.greet() // =&gt; 'Hello Vue.js!'    Greetکار با متدهای درون خطی (Methods in Inline Handlers)به جای اتصال مستقیم به نام متد ، می توانیم از متدهایی در یک عبارت JavaScript به صورت خطی (inline)  نیز استفاده کنیم:&#x3C;div id=&#x22;example-3&#x22;&#x3E;  &#x3C;button v-on:click=&#x22;say(&#x27;hi&#x27;)&#x22;&#x3E;Say hi&#x3C;/button&#x3E;  &#x3C;button v-on:click=&#x22;say(&#x27;what&#x27;)&#x22;&#x3E;Say what&#x3C;/button&#x3E;&#x3C;/div&#x3E;new Vue({  el: '#example-3',  methods: {    say: function (message) {      alert(message)    }  }})نتیجه:  Say hi  Say whatبعضی اوقات ما نیاز داریم در یک کنترل کننده دستور داخلی  (inline statement handler)به رویداد اصلی DOM نیز دسترسی پیدا کنیم. می توانید با استفاده از متغیر ویژه $event آن رویداد را به متد منتقل کنید:&#x3C;button v-on:click=&#x22;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&#x22;&#x3E;  Submit&#x3C;/button&#x3E;// ...methods: {  warn: function (message, event) {    // now we have access to the native event    if (event) event.preventDefault()    alert(message)  }}  Submitاصلاح کننده رویداد (Event Modifiers)این یک نیاز بسیار متداول است که متدهای ()event.preventDefault   یا ()event.stopPropagation   را در مدیریت رویداد به کار بگیرید. اگرچه ما می توانیم این کار را به راحتی در داخل متدها انجام دهیم ، اما بهتر  است که متدها صرفاً در مورد منطق داده ها باشند نه اینکه بخواهند با جزئیات رویداد DOM سروکار داشته باشند.برای رفع این مشکل ،  Vue اصلاح کننده رویداد  (event modifiers ) را برای v-on فراهم می کند. به یاد بیاورید که event modifiers پسوندهایی با عنوان هستند که توسط یک نقطه مشخص می شوند..stop.prevent.capture.self.once.passive&#x3C;!-- the click event&#x27;s propagation will be stopped --&#x3E;&#x3C;a v-on:click.stop=&#x22;doThis&#x22;&#x3E;&#x3C;/a&#x3E;&#x3C;!-- the submit event will no longer reload the page --&#x3E;&#x3C;form v-on:submit.prevent=&#x22;onSubmit&#x22;&#x3E;&#x3C;/form&#x3E;&#x3C;!-- modifiers can be chained --&#x3E;&#x3C;a v-on:click.stop.prevent=&#x22;doThat&#x22;&#x3E;&#x3C;/a&#x3E;&#x3C;!-- just the modifier --&#x3E;&#x3C;form v-on:submit.prevent&#x3E;&#x3C;/form&#x3E;&#x3C;!-- use capture mode when adding the event listener --&#x3E;&#x3C;!-- i.e. an event targeting an inner element is handled here before being handled by that element --&#x3E;&#x3C;div v-on:click.capture=&#x22;doThis&#x22;&#x3E;...&#x3C;/div&#x3E;&#x3C;!-- only trigger handler if event.target is the element itself --&#x3E;&#x3C;!-- i.e. not from a child element --&#x3E;&#x3C;div v-on:click.self=&#x22;doThat&#x22;&#x3E;...&#x3C;/div&#x3E;هنگام استفاده از modifiers ، موارد مهم را مرتب کنید زیرا کد مربوطه به همان ترتیب تولید می شود. بنابراین استفاده از v-on:click.prevent.self  از کلیه کلیکها جلوگیری می کند در حالی که v-on:click.self.prevent   فقط از کلیک روی خود عنصر جلوگیری می کند.در نسخه New in 2.1.4+&#x3C;!-- the click event will be triggered at most once --&#x3E;&#x3C;a v-on:click.once=&#x22;doThis&#x22;&#x3E;&#x3C;/a&#x3E;بر خلاف اصلاح کننده های دیگر ، که منحصر به رویدادهای DOM بومی هستند ، از اصلاح کننده  once.  نیز می توانید در رویدادهای کامپوننت استفاده کنید.در نسخه New in 2.3.0+&#x3C;!-- the scroll event&#x27;s default behavior (scrolling) will happen --&#x3E;&#x3C;!-- immediately, instead of waiting for &#x60;onScroll&#x60; to complete  --&#x3E;&#x3C;!-- in case it contains &#x60;event.preventDefault()&#x60;                --&#x3E;&#x3C;div v-on:scroll.passive=&#x22;onScroll&#x22;&#x3E;...&#x3C;/div&#x3E;اصلاح کننده passive.  مخصوصاً برای بهبود عملکرد در دستگاه های تلفن همراه مفید است.از  passive.  و .prevent  با یکدیگر استفاده نکنید ، زیرا prevent.  نادیده گرفته می شود و مرورگر شما احتمالاً هشداری را به شما نشان می دهد. به یاد داشته باشید ، passive.  با مرورگر ارتباط برقرار می کند که نمی خواهید از عملکرد پیش فرض رویداد جلوگیری کند.کار با کیبورد  (Key Modifiers)هنگام گوش دادن به رویدادهای صفحه کلید ، اغلب باید کلیدهای خاص را بررسی کنیم. Vue اجازه می دهد تا هنگام گوش دادن به رویدادهای کلیدی ، اصلاح کننده های کیبورد (key modifiers) را برای v-on اضافه کنید:&#x3C;!-- only call &#x60;vm.submit()&#x60; when the &#x60;key&#x60; is &#x60;Enter&#x60; --&#x3E;&#x3C;input v-on:keyup.enter=&#x22;submit&#x22;&#x3E;می توانید مستقیماً از نامهای کلید معتبری که از طریق KeyboardEvent.key در معرض مدیریت هستند با تغییر نام آنها بصورت  kebab-case استفاده کنید.&#x3C;input v-on:keyup.page-down=&#x22;onPageDown&#x22;&#x3E;در مثال بالا، مدیریت کننده رویداد زمانی فراخوانی می شود که event.key$  برابر با 'PageDown' باشد.استفاده از   (Key Codes)استفاده از رویدادهای keyCode  ممکن است در مرورگرهای جدید پشتیبانی نشود.استفاده از ویژگی های keyCode نیز مجاز است:&#x3C;input v-on:keyup.13=&#x22;submit&#x22;&#x3E;Vue در صورت لزوم برای پشتیبانی از مرورگرها ، نامهای متداول را برای متداول ترین کدهای کلیدی فراهم می کند:.enter.tab.delete (captures both “Delete” and “Backspace” keys).esc.space.up.down.left.rightچند کلید (esc. و تمام کلیدهای جهت دار) در IE9 دارای مقادیر کلیدی متناقض هستند ، بنابراین در صورت نیاز به پشتیبانی از IE9 ، این مستعارهای داخلی ترجیح داده می شوند.همچنین می توانید نام مستعار اصلاح کننده کلید سفارشی   (define custom key modifier aliases) را از طریق شیء سراسری config.keyCodes تعریف کنید:// enable `v-on:keyup.f1`Vue.config.keyCodes.f1 = 112System Modifier Keysدر New in 2.1.0+ :شما می توانید از modifiers زیر جهت شنود رویدادهای موس یا کیبورد فقط زمانیکه کلید اصلاح کننده مربوطه فشرده شد استفاده نمایید:.ctrl.alt.shift.metaتوجه: در کیبوردهایMacintosh ، دکمه meta کلید (⌘) است. در کیبوردهای ویندوز ، دکمه meta کلید (⊞) است. در کیبوردSun Microsystems ، متا به عنوان یک الماس جامد (◆) مشخص شده است. در کیبوردهای خاص ، به طور خاص صفحه کلیدها و جانشینان دستگاههای MIT و Lisp ، مانند کیبورد نایت ، کیبوردcadet فضایی ، متا با عنوان \"META\" شناخته می شوند. در کیبوردهایSymbolics ، متا با \"META\" یا \"متا\" شناخته می شوند.برای مثال:&#x3C;!-- Alt + C --&#x3E;&#x3C;input @keyup.alt.67=&#x22;clear&#x22;&#x3E;&#x3C;!-- Ctrl + Click --&#x3E;&#x3C;div @click.ctrl=&#x22;doSomething&#x22;&#x3E;Do something&#x3C;/div&#x3E;توجه داشته باشید که کلیدهای اصلاح کننده با کلیدهای معمولی متفاوت هستند و در هنگام استفاده از وقایع Keyup ، هنگام انتشار رویداد باید فشرده شوند. به عبارت دیگر ، keyup.ctrl تنها در صورت رها کردن کلید در حالی که ctrl را رها می کنید ، شروع می شود. اگر کلید ctrl را به تنهایی آزاد کنید ، رویدادی ایجاد نمی شود. اگر چنین رفتاری را می خواهید ، به جای آن از کلید keycode برای ctrl استفاده کنید: keyup.17..exact Modifierدر نسخه New in 2.5.0+ :اصلاح کننده exact.  اجازه می دهد تا کنترل ترکیب دقیق اصلاح کننده های سیستم مورد نیاز برای ایجاد یک رویداد را کنترل کنید.&#x3C;!-- this will fire even if Alt or Shift is also pressed --&#x3E;&#x3C;button @click.ctrl=&#x22;onClick&#x22;&#x3E;A&#x3C;/button&#x3E;&#x3C;!-- this will only fire when Ctrl and no other keys are pressed --&#x3E;&#x3C;button @click.ctrl.exact=&#x22;onCtrlClick&#x22;&#x3E;A&#x3C;/button&#x3E;&#x3C;!-- this will only fire when no system modifiers are pressed --&#x3E;&#x3C;button @click.exact=&#x22;onClick&#x22;&#x3E;A&#x3C;/button&#x3E;Mouse Button Modifiersدر نسخه New in 2.2.0+ :.left.right.middleاین اصلاح کننده ها کنترل کننده ها را محدود به حوادثی می کنند که توسط یک دکمه ماوس خاص ایجاد می شوند.چرا از شنودندگان در HTML استفاده می کنیم؟ممکن است شما نگران باشید که تمام این رویکرد گوش دادن به رویداد ، قوانین قدیمی خوب درباره \"جدایی نگرانی ها - separation of concerns \" را نقض می کند. مطمئن باشید - از آنجا که تمام عملکردها و اصطلاحات انتقال دهنده Vue کاملاً محدود به ViewModel هستند که نمای فعلی را کنترل می کند ، هیچ مشکلی برای نگهداری نخواهد داشت. در حقیقت ، استفاده از v-on فواید زیادی دارد:پیاده سازی تابع کنترل کننده بهمراه کد JS شما با استفاده از قالب html ساده تر است.از آنجا که لازم نیست شنوندگان رویداد را به صورت دستی در JS وصل کنید ، کد ViewModel شما می تواند منطقی ناب و عاری از DOM باشد. این باعث می شود آزمایش آسان تر شود.هنگامی که یک ViewModel از بین می رود ، تمام شنوندگان رویداد به طور خودکار حذف می شوند. نیازی به نگرانی در مورد پاک کردن توسط خودتان  نیست.",
            "url": "/documentation/vuejs/Essentials/Event-Handling"
          }
          ,
        
          "documentation-vuejs-essentials-form-input-bindings" :{
            "title": "اتصال داده به ورودی فرم (Form Input Bindings)",
            "content": "  اتصال داده به ورودی فرم (Form Input Bindings)شما می توانید از دایرکتیوv-model برای ایجاد اتصالات داده دو طرفه در ورودی فرم ، textarea و عناصر انتخاب استفاده کنید. این به طور خودکار روش صحیح برای به روز رسانی عنصر را بر اساس نوع ورودی انتخاب می کند. v-model مقدار اولیه ، صفات بررسی شده یا منتخب موجود در هر عنصر فرم را نادیده نمی گیرد. همیشه با داده های نمونه Vue به عنوان منبع درست رفتار خواهد کرد. شما باید مقدار اولیه را در قسمت JavaScript ، در داخل گزینه data (کامپوننت) خود اعلام کنید.v-model در داخل از خواص مختلفی استفاده می کند و رویدادهای مختلفی را برای عناصر ورودی مختلف منتشر می کند:text   و عناصر textarea از ویژگی value  و رویداد ورودی استفاده می کنند.checkboxes  و radiobuttons  از ویژگیهای checked  استفاده کرده و رویداد را تغییر می دهند.فیلدهای انتخابی  value  را به عنوان پایه استفاده کرده و به عنوان یک رویداد تغییر می دهند.Text&#x3C;input v-model=&#x22;message&#x22; placeholder=&#x22;edit me&#x22;&#x3E;&#x3C;p&#x3E;Message is: &#123;&#123; message &#125;&#125;&#x3C;/p&#x3E;var vm = new Vue({        el: 'app',        data:{            message: ''        }    })Message is: &#123;&#123; message &#125;&#125;Multiline text&#x3C;span&#x3E;Multiline message is:&#x3C;/span&#x3E;&#x3C;p style=&#x22;white-space: pre-line;&#x22;&#x3E;&#123;&#123; message &#125;&#125;&#x3C;/p&#x3E;&#x3C;br&#x3E;&#x3C;textarea v-model=&#x22;message&#x22; placeholder=&#x22;add multiple lines&#x22;&#x3E;&#x3C;/textarea&#x3E;Multiline message is:&#123;&#123; message &#125;&#125;درج در textareas بصورت (&#x3C;textarea&#x3E;&#123;&#123;text&#125;&#125;&#x3C;/textarea&#x3E;) کار نمی کند. از v-model  استفاده نمایید.CheckboxCheckbox تکی، مقدار boolean   :&#x3C;input type=&#x22;checkbox&#x22; id=&#x22;checkbox&#x22; v-model=&#x22;checked&#x22;&#x3E;&#x3C;label for=&#x22;checkbox&#x22;&#x3E;&#123;&#123; checked &#125;&#125;&#x3C;/label&#x3E;&#123;&#123; checked &#125;&#125;checkboxes چک چندگانه ، محدود به همان آرایه:&#x3C;div id=&#x27;example-3&#x27;&#x3E;  &#x3C;input type=&#x22;checkbox&#x22; id=&#x22;jack&#x22; value=&#x22;Jack&#x22; v-model=&#x22;checkedNames&#x22;&#x3E;  &#x3C;label for=&#x22;jack&#x22;&#x3E;Jack&#x3C;/label&#x3E;  &#x3C;input type=&#x22;checkbox&#x22; id=&#x22;john&#x22; value=&#x22;John&#x22; v-model=&#x22;checkedNames&#x22;&#x3E;  &#x3C;label for=&#x22;john&#x22;&#x3E;John&#x3C;/label&#x3E;  &#x3C;input type=&#x22;checkbox&#x22; id=&#x22;mike&#x22; value=&#x22;Mike&#x22; v-model=&#x22;checkedNames&#x22;&#x3E;  &#x3C;label for=&#x22;mike&#x22;&#x3E;Mike&#x3C;/label&#x3E;  &#x3C;br&#x3E;  &#x3C;span&#x3E;Checked names: &#123;&#123; checkedNames &#125;&#125;&#x3C;/span&#x3E;&#x3C;/div&#x3E;new Vue({  el: '#example-3',  data: {    checkedNames: []  }})        Jack        John        Mike        Checked names: &#123;&#123; checkedNames &#125;&#125;Radio&#x3C;input type=&#x22;radio&#x22; id=&#x22;one&#x22; value=&#x22;One&#x22; v-model=&#x22;picked&#x22;&#x3E;&#x3C;label for=&#x22;one&#x22;&#x3E;One&#x3C;/label&#x3E;&#x3C;br&#x3E;&#x3C;input type=&#x22;radio&#x22; id=&#x22;two&#x22; value=&#x22;Two&#x22; v-model=&#x22;picked&#x22;&#x3E;&#x3C;label for=&#x22;two&#x22;&#x3E;Two&#x3C;/label&#x3E;&#x3C;br&#x3E;&#x3C;span&#x3E;Picked: &#123;&#123; picked &#125;&#125;&#x3C;/span&#x3E;OneTwoPicked: &#123;&#123; picked &#125;&#125;Selectانتخاب تکی:&#x3C;select v-model=&#x22;selected&#x22;&#x3E;  &#x3C;option disabled value=&#x22;&#x22;&#x3E;Please select one&#x3C;/option&#x3E;  &#x3C;option&#x3E;A&#x3C;/option&#x3E;  &#x3C;option&#x3E;B&#x3C;/option&#x3E;  &#x3C;option&#x3E;C&#x3C;/option&#x3E;&#x3C;/select&#x3E;&#x3C;span&#x3E;Selected: &#123;&#123; selected &#125;&#125;&#x3C;/span&#x3E;new Vue({  el: '...',  data: {    selected: ''  }})  Please select one  A  B  CSelected: &#123;&#123; selected &#125;&#125;اگر مقدار اولیه  از v-model  شما با هیچ یک از گزینه ها مطابقت نداشته باشد ، عنصر &#x3C;select&#x3E; در حالت \"انتخاب نشده\" ارائه می شود. در iOS این باعث می شود کاربر نتواند اولین مورد را انتخاب کند. بنابراین توصیه می شود همانطور که در مثال بالا نشان داده شده است گزینه غیرفعال با مقدار خالی تهیه کنید.انتخاب چندگانه:&#x3C;select v-model=&#x22;selected&#x22; multiple&#x3E;  &#x3C;option&#x3E;A&#x3C;/option&#x3E;  &#x3C;option&#x3E;B&#x3C;/option&#x3E;  &#x3C;option&#x3E;C&#x3C;/option&#x3E;&#x3C;/select&#x3E;&#x3C;br&#x3E;&#x3C;span&#x3E;Selected: &#123;&#123; selected &#125;&#125;&#x3C;/span&#x3E;            A        B        C        Selected: &#123;&#123; selected &#125;&#125;گزینه های پویا ارائه شده با v-for:&#x3C;select v-model=&#x22;selected&#x22;&#x3E;  &#x3C;option v-for=&#x22;option in options&#x22; v-bind:value=&#x22;option.value&#x22;&#x3E;    &#123;&#123; option.text &#125;&#125;  &#x3C;/option&#x3E;&#x3C;/select&#x3E;&#x3C;span&#x3E;Selected: &#123;&#123; selected &#125;&#125;&#x3C;/span&#x3E;new Vue({  el: '...',  data: {    selected: 'A',    options: [      { text: 'One', value: 'A' },      { text: 'Two', value: 'B' },      { text: 'Three', value: 'C' }    ]  }})                        &#123;&#123; option.text &#125;&#125;                Selected: &#123;&#123; selected &#125;&#125; اتصال مقدار (Value Bindings)برای radio, checkbox and select options ، مقادیر اتصال v-model  معمولاً رشته های استاتیک (یا booleans برای checkbox) است:&#x3C;!-- &#x60;picked&#x60; is a string &#x22;a&#x22; when checked --&#x3E;&#x3C;input type=&#x22;radio&#x22; v-model=&#x22;picked&#x22; value=&#x22;a&#x22;&#x3E;&#x3C;!-- &#x60;toggle&#x60; is either true or false --&#x3E;&#x3C;input type=&#x22;checkbox&#x22; v-model=&#x22;toggle&#x22;&#x3E;&#x3C;!-- &#x60;selected&#x60; is a string &#x22;abc&#x22; when the first option is selected --&#x3E;&#x3C;select v-model=&#x22;selected&#x22;&#x3E;  &#x3C;option value=&#x22;abc&#x22;&#x3E;ABC&#x3C;/option&#x3E;&#x3C;/select&#x3E;اما گاهی اوقات ممکن است بخواهیم مقدار را به عنوان یک ویژگی پویا در نمونه Vue پیوند دهیم. برای دستیابی به آن می توانیم از v-bind استفاده کنیم. علاوه بر این ، استفاده از v-bind به ما امکان می دهد مقدار ورودی را به مقادیر غیر رشته وصل کنیم.Checkbox&#x3C;input  type=&#x22;checkbox&#x22;  v-model=&#x22;toggle&#x22;  true-value=&#x22;yes&#x22;  false-value=&#x22;no&#x22;&#x3E;// when checked:vm.toggle === 'yes'// when unchecked:vm.toggle === 'no'ویژگی های true-value   و false-value   روی ویژگی value  ورودی تأثیر نمی گذارند ، زیرا مرورگرها چک باکس های چک نشده  را ارسال نمی کنند. Radio&#x3C;input type=&#x22;radio&#x22; v-model=&#x22;pick&#x22; v-bind:value=&#x22;a&#x22;&#x3E;// when checked:vm.pick === vm.aSelect Options&#x3C;select v-model=&#x22;selected&#x22;&#x3E;  &#x3C;!-- inline object literal --&#x3E;  &#x3C;option v-bind:value=&#x22;{ number: 123 }&#x22;&#x3E;123&#x3C;/option&#x3E;&#x3C;/select&#x3E;// when selected:typeof vm.selected // =&gt; 'object'vm.selected.number // =&gt; 123اصلاح کننده ها (Modifiers).lazyبه طور پیش فرض ، مدل v-model  بعد از هر رویداد ورودی ، ورودی را با داده ها همگام می کند (به استثنای ترکیب IME همانطور که گفته شد).می توانید از رویداد lazy به جای sync  بعد از رویداد change  استفاده نمایید :&#x3C;!-- synced after &#x22;change&#x22; instead of &#x22;input&#x22; --&#x3E;&#x3C;input v-model.lazy=&#x22;msg&#x22; &#x3E;.numberاگر می خواهید ورودی کاربر به صورت خودکار بصورت عددی تایپ شود ، می توانید اصلاح کننده شماره را به ورودی های مدیریت شده v-model  خود اضافه کنید:&#x3C;input v-model.number=&#x22;age&#x22; type=&#x22;number&#x22;&#x3E;این اغلب مفید است ، زیرا حتی با type=\"number\" مقدار عناصر ورودی HTML همیشه یک رشته را برمی گرداند. اگر مقدار با ()parseFloat تجزیه نشود ، مقدار اصلی برمی گردد..trimاگر می خواهید کاراکتر فضای خالی از ورودی کاربر به صورت خودکار حذف شود ، می توانید اصلاح کننده trim  را به ورودی های با مدیریت v-model خود اضافه کنید:&#x3C;input v-model.trim=&#x22;msg&#x22;&#x3E;",
            "url": "/documentation/vuejs/Essentials/Form-Input-Bindings"
          }
          ,
        
          "documentation-vuejs-essentials-components-basics" :{
            "title": "اصول پایه Component",
            "content": "  مثال پایه (Base Example)در این قسمت یک مثال از یک کامپوننت را مشاهده می کنید:// Define a new component called button-counterVue.component(&#x27;button-counter&#x27;, {  data: function () {    return {      count: 0    }  },  template: &#x27;&#x3C;button v-on:click=&#x22;count++&#x22;&#x3E;You clicked met &#123;&#123; count &#125;&#125; times.&#x3C;/button&#x3E;&#x27;})کامپوننت ها با نام خود قابلیت استفاده مجدد در نمونه های vue را دارند. در این مثال &#x3C;button-counter&#x3E; .می توانیم از این کامپوننت به عنوان یک عنصر سفارشی در نمونه ایجاد شده Vue استفاده کنیم :&#x3C;div id=&#x22;components-demo&#x22;&#x3E;  &#x3C;button-counter&#x3E;&#x3C;/button-counter&#x3E;&#x3C;/div&#x3E;new Vue({ el: '#components-demo' })   از آنجا که کامپوننت ها قابلیت استفاده مجدد در نمونه های Vue را دارا می باشند، آنها تعدادی خاصیت را در یک new Vue همانند data, computed, watch, methods و lifecycle hooks را می پذیرند.  استقاده مجدد از کامپوننت ها (Reusing Components)کامپوننت ها را می توانید هربار که بخواهید استفاده نمایید :&#x3C;div id=&#x22;components-demo&#x22;&#x3E;  &#x3C;button-counter&#x3E;&#x3C;/button-counter&#x3E;  &#x3C;button-counter&#x3E;&#x3C;/button-counter&#x3E;  &#x3C;button-counter&#x3E;&#x3C;/button-counter&#x3E;&#x3C;/div&#x3E;         توجه کنید که با کلیک بر روی دکمه ها ، هر یک مقدار جداگانه خود را حفظ می کنند. به این دلیل است که هر بار که از یک کامپوننت استفاده می کنید ، نمونه جدیدی از آن ایجاد می شود.  خاصیت data باید بصورت تابع پیاده سازی شود (data Must Be a Function)وقتی ما عنصر  &#x3C;button-counter&#x3E; را تعریف کردیم ، ممکن است متوجه شده باشید که داده ها به طور مستقیم یک شی را ارائه نمی دهند ، مانند این:data: {  count: 0}در عوض ، خاصیت data یک کامپوننت باید یک تابع باشد ، به طوری که هر نمونه می تواند یک نسخه مستقل از شی داده داده شده را حفظ کند:data: function () {  return {    count: 0  }}اگر Vue این قانون را نداشت ، کلیک کردن بر روی یک دکمه می توانست بر داده های سایر موارد دیگر  تأثیر بگذارد.  سازماندهی کامپوننت ها (Organizing Components)معمولا برنامه ها به صورت قطعات و اجزای تو در تو و درختی پیاده سازی می شوند :به عنوان مثال ، شما ممکن است کامپوننت هایی  برای header ،  sidebar و همچنین نمایش محتوا داشته باشید که معمولاً خود شامل اجزای دیگری همانند لینک ها، پست های وبلاگ و غیره است.جهت استفاده از کامپوننت ها در قالب ها ، آنها باید ابتدا ثبت شوند تا Vue از وجود آنها آگاه شود. دو نوع روش ثبت کامپوننت وجود دارد: سراسری و محلی. تاکنون توانستیم با استفاده از Vue.component  کامپوننت هایی را بصورت سراسری ایجاد کنیم :Vue.component('my-component-name', {  // ... options ...})کامپوننت هایی که بصورت سراسری ایجاد می شوند، می توانند در قالب نمونه های اصلی (new Vue) ایجاد شده و حتی در داخل همه subcomponents مورد استفاده قرار گیرند.  انتقال داده به کامپوننت ها با استفاده از Props(Passing Data to Child Components with Props)در ابتدا ، ما به ایجاد یک کامپوننت  برای نمایش  پست های وبلاگ اشاره کردیم. جهت انتقال داده هایی همانند عنوان و محتوای پست به کامپوننت، می توانیم از Props استفاده نماییم. Props ویژگی های سفارشی هستند که می توانید روی یک کامپوننت ثبت نمایید.Vue.component(&#x27;blog-post&#x27;, {  props: [&#x27;title&#x27;],  template: &#x27;&#x3C;h3&#x3E;&#123;&#123; title &#125;&#125;&#x3C;/h3&#x3E;&#x27;})یک کامپوننت می تواند دارای تعداد زیادی props باشد و مقادیر می توانند به props انتقال یابند.  در قالب بالا ، خواهید دید که ما می توانیم دقیقاً به این مقادیر همانند data دسترسی داشته باشیم.پس از ثبت props ، می توانید داده ها را به عنوان یک ویژگی سفارشی همانند زیر منتقل کنید:&#x3C;blog-post title=&#x22;My journey with Vue&#x22;&#x3E;&#x3C;/blog-post&#x3E;&#x3C;blog-post title=&#x22;Blogging with Vue&#x22;&#x3E;&#x3C;/blog-post&#x3E;&#x3C;blog-post title=&#x22;Why Vue is so fun&#x22;&#x3E;&#x3C;/blog-post&#x3E;همچنین چنانچه مجموعه داده هایی بدین صورت داشته باشیم:new Vue({  el: '#blog-post-demo',  data: {    posts: [      { id: 1, title: 'My journey with Vue' },      { id: 2, title: 'Blogging with Vue' },      { id: 3, title: 'Why Vue is so fun' }    ]  }})سپس جهت رند کامپوننت برای هر یک از آنها بدین صورت پیاده سازی می کنیم:&#x3C;blog-post  v-for=&#x22;post in posts&#x22;  v-bind:key=&#x22;post.id&#x22;  v-bind:title=&#x22;post.title&#x22;&#x3E;&#x3C;/blog-post&#x3E;   در مثال بالا مشاهده کردید که می توانیم از v-bind  جهت انتقال مقادیر بصورت داینامیک استفاده کنیم. این امر به ویژه هنگامی مفید است که شما محتوای دقیقی که می خواهید ارائه دهید را نمی دانید ، مانند هنگام ارسال پیامک از یک API.  بررسی  قالب های چند خطی و المان ریشه  (A Single Root Element)هنگام ساخت کامپوننت  &#x3C;blog-post&#x3E; در مثال قبل،  قالب شما حاوی مواردی غیر از عنوان همانند محتوا ، تاریخ ایجاد پست و ... می باشد : &#x3C;h3&#x3E;&#123;&#123; title &#125;&#125;&#x3C;/h3&#x3E;&#x3C;div v-html=&#x22;content&#x22;&#x3E;&#x3C;/div&#x3E;اگر این مورد را در الگوی خود امتحان کنید ، Vue خطایی با  متن  هر مؤلفه باید یک عنصر ریشه واحد داشته باشد را نمایش خواهد داد. می توانید با قرار دادن قالب خود در یک المان والد  مشکل را رفع نمایید :&#x3C;div class=&#x22;blog-post&#x22;&#x3E;  &#x3C;h3&#x3E;&#123;&#123; title &#125;&#125;&#x3C;/h3&#x3E;  &#x3C;div v-html=&#x22;content&#x22;&#x3E;&#x3C;/div&#x3E;&#x3C;/div&#x3E;با بزرگ شدن کامپوننت ، به احتمال زیاد به غیر از عنوان و محتوای یک پست به نمایش عناصر دیگری همچون تاریخ انتشار ، نظرات و ..  نیز احتیاج خواهیم داشت. تعریف prop برای هر قطعه از اطلاعات مرتبط می تواند بسیار آزار دهنده باشد:&#x3C;blog-post  v-for=&#x22;post in posts&#x22;  v-bind:key=&#x22;post.id&#x22;  v-bind:title=&#x22;post.title&#x22;  v-bind:content=&#x22;post.content&#x22;  v-bind:publishedAt=&#x22;post.publishedAt&#x22;  v-bind:comments=&#x22;post.comments&#x22;&#x3E;&#x3C;/blog-post&#x3E;بنابراین می توانیم کامپوننت بالا را مجددا  دوباره سازی کرده تا تنها نیاز به تعریف یک prop داشته باشیم : &#x3C;blog-post  v-for=&#x22;post in posts&#x22;  v-bind:key=&#x22;post.id&#x22;  v-bind:post=&#x22;post&#x22;&#x3E;&#x3C;/blog-post&#x3E;Vue.component(&#x27;blog-post&#x27;, {  props: [&#x27;post&#x27;],  template: &#x60;    &#x3C;div class=&#x22;blog-post&#x22;&#x3E;      &#x3C;h3&#x3E;&#123;&#123; post.title &#125;&#125;&#x3C;/h3&#x3E;      &#x3C;div v-html=&#x22;post.content&#x22;&#x3E;&#x3C;/div&#x3E;    &#x3C;/div&#x3E;  &#x60;})مثال فوق و برخی مثال ها در آینده از template literal جاوا اسکریپت جهت خواندن قالب های چند خطی استفاده می نمایند که  توسط Internet Explorer (IE) پشتیبانی نمی شوند ، چنانچه بخواهیم در IE پشتیبانی شود از  newline escapes استفاده نمایید.  اجرای رویدادهای کامپوننت های فرزند  (Listening to Child Components Events)هنگامی که کامپوننت &#x3C;blog-post&#x3E; را توسعه می دهیم ، برخی از ویژگیها ممکن است نیاز به برقراری ارتباط با والدین داشته باشند. به عنوان مثال ، ممکن است تصمیم بگیریم قابلیت بزرگتر کردن متن پست های وبلاگ را اضافه نماییم : می توانیم با اضافه کردن خاصیت   postFontSize به data در والد،  این عمل را انجام نماییم :new Vue({  el: &#x27;#blog-posts-events-demo&#x27;,  data: {    posts: [/* ... */],    postFontSize: 1  }})&#x3C;div id=&#x22;blog-posts-events-demo&#x22;&#x3E;  &#x3C;div :style=&#x22;{ fontSize: postFontSize + &#x27;em&#x27; }&#x22;&#x3E;    &#x3C;blog-post      v-for=&#x22;post in posts&#x22;      v-bind:key=&#x22;post.id&#x22;      v-bind:post=&#x22;post&#x22;    &#x3E;&#x3C;/blog-post&#x3E;  &#x3C;/div&#x3E;&#x3C;/div&#x3E;اکنون بیایید یک دکمه برای بزرگنمایی متن درست قبل از محتوای هر پست اضافه کنیم:Vue.component(&#x27;blog-post&#x27;, {  props: [&#x27;post&#x27;],  template: &#x60;    &#x3C;div class=&#x22;blog-post&#x22;&#x3E;      &#x3C;h3&#x3E;&#123;&#123; post.title &#125;&#125;&#x3C;/h3&#x3E;      &#x3C;button&#x3E;        Enlarge text      &#x3C;/button&#x3E;      &#x3C;div v-html=&#x22;post.content&#x22;&#x3E;&#x3C;/div&#x3E;    &#x3C;/div&#x3E;  &#x60;})مشکل این است که این دکمه کاری نمی کند:&#x3C;button&#x3E;  Enlarge text&#x3C;/button&#x3E;زمانیکه روی دکمه کلیک می کنیم ، باید به والدین ارتباط برقرار کرده تا متن تمام پست ها را بزرگتر کند. خوشبختانه ، نمونه های Vue سیستم رویدادهای سفارشی را برای حل این مشکل ارائه می دهند. کامپوننت والد می تواند با استفاده از دایرکتیو v-on انتخاب نماید که در بین رویدادها در نمونه کامپوننت فرزند به کدامیک گوش دهد. دقیقاً همانطور که با یک رویداد محلی DOM انجام می دهیم:&#x3C;blog-post  ...  v-on:enlarge-text=&#x22;postFontSize += 0.1&#x22;&#x3E;&#x3C;/blog-post&#x3E;سپس کامپوننت فرزند می تواند با فرخوانی متد emit$، نام رویداد را منتقل می کند:&#x3C;button v-on:click=&#x22;$emit(&#x27;enlarge-text&#x27;)&#x22;&#x3E;  Enlarge text&#x3C;/button&#x3E;کامپوننت والد با استفاده از v-on :large-text = \"postFontSize + = 0.1\" این رویداد را دریافت کرده و مقدار postFontSize را به روز می کنند.    &lt;div :style=\"{ fontSize:postFontSize+'em' }\"&gt;        &lt;/div&gt;  انتشار یک مقدار با رویداد  (Emitting a Value With an Event)انتشار مقادیر خاص با یک رویداد گاهی اوقات مفید است. به عنوان مثال ، ممکن است بخواهیم کامپوننت &#x3C;blog-post&#x3E; مسئولیت این را داشته باشد که متن را تا چه اندازه بزرگنمایی کند. در این موارد ، ما می توانیم از دومین پارامتر متد  emit$  استفاده نماییم:&#x3C;button v-on:click=&#x22;$emit(&#x27;enlarge-text&#x27;, 0.1)&#x22;&#x3E;  Enlarge text&#x3C;/button&#x3E;زمانیکه  ما به رویداد در والد گوش فرا می دهیم ، می توانیم به مقدار رویداد با استفاده از event$ دسترسی داشته باشیم :&#x3C;blog-post  ...  v-on:enlarge-text=&#x22;postFontSize += $event&#x22;&#x3E;&#x3C;/blog-post&#x3E;یا اگر کنترل کننده رویداد یک متد باشد:&#x3C;blog-post  ...  v-on:enlarge-text=&#x22;onEnlargeText&#x22;&#x3E;&#x3C;/blog-post&#x3E;سپس مقدار به اولین پارامتر متد انتقال می یابد:new Vue({        el: '#blog-posts-events-demo',        data: {            posts: [/* ... */],            postFontSize : 1        },        methods: {            onEnlargeText: function (enlargeAmount) {                this.postFontSize += enlargeAmount            }        }    }) استفاده از v-model   (Using v-model on Components)رویدادهای سفارشی همچنین می توانند در ایجاد ورودی های سفارشی که با v-model کار می کنند استفاده شوند. به خاطر دارید که :&#x3C;input v-model=&#x22;searchText&#x22;&#x3E;همان کاری را انجام می دهد که:&#x3C;input  v-bind:value=&#x22;searchText&#x22;  v-on:input=&#x22;searchText = $event.target.value&#x22;&#x3E;در صورت استفاده از v-model در کامپوننت چنین عمل می کند :&#x3C;custom-input  v-bind:value=&#x22;searchText&#x22;  v-on:input=&#x22;searchText = $event&#x22;&#x3E;&#x3C;/custom-input&#x3E;جهت اجرای کار input باید چنین عمل کند :مقید کردن مقدار خاصیت به مقدار propدر ورودی ، رویداد ورودی سفارشی خود را با مقدار جدید منتشر کنیددر عمل چنین خواهیم داشت :Vue.component(&#x27;custom-input&#x27;, {  props: [&#x27;value&#x27;],  template: &#x60;    &#x3C;input      v-bind:value=&#x22;value&#x22;      v-on:input=&#x22;$emit(&#x27;input&#x27;, $event.target.value)&#x22;    &#x3E;  &#x60;})اکنون v-model باید با این کامپوننت کاملاً کار کند:&#x3C;custom-input v-model=&#x22;searchText&#x22;&#x3E;&#x3C;/custom-input&#x3E; انتشار محتوا با Slots (Content Distribution with Slots)درست همانند عناصر HTML ، بسیار مفید است که بتوانید محتوای را به یک کامپوننت منتقل کنید ، مانند زیر:&#x3C;alert-box&#x3E;  Something bad happened.&#x3C;/alert-box&#x3E;که ممکن است چیزی مانند زیر باشد:خوشبختانه ، این کار توسط عنصر &#x3C;slot&#x3E; سفارشی Vue انجام شده است:Vue.component(&#x27;alert-box&#x27;, {  template: &#x60;    &#x3C;div class=&#x22;demo-alert-box&#x22;&#x3E;      &#x3C;strong&#x3E;Error!&#x3C;/strong&#x3E;      &#x3C;slot&#x3E;&#x3C;/slot&#x3E;    &#x3C;/div&#x3E;  &#x60;})همانطور که در بالا مشاهده  میکنید ، ما فقط slot را جایی که می خواهیم آن را استفاده کنیم قرار می دهیم و تمام !            Something bad happened.     نکاتی در عملیات تجزیه قالب  (DOM Template Parsing Caveats)برخی از عناصر HTML مانند &#x3C;ul&#x3E; &#x60C; &#x3C;ol&#x3E; &#x60C; &#x3C;table&#x3E; &#x648; &#x3C;select&#x3E; محدودیت هایی در مورد عناصر موجود در داخل آنها دارند و برخی از عناصر مانند &#x3C;li&#x3E; &#x60C; &#x3C;tr&#x3E; و &#x3C;option&#x3E; فقط می توانند در داخل بعضی از عناصر دیگر ظاهر شوندد.این مسئله هنگام استفاده از کامپوننت هایی با چنین عناصری محدودیت هایی به دنبال خواهد داشت. مثلا:&#x3C;table&#x3E;  &#x3C;blog-post-row&#x3E;&#x3C;/blog-post-row&#x3E;&#x3C;/table&#x3E;کامپوننت سفارشی &#x3C;blog-post-row&#x3E; به عنوان محتوای نامعتبر حذف می شود و باعث ایجاد خطا در خروجی نهایی ارائه شده می شود. خوشبختانه ،  ویژگی ویژه is یک راه حل ارائه می دهد:&#x3C;table&#x3E;  &#x3C;tr is=&#x22;blog-post-row&#x22;&#x3E;&#x3C;/tr&#x3E;&#x3C;/table&#x3E;لازم به ذکر است در صورت استفاده از قالب های رشته از یکی از منابع زیر این محدودیت اعمال نمی شود:String templates (e.g. template: '...')Single-file (.vue) components&#x3C;script type=&#x22;text/x-template&#x22;&#x3E;",
            "url": "/documentation/vuejs/Essentials/Components-Basics"
          }
          ,
        
          "documentation-vuejs-components-in-depth-component-registration" :{
            "title": "ثبت Component",
            "content": "نامگداری Componentجهت ثبت یک کامپوننت نامی به آن اختصاص داده می شود:Vue.component('my-component-name', { /* ... */ })نام کامپوننت اولین آرگومان Vue.component می باشد.نامی که شما به یک component می دهید بستگی به مکانی دارد که قصد استفاده از آن را دارید. هنگام استفاده از یک component به طور مستقیم در DOM (بر خلاف یک template رشته ای یا component تک فایلی) ، ما به شدت توصیه می کنیم از قوانین W3C برای نام های تگ های سفارشی پیروی کنید (همه حروف کوچک و باید دارای خط ربط باشد). این به شما کمک می کند تا از تعارض با عناصر HTML فعلی و آینده جلوگیری کنید.همچنین می توانید پیشنهادات نامگداری را در بخش Style Guide مشاهده نمایید.سبک نامگذاری (Name Casing)شما دو انتخاب جهت سبک نامگذاری در اختیار دارید :روش kebab-caseVue.component('my-component-name', { /* ... */ })هنگام تعریف یک Component به سبک kebab ، جهت دسترسی به عنصر سفارشی آن ، همانند &#x3C;my-component-name&#x3E;  ، عمل می کنیم:روش PascalCaseVue.component('MyComponentName', { /* ... */ })هنگام نامگداری یک Component به سبک PascalCase ، می توانید هنگام مراجعه به عنصرسفارشی آن ، از هر دو سبک استفاده کنید. این بدان معنی است که هر دو &#x3C;my-component-name&#x3E; و &#x3C;MyComponentName&#x3E; قابل قبول هستند. با این حال توجه داشته باشید که فقط نامهای به سبک kebab به طور مستقیم در DOM معتبر هستند (به عنوان مثال templates غیر رشته ای). ثبت سراسری (Global Registration)تاکنون ما فقط با استفاده از Vue.component کامپوننت هایی  ایجاد کرده ایم:Vue.component('my-component-name', {  // ... options ...})این  کامپوننت ها به صورت سراسری ثبت شده اند. این بدان معنی است که آنها می توانند در قالب نمونه های اصلی Vue (Vue new) ایجاد شده پس از ثبت  مورد استفاده قرار گیرند. مثلا:Vue.component('component-a', { /* ... */ })Vue.component('component-b', { /* ... */ })Vue.component('component-c', { /* ... */ })new Vue({ el: '#app' })&#x3C;div id=&#x22;app&#x22;&#x3E;  &#x3C;component-a&#x3E;&#x3C;/component-a&#x3E;  &#x3C;component-b&#x3E;&#x3C;/component-b&#x3E;  &#x3C;component-c&#x3E;&#x3C;/component-c&#x3E;&#x3C;/div&#x3E;این حتی برای همه subcomponents نیز صدق می کند ، بدین معنی که هر سه این کامپوننت ها نیز در داخل یکدیگر در دسترس خواهند بود. ثبت محلی (Local Registration)ثبت سراسری غالباً ایده آل نیست. به عنوان مثال ، اگر از سیستم ساختاری مانند Webpack استفاده می کنید ، ثبت سراسری همه کامپوننت ها بدین معنی است که حتی اگر استفاده از یک کامپوننت را متوقف کنید ، هنوز هم می تواند در ساخت نهایی شما گنجانده شود. این باعث افزایش ناخواسته جاوا اسکریپت کاربران شما برای بارگیری می شود.در این موارد ، می توانید اجزای خود را به عنوان اشیاء ساده JavaScript تعریف کنید:var ComponentA = { /* ... */ }var ComponentB = { /* ... */ }var ComponentC = { /* ... */ }سپس کامپوننت هایی را که می خواهید از آنها استفاده کنید در خاصیت کامپوننت ها تعریف کنید:new Vue({  el: '#app',  components: {    'component-a': ComponentA,    'component-b': ComponentB  }})برای هر خاصیت در آبجکت components، کلید نام المان سفارشی خواهد بود.توجه داشته باشید که کامپوننت های محلی ثبت شده در subcomponents در دسترس نیستند. به عنوان مثال ، اگر می خواهید ComponentA در ComponentB موجود باشد ، باید استفاده کنید:var ComponentA = { /* ... */ }var ComponentB = {  components: {    'component-a': ComponentA  },  // ...}یا اگر از ماژول های ES2015 استفاده می کنید ، از جمله از طریق Babel و Webpack ، بدین صورت خواهد بود:import ComponentA from './ComponentA.vue'export default {  components: {    ComponentA  },  // ...}  سیستم ماژول (Module Systems)چنانچه در سیستم ماژول از import/require استفاده نمی کنید ، احتمالاً اکنون می توانید از این بخش استفاده کنید:کامپوننت محلی در سیستم ماژول (Local Registration in a Module System)چنانچه شما از یک سیستم ماژول مانند Babel و Webpack. استفاده می کنید در این موارد ، ما توصیه می کنیم که یک دایرکتوری components ایجاد و هر یک از کامپوننت ها را در فایل خود قرار دهید.سپس هر کامپوننتی که قرار است مورد استفاده قرار گیرد را قبل از ثبت بصورت محلی وارد نمایید.به عنوان مثال در فایل ComponentB.js یا ComponentB.vue :import ComponentA from './ComponentA'import ComponentC from './ComponentC'export default {  components: {    ComponentA,    ComponentC  },  // ...}هم اکنون هر دو کامپوننت ComponentA و ComponentC می توانند در قالب کامپوننت ComponentB مورد استفاده قرار گیرند.  ثبت سراسری کامپوننت های پایه بصورت اتوماتیک  (Automatic Global Registration of Base Components)بسیاری از کامپوننت های شما نسبتاً عمومی خواهند بود همانند دکمه ها و فیلدهای ورودی، ما بعضی اوقات به این موارد به عنوان اجزای پایه اشاره می کنیم و آنها معمولاً بسیار مورد استفاده قرار می گیرند.import BaseButton from './BaseButton.vue'import BaseIcon from './BaseIcon.vue'import BaseInput from './BaseInput.vue'export default {  components: {    BaseButton,    BaseIcon,    BaseInput  }}خوشبختانه ، اگر از Webpack استفاده می کنید (یا Vue CLI 3+ ، که از Webpack به صورت داخلی استفاده می کند) ، می توانید از Requ.context جهت ثبت سراسری این کامپوننت های بسیار رایج استفاده کنید. (به عنوان مثال src / main.js):import Vue from 'vue'import upperFirst from 'lodash/upperFirst'import camelCase from 'lodash/camelCase'const requireComponent = require.context(  // The relative path of the components folder  './components',  // Whether or not to look in subfolders  false,  // The regular expression used to match base component filenames  /Base[A-Z]\\w+\\.(vue|js)$/)requireComponent.keys().forEach(fileName =&gt; {  // Get component config  const componentConfig = requireComponent(fileName)  // Get PascalCase name of component  const componentName = upperFirst(    camelCase(      // Gets the file name regardless of folder depth      fileName        .split('/')        .pop()        .replace(/\\.\\w+$/, '')    )  )  // Register component globally  Vue.component(    componentName,    // Look for the component options on `.default`, which will    // exist if the component was exported with `export default`,    // otherwise fall back to module's root.    componentConfig.default || componentConfig  )})توجه داشته باشید که ثبت سراسری باید قبل از ایجاد نمونه root Vue انجام شود. (با Vue new)",
            "url": "/documentation/vuejs/Components-In-Depth/Component-Registration"
          }
          ,
        
          "documentation-marriage-responsibility" :{
            "title": "مسئولیت پذیری",
            "content": " مسئولیت پذیری (شهامت برای ازدواج) اشخاص وظیفه‌شناس به‌علت پاسخ‌گو بودن در مقابل کارهای‌شان قابل‌اعتمادترند و این جلب‌اعتماد از زمینه‌های پیشرفت آن‌ها به‌شمار می‌رود و مسئولیت‌پذیر بودن باعث انجام بهتر و صحیح‌تر کارها می‌شود. این ویژگی مهم روند پیشرفت‌های فردی و اجتماعی و تعاملات بین افراد را سرعت می‌بخشد و بر میزان اعتبار اجتماعی شخص می‌افزاید و به او احساس ارزشمند بودن و عزت‌نفس می‌دهد. زندگی با یک همسر وظیفه‌شناس و مسئولیت‌پذیر بسیار لذت‌بخش‌تر از زندگی با فردی بی‌مسئولیت و بی‌وجدان است.مسئولیت‌پذیری، «مسئولانه» عمل کردن است و به صرف این‌که فقط بگویید مسئولیت‌پذیر هستید، هرگز فردی مسئول نمی‌شوید. مسئولیت‌پذیری یک مفهوم نیست بلکه یک عمل است، وقتی شما به آنچه وعده داده‌اید عمل کنید، مسئولیت‌پذیر شناخته می‌شوید، به این معنی که اگر سنگ از آسمان هم ببارد هرگز فراموش‌تان نمی‌شود سر قول خود بایستید، اجاره خانه‌تان را پرداخت کنید، بموقع به قرار ملاقات‌هایتان برسید و ...داشتن حس مسئولیت‌پذیری باعث می‌شود فرد با قانع شدن به کمترین داشته‌ها و امکانات با عزمی راسخ به جدال با مشکلات زندگی برود.  «مسئولیت‌گریزی» موضوعی است که بی‌تردید می‌توان آن را یکی از مهم‌ترین دلایل رشد آمار طلاق در جامعه مورد توجه قرار داد. طبق بررسی‌های موجود، بسیاری از عواملی که موجب جدایی زوجین از یکدیگر می‌شود بر سر تقبل نکردن وظایف و انجام کارها و امور زندگی است که غالبا به دلیل مسئولیت‌گریزی زوجین یا یکی از آنها حاصل می‌شود.وظیفه‌شناسی در ازدواج و تشکیل زندگی مشترک نیازمند:بلوغ جسمانیبلوغ فکری بلوغ عاطفی بلوغ اجتماعی و روانی بلوغ اقتصادی درصورت عدم ‌وجود هر کدام از فاکتورهای بالا فرد نمی‌تواند نقش خود را به نحواحسن ایفا کند. ازدواج بدون توجه به ویژگی مسئولیت‌پذیری حاصلی جز افزایش اختلاف و بی‌نظمی در زندگی مشترک نداشته و منجر به فروپاشی کانون گرم خانواده در آینده خواهد شد.معمولا مسئولیت زیادی به کودکان واگذار نمی‌شود، چرا که می‌دانیم به قدر کافی بزرگ و پخته نیستند که بتوانند از عهده انجام برخی کارها برآیند، حال تصور کنید با کسی ازدواج کنید که مانند کودکان است و برای حفاظت از خویش هم نیازمند مراقبت است، چه برسد که بخواهد مسئولیتی را بپذیرد یا بتواند برای خوشبختی شما کاری کند.اینجاست که نمی‌دانید با مسئولیت‌های زندگی که بخشی از آن بر عهده همسرتان است چگونه کنار بیایید؟ انجام آنها را به او محول کنید یا خیر؟ و... بی‌شک با گذشت مدت زمان کوتاهی از زندگی مشترک متوجه خواهید شد که با یک کودک ازدواج کرده‌اید، کودکی که فقط بدن و اندامی بزرگسالانه دارد.یادتان باشد کسانی که همیشه احتیاج به مراقبت دیگران دارند و بار زندگی‌شان را به دوش آنان می‌اندازند، هرگز نمی‌توانند حامی و حمایتگر همسرشان باشند و حس امنیت و نیاز پشتیبانی‌شان را اقناع کنند.یکی از دلایل بالا رفتن سن ازدواج، همین عدم مسئولیت‌پذیری جوانان می‌باشد.جوانان امروزی به‌ویژه پسران به علت ترس از مسئولیت‌پذیری حاضر به ازدواج نمی‌شوند و هرگز نیز این توان را در خود نمی‌بینند که بتوانند از عهده چنین مسئولیت مهمی برآیند و شاید به همین دلیل است که بسیاری تجرد را می‌پسندند و آن را تصمیم قطعی زندگی‌شان قلمداد می‌کنند.بلوغ عاطفیمحبت کردن و دریافت محبت یکی از اولین نشانه های بلوغ عاطفی است. کسانی که به بلوغ عاطفی نرسیده اند، همواره نیازمند محبت و توجه هستند و ضعف های خود را پنهان می کنند، انتقادپذیر نیستند، حسادت می کنند، کمتر کسی را می بخشند، خلق و خوی ثابتی ندارند و کج خلقی می کنند. در مقابل مهمترین ویژگی در افرادی که به رشد شناختی، عاطفی و اجتماعی رسیده اند این است که نقاط ضعف و قوت خود را می شناسند، توانایی پذیرش تعهد و مسئولیت را در زندگی خود دارند و در قبال تصمیمات و رفتارهایی که انجام می دهند بالغانه و مسئولانه عمل می کنند. توانایی تصمیم گیری صحیح و بدون وابستگی به دیگران را دارند. پیروی بی چون و چرا از دیگران ندارند و استقلال فکریشان را حفظ می کنند و مسائل را تجزیه و تحلیل می کنند.مثلاً به کسی فکر کنید که کل آرامشش وابسته به حضور دیگران است؛ اگر مادر، پدر یا همسر کنارش نباشند یا از او تعریف نکنند انگار که اصلاً وجود ندارد.بلوغ اجتماعی  و روانی بلوغ اجتماعي مرحله ای است که انسان به خودکفايي، استقلال، قدرت تصمیم گیری و هویت میرسد ، افراد دیگر را می پذیرد و با آن ها تعامل سازگار برقرار ميکند.افرادی که دارای بلوغ اجتماعی هستند:اهل تعاون و همکاري هستند. توجه و تائید سایرین را از طريق درست و اصول برتری و ارتقای شخصیت خود به دست می آورد.انتقاد به سایرین را بصورت سازنده، آرام، و ساده و با زبانی ملایم مطرح می نماید و از انتقاد آن ها نسبت بخود عصبانی نمی شود.روحیه قدر دانی و تشکر در تمامی زمينه ها در وی وجود دارد ارشاد و راهنمايي افراد دیگر را می پذیرد.شادمان ، متواضع و خوش اخلاق است.بلوغ اقتصادی توانمندی اقتصادی در ازدواج این است که فرد بالقوه توانایی داشته باشد که اگر زندگی مشترک تشکیل داد، بتواند آن را اداره کند و کافی است تنها بخشی از این توانمندی به فعلیت رسیده باشد. در واقع بلوغ اقتصادی جوان به معنای داشتن برنامه اقتصادی برای آینده، کم شدن وابستگی اقتصادی فرد از خانواده، و کسب درآمد حداقلی است.در این نوع بلوغ شما توانایی و مهارت تامین مالی و مدیریت مالی زندگی را دارید. می دانید چقدر درآمد دارید، از کجا در می آورید و کجا خرج می کنید، یعنی مدیریت مالی دارید. اگر بخش مهمی از درآمدتان صرف دوستانتان می شود یا برای خرید موبایل جدید، اسپرت کردن ماشین تان و... از کفتان می رود، یعنی برای ازدواج مناسب نیستید. این توانایی کسب درآمد و برنامه ریزی برای هزینه ها بلوغ مالی گفته می شود.رسیدن به بلوغ اقتصادی صرفاً مربوط به پسران نمی شود بلکه دختران هم باید مدیریت و برنامه ریزی مخارج را بلد باشند تا بتوانند زندگی همراه با پیشرفت، آرامش و دوری از فقر مادی و روحی را داشته باشند.بلوغ فکریاین افراد توانایی کنترل تکانه های هیجانی خود را دارند و می توانند احساسات خود را مدیریت کنند، شخصیت های وابسته و احساساتی نیستند و همواره نیازمند توجه و محبت افراطی نیستند، اغلب حسادت نمی کنند و می توانند دیگران را ببخشند و خودشان در عذر خواهی پیش قدم می شوند. از امکانات و فرصت هایی که دارند به خوبی استفاده می کنند و افرادی اخلاق مند هستند که یک سلسله اصول اخلاقی را برای خود تعریف کرده اند که در هیچ شرایطی پا فراتر از آن نمی گذارند؛ همچنین برای دیگران ارزش انسانی بالایی قائل هستند و کسی را مسئول خوشبختی خود نمی دانند چرا که خود برای رسیدن به خوشبختی شان تلاش می کنند. و نکته آخر اینکه این افراد توانایی این را دارند که خود را با شرایط و محیط پیرامونشان سازگار کنند و تطبیق دهند.بعضی‌ها از خودشان فکر و ایده ندارند. آن‌ها آن‌قدر دهان‌بین هستند که هر کس چیزی گفت فوری می‌پذیرند. برعکس آدم‌هایی که وابستگی فکری ندارند، خودشان باورها و ارزش‌های مخصوص به خودشان را دارند؛ مثلاً فرض کنید که یک نفر فقط به این خاطر از یک فیلم خوشش آمده که کناردستی‌اش دارد از آن تعریف می‌کند. اصلاً منظور ما این نیست که آدم‌ها نباید از هم کمک فکری بگیرند اما خودشان باید به این نتیجه برسند که فلان باور درست است یا غلط.وابستگی، به معنی اتکای به دیگری، زیر دست یا تابع کسی بودن، تعلق به چیزی یا کسی داشتن و تکیه کردن به دیگری برای درخواست حمایت یا کمک است.آدم وابسته عزت نفس خوبی هم نداره و اصلا خودشو در حد این نمیبینه که بتونه خیر و صلاح خودشو تشخیص بده پس دنبال خیر و صلاحش در حرف دیگرانه و تصویرش از خودش ناتوان تر از این حرف هاست.اختلال شخصیت وابسته، نوعی اختلال شخصیت است که فرد وابستگی فراگیر روانی به افراد دیگر دارد. اختلالات شخصیت عبارتند از مجموعه اختلال‌های روان شناختی که ویژگی اصلی آن‌ها رفتارهای خشک و غیرقابل انعطاف است. این اختلال شخصیت یک وضعیت بلند مدت (مزمن) است که در آن بیمار برای نیازهای عاطفی و جسمی خود به دیگران وابسته است و تنها یک حداقل دستیابی به سطح طبیعی استقلال دارد.انواع وابستگی فکری :1 - وابستگی به خانواده وابستگی بیش از حد مانند همان بند نافی است که تمام نیازهای جنین از آن تامین می شود. در افراد وابسته این بند ناف روانی پس از ازدواج قطع نمی شود و شخص را همچنان به خانواده و گذشته ارتباط می دهد.تربیت مهم ترین دلیل ایجاد شخصیت وابسته در فرد است. برخی از والدین، به دلیل کمبودهای روحی و زخم های گذشته، از فرزندشان فردی وابسته به خود می سازند که از آن به همسرسازی فرزند نیز یاد می شود.اغلب ما، به خصوص با توجه به تربیت شرقی و ایرانی، به خانواده و والدین خود علاقه زیادی داریم. با آنان ارتباط ویژه ای داریم و تقریبا هر روز به شکلی با آنها ارتباط می گیریم.وجود این ارتباط عاطفی به خودی خود مشکل ساز نیست، تا زمانی که فرد استقلال فردی خود را نیز حفظ کند و به نیازهای همسرش توجه داشته باشد.این حالت زمانی به مشکلی جدی تبدیل می شود که خانواده نقش پررنگی در تصمیمات و استقلال فرد بازی کند و فرد نتواند از لحاظ عاطفی از آنان جدا شود.این وابستگی معمولا باعث می شود که خانواده نیز دخالت بیشتری در زندگی فرزند خود داشته باشند و در تصمیمات آنان نقش مهمی ایفا کنند. شخص به هنگام مشکلات به اولین کسی که رجوع می کند خانواده اش هستند و از آنان چاره جویی می کند. این چاره جویی به خصوص اگر در زمینه اختلاف با همسر باشد، باعث نارضایتی بیشتر می شود.رکن اصلی زندگی این است که از خانواده خودمان جدا شویم و در زندگی مشترک و جدیدمان دلبستگی و وابستگی ایجاد کنیم اما معمولا فرد وابسته به خانواده در این شرایط دچار اضطراب و استرس می شود و قدرت تصمیم گیری درستی ندارد چون هنوز آمادگی ازدواج نداشته و از روی احساسات این کار را انجام داده است.انواع وابستگی ها به مادر و خانواده:فرد وابسته به خانواده، فقط در مواردی خاص برای حل مشکلات به سراغ خانواده می رود و به تصمیمات آنها عمل می کند.خانواده برای فرد حتی در زندگی جدیدش حضور و نقش پر رنگی دارند و حکم سایه را ایفا می کنند یعنی در همه جا با او هستند و فرد بدون آن ها نمی تواند تصمیمی برای زندگی خود بگیرد. این افراد از لحاظ روانی و عاطفی بسیار وابسته هستند و این وابستگی در زندگی آنان با وجود تشکیل خانواده هنوز ادامه دارد . به علت وابستگی های شدید ، خانواده آنها به خود اجازه دخالت در کوچک ترین مسائل زندگی مشترک را می دهند و موجب بروز اختلافاتی در زندگی زناشویی آنان می گردند.در حالت دوم ، افراد به محض وقوع اتفاق کوچکی که در رابطه پیش می‌آید فورا به سراغ والدین خود می‌روند و آن‌ها را در جریان تمام ماجرا می‌گذارند. در بسیاری از مسائل مهارت لازم را ندارند، به خصوص مهارت‌های اجتماعی. به جای اینکه خودشان مساله را حل کنند، نامزدشان را مقابل والدین قرار می‌دهند. فرد وابسته به خانواده در مورد موضوعی با همسرش توافق می‌کند ولی به محض اینکه به منزل خانواده‌اش می‌رود زیر توافق خود می‌زند.2 - وابستگی و تاثیر دوستان  بعد از ازدواج شما وارد شبکه ی گسترده ای از ارتباطات می شوید. تنها ارتباط با همسرتان نیست که تعیین کننده ی موفقیت شما در ازدواج است. شما باید با خانواده ی او ،دوستان او حتی شغل او و همچنین همسرتان هم با دوستان شما ،خانواده تان و شغل و دل مشغولی های شما ارتباط درست برقرار کند.بعد از ازدواج وضعیت ارتباط با دوستان کمی فرق می کند .باید هر کدام از طرفین در کنار حفظ روابط دوستانه ی خود با ایجاد تعادل در میزان رابطه ، رضایت خاطر همسرشان را تأمین کنند.دوران مجردی تمام شده است، الان دقیقا شما یک فرد متاهل شده اید، با یکسری وظایف. دقیقا از زمانی که پای قرارداد زندگی مشترک را امضا کردید همه موارد دوران مجردی را خط زدید. رفیق بازی دقیقا یکی از همین کارهاست. گاهی زوجین با پافشاری روی این موضوع پای شان به دادگاه کشیده می شود. نمی گوییم بعد از ازدواج دوستی ها را باید کنار گذاشت بلکه عدم مدیریت این روابط سبب می شود تا عدم الویت گذاری بین زندگی مشترک و دوستان، آسیب های جدی به زندگی وارد کند. درست است که رفقا پیراهنی نیستند که روز به روز عوض‌شان کنید اما به هر حال به قول سهراب سپهری همیشه «دوستانی بهتر از آب روان» نصیب‌تان نمی‌شود؛به همین دلیل گاهی لازم است همراهان‌تان را پس از ازدواج غربال کنید و آنهایی که برای زندگی مشترک‌تان خطرناکند را کنار بگذارید. ما در این مطلب به 8 گروه از دوستان خطرناکی اشاره کرده‌ایم که می‌توانند دوام زندگی مشترک‌تان را تهدید کنند و شما و همسرتان را به جان هم بیندازند اما شک نکنید این فهرست همیشه قابل گسترده شدن است. ‌دوستان اهل بازی «من از تو خوشبخت‌تر هستم»می‌توانید حدس بزنید این دوستان چه جور آدم‌هایی هستند؟ آنها اصرار دارند با شما وارد رقابت بر سر دارایی‌های‌شان شوند؛ مثلا مدام از روابط عالی با همسرشان حرف بزنند و شرح بدهند شریک زندگی‌شان مثل یک بره مطیع است و آنقدر عاشق که جانش را کف دستش گذاشته و هر دم، آماده است آن را فدای‌شان کند. تصویری که آنها از زندگی‌شان می‌سازند، همیشه اغراق‌آمیز است. همه افتخارشان خلاصه می‌شود در مارک لباس‌ها، لوازم منزل‌شان، درآمد بالا، تفریحات اعیانی، خریدهای آنچنانی، سفرهای اعجاب‌انگیز و دوردور کردن در فروشگاه‌های گران‌قیمت.چه خطری تهدیدتان می‌کند؟مهم‌ترین ضرر همنشینی با این دست آدم‌ها، مقایسه کردن زندگی خودتان با آنها و افزایش حس نارضایتی در شماست. نتیجه این بازی هم از همان اول معلوم است؛ زندگی مشترک‌تان هرقدر هم که خوب باشد آنها همیشه یک برگ برنده برای رو کردن دارند تا ثابت کنند اهمیتی ندارد چقدر برای خوشبختی دست و پا بزنید، آنها همیشه از شما خوشبخت‌تر هستند.این گروه از دوستان، بی‌آنکه نظر شما را بپرسند، شما را به یک رقابت احمقانه بر سر بیشتر به دست آوردن و بیشتر داشتن وارد می‌کنند و انتظارات‌تان از زندگی مشترک و همسرتان را تا جایی بالا می‌برند که هیچ‌وقت به آنچه دارید، راضی نمی‌شوید.دوستان اهل بازی «من چقدر بدبختم!»رفتار این گروه دقیقا برعکس گروه قبلی است. کارشان فقط نق زدن است. آنها زندگی شما را با مال خودشان مقایسه می‌کنند و دائما غبطه می‌خورند و با حسرت تمام نشدنی‌شان تاثیری منفی بر زندگی مشترک‌تان می‌گذارند.مهسا که دوستی با یکی از این آدم‌ها را تجربه کرده است، تعریف می‌کند در یک مهمانی خانوادگی همان دوست حسرت‌خور، مدت‌ها حرکات شوهر او را زیر نظر گرفته بود و همین که دور هم جمع شده بودند تا گپی بزنند، خطاب به شوهر مهسا گفته بود: «شما چه همسر مهربانی هستید. شوهر من هیچ وقت در کارهای خانه کمکم نمی‌کند. شوهرم می‌گوید، مرد واقعی نباید در خانه دست به سیاه و سفید بزند.خوش به حال زن‌تان. واقعا شما با این همه کار بیرون از خانه چطور به کمک کردن در خانه هم می‌رسید؟» حسرت خوردن این دوست اما به همین‌جا ختم نشده بود. او در مهمانی بعدی، حسودی کرده بود که چرا شوهر مهسا او را «عزیزم» خطاب می‌کند اما شوهر خودش، اسمش را صدا می‌کند و بعد باز موضوع کمک کردن شوهر مهسا در امور خانه را پیش کشیده بود و با خنده‌ای از سر لج گفته بود: «شما مثل یک کدبانو کار می‌کنید!»چه خطری تهدیدتان می‌کند؟‌خودتان را جای مهسا بگذارید. احساس می‌کنید با نشان دادن این واکنش‌ها همسرتان چه احساسی پیدا می‌کند؟ دوستان حسرت‌خور گذشته از انرژی منفی‌ای که با خود به هر جمعی می‌آورند، می‌توانند در شما یا شریک زندگی‌تان احساس برتری کاذبی ایجاد کنند و شما دو نفر را در اوج خوشبختی به جان هم بیندازند.دوستانی که زیادی صمیمی می‌شونداین گروه از دوستان، حد و مرزی برای ارتباطات‌شان نمی‌شناسند. آنها دیگران را بیش از اندازه به حریم خصوصی‌شان وارد می‌کنند و به خود هم اجازه وارد شدن به خط قرمزهای زندگی دیگران را می‌دهند. چنین افرادی دعوای زن و شوهری‌شان را خیلی راحت به خانه شما می‌آورند، سرزده سراغ‌تان می‌آیند و برنامه‌های‌تان را به هم می‌زنند و از اینکه در مناسبات زندگی خصوصی‌تان دخالت کنند، ابایی ندارند.آنها با همسرتان هم به اندازه شما صمیمی می‌شوند و مثل یک دوست قدیمی بی‌نیاز به حضور شما با او وارد ارتباط شده و حتی درددل می‌کنند و گاهی حتی دایه عزیز‌تر از مادر می‌شوند و همسر شما را به عنوان دوست صمیمی و قدیمی‌شان معرفی می‌کنند.چه خطری تهدیدتان می‌کند؟بی‌تعارف و خیلی سریع، نام آن دوستانی را که در روابط با همسرتان حد و مرز نمی‌شناسند، از فهرست رفقای صمیمی‌تان حذف کنید.هر ارتباطی تعریفی دارد. رابطه همسر شما و دوستان‌تان هم از این قاعده مستثنا نیست. فراموش نکنید همیشه پس از ازدواج این امکان وجود دارد که برخی دوستان عمدی یا غیر عمدی تلاش کنند بیش از حد با همسرتان صمیمی شوند.ممکن است تصور کنید شما جوان و برازنده هستید و همسرتان شما را برای زندگی مشترک انتخاب کرده است پس این بیش از حد صمیمی شدن‌ها، تاثیری در نظر همسرتان نسبت به شما ندارد اما در اشتباهید. به هرحال روابط تعریف نشده و خارج از عرف یک دوست، همیشه وسوسه‌ای دائم برای شریک زندگی شماست که راه لغزش را برایش هموار می‌کند. گاهی شنیدن درد دل‌های دیگران و همدردی با آنها می‌تواند ما را بیش از اندازه به آنها نزدیک کند.به این سوال پاسخ دهیددر روابط انسانی باید مدام هدف‌ها را بسنجیم و از خود بپرسیم منظور اصلی‌مان از ارتباط با دیگری چیست. دوستانی که بلد نیستند به‌درستی به این سؤال جواب بدهند در ارتباط با آدم‌های دیگر از جمله همسر شما با چالش مواجه می‌شوند و چه بسا حتی دچار سوء‌برداشت شوند.دوستان خیانتکاراین افراد یا از زندگی با شریکی که انتخاب کرده‌اند ناراضی‌اند و به همین دلیل در جای دیگری به دنبال خوشبختی می‌گردند یا اینکه خود را اهل تنوع یا قربانی یک عشق ناگهانی معرفی می‌کنند و رابطه‌ای موازی با زندگی مشترک‌شان را شکل می‌دهند. ممکن است این افراد از سر شرم یا به هر دلیل دیگری این رابطه را از شما و دیگران پنهان کنند یا اینکه برعکس شما را محرم رازهای مگوی‌شان تلقی کنند و خاطرات و اتفاق‌هایی که در این رابطه تجربه می‌کنند را با شما تقسیم کنند.دوستانی که به همسرشان خیانت می‌کنند، عهدشکنی‌های‌شان را با آب و تاب برای‌تان تعریف می‌کنند، دست به دامن توجیه‌های مسخره می‌شوند، دلیل‌های عجیب و غریب می‌تراشند تا شما را قانع کنند که حق داشته‌اند عهدشان را در زندگی مشترک‌شان بشکنند و راه بیفتند پی هوس‌شان.چه خطری تهدیدتان می‌کند؟رفت و آمد با آنها دو اشکال بزرگ دارد؛ اولا آهسته‌آهسته، زشتی عهدشکنی پس از ازدواج برای‌تان کمرنگ می‌شود و امکان دارد تغییر باورهای‌تان بی‌آنکه متوجه باشید به تغییر رفتار منجر شود. پژوهشگران می‌گویند بسیاری از رفتارهای ناخوشایند و واکنش‌های نادرست از طرف دیگران به ما منتقل می‌شوند. آنها می‌گویند رفتارهای مخرب به نوعی واگیردار هستند و بی‌آنکه بدانید می‌توانند زندگی شما را به تسخیر خود در بیاورند.از طرف دیگر همسر شما هم خواسته یا ناخواسته بخاطر این معاشرت‌ها در معرض ویروس واگیردار خیانت قرار می‌گیرد.ثانیا زندگی مشترک‌تان همیشه در خطر است چون کسی که به عهدش با نزدیک‌ترین شریکش یعنی همسرش وفا نکرده است می‌تواند در رفاقتش با شما هم بی‌وفا باشد و زندگی مشترک‌تان را به خطر بیندازد.خطر دیگری هم در کمین‌تان استشما محرم رازهایی می‌شوید که نه از عهده فاش کردن‌شان برمی‌آیید و نه توان نگه داشتن‌شان را دارید. هر زمان که همسر دوست خیانتکارتان را می‌بینید، احساس می‌کنید وظیفه نجات دادن زندگی‌اش را با گفتن چنین رازی دارید و از سوی دیگر در قبال حرفی که مجوز به زبان آوردنش را ندارید هم مسئولید و هم ممکن است با مطرح کردن این موضوع فاجعه‌ای را به بار بیاورید که توان تحمل عواقبش را ندارید.دوستانی که ازدواج‌تان توی کت‌شان نمی‌روداین گروه ارزشی برای وقت شما در زندگی مشترک قائل نیستند. آنها درک نمی‌کنند که پس از ازدواج بخشی از وقت و قلب شما متعلق به همسرتان است و شما را تمام و کمال می‌خواهند. اگر به این افراد بگویید نمی‌توانید همه روزتان را همراه‌شان در پاساژها دوردور کنید یا در کافی‌شاپ‌ها بنشینید و قهوه دوبل بخورید یا به درددل آنها گوش کنید، شما را به جوگیر بودن یا عوض شدن متهم می‌کنند و برای همیشه روی‌تان خط می‌کشند.چه خطری تهدیدتان می‌کند؟اگر بخواهید این افراد را در کنار خود حفظ کنید، باید برخی مناسبات زندگی مشترک‌ را زیر پا بگذارید. برای چنین دوستانی محدودیت‌های شما در مجردی سفر رفتن قابل درک نیست. آنها نمی‌پذیرند شما گذشته از همسرتان با خانواده او هم وصلت کرده‌اید و باید وقتی را برای بودن در کنار دوستان دیگر و فامیل‌ها هم در نظر بگیرید. برای این افراد پذیرفتنی نیست که شما مسئولیت رسیدگی به امور خانه را دارید و نمی‌توانید 8 شب خسته و بی‌رمق به خانه بازگردید و قبل از آمدن به تنهایی شام‌تان را بخورید.اگر بخواهید چنین دوستانی را حفظ کنید، احتمالا از سوی همسرتان انگ بی‌مسئولیتی می‌خورید و اگر هم بخواهید از زندگی مشترک‌تان محافظت کنید، احتمالا مدام باید طعنه‌ها و گلایه‌های آنها را تحمل کنید اما یادتان نرود دوستان واقعی باید به این شراکت جدید در زندگی‌تان احترام بگذارند و در غیر این صورت همراه‌های مناسبی برای ادامه مسیر دوستی نیستند.دوستانی که عادت‌های بد دارنددوستان وراج که ارزشی برای زمان قائل نیستند، دوستان اهل دود و دم، دوستان قانون‌شکن، دوستان فحاش و بددهن و خلاصه دوستانی که می‌دانید عادت‌های ناپسندشان در حدی خطرناک است که امکان دارد همنشینی با آنها به زندگی مشترک‌تان آسیب بزند، نباید در فهرست دوستان پس از ازدواج‌تان باقی بمانند.چه خطری تهدیدتان می‌کند؟در نظر داشته باشید که هر رفیقی نقاط ضعفی هم دارد اما گاهی برخی صفات ناپسند یک به اصطلاح دوست، بلای جان‌تان می‌شود. یادتان نرود بسیاری از صفات ناپسند واگیر دارند و زودتر از خصوصیات پسندیده اطرافیان‌تان به شما منتقل می‌شوند. شاید در آغاز فحاشی‌های یک دوست برای‌تان آزاردهنده شود اما به مرور گروه واژگان شما شبیه به هم می‌شود و حتی لحن و حالت حرف زدن‌تان هم به یکدیگر شباهت پیدا می‌کند حتی اگر احساس کنید توان ایستادگی در برابر این هجوم را دارید، نمی‌توانید از توانایی همسرتان در این مورد هم مطمئن باشید.دوستانی که آتش بیار معرکه‌اندهمه می‌دانند آسمان هیچ زندگی مشترکی همیشه آفتابی نیست و گاهی وقت‌ها هم ابری می‌شود. این جور وقت‌ها دوستان واقعی تلاش می‌کنند به شما و همسرتان برای بازسازی زندگی‌تان کمک کنند اما دوستانی هم وجود دارند که به جای بازسازی روابط‌تان، آتش‌بیار معرکه می‌شوند و در لباس مشاوری امین، مدام تحریک‌تان می‌کنند که مبادا از خطای همسرتان بگذرید یا با جرات در حضور همسرتان به اشتباه‌های‌تان اعتراف و طلب بخشایش کنید.حتی اگر قهرتان با وجود کارشکنی‌های‌شان، سرانجام به آشتی برسد آنها آرام نمی‌گیرند طوری که انگار دلخوری‌شان از مشکلات زندگی شما از خودتان هم بیشتر است به همین علت است که اگر همسرتان در جمع حضور نداشته باشد یا درباره‌اش بد می‌گویند یا آنقدر به ضعف‌های زندگی‌تان اشاره می‌کنند و از آنها می‌پرسند که دست آخر سردرددل شما هم باز شود.بعد یک گوش خوب برای غیبت شنیدن می‌شوند و همه نکات منفی را به خاطر می‌سپرند و در گفت‌وگوهای بعدی با همان الفاظ و صفت‌ها درباره همسرتان حرف می‌زنند اما شما دیگر نمی‌توانید بابت توهین‌های‌شان به آنها گلایه کنید چون بخش عمده حرف‌های‌شان با استناد به گفته‌های شما در زمان آن درددل‌های دوستانه است!چه خطری تهدیدتان می‌کند؟چرا آنها نمی‌توانند زندگی آرام شما را تحمل کنند؟ جالب است بدانید گاهی رفتارهای جسورانه‌ای که این نوع دوستان برای برخورد با همسرتان به شما توصیه می‌کنند، آرزوهایی است که برای زندگی مشترک خودشان دارند؛ آرزوهایی که سرکوب شده است و نتوانسته‌اند عملی‌شان کنند چون می‌دانسته‌اند که این رفتارها زندگی مشترک‌شان را خراب می‌کند.برای مثال مردی که در زندگی مشترکش همیشه از ترس رفتار پرخاشگرانه همسرش، ساکت و سر به زیر بوده است در اداره وقتی ماجرای مشاجره دوستش را با همسرش می‌شنود به او پیشنهاد می‌کند گاهی زنش را کتک بزند؛ رفتاری که او پیشنهاد می‌کند در واقع گرایش سرکوب‌شده‌ای در خودش است که نتوانسته در زندگی مشترک‌ خودش اجرایی‌اش کند چون می‌داند که همسرش با پرخاشگری‌اش برخورد خواهد کرد.گروه دیگری از دوستان «آتش بیار معرکه»، توصیه‌های بدی برای شما دارند چون خودشان، تجربه‌های بدی در زندگی مشترک داشته‌اند و بیشتر از آنچه به شما پیشنهاد می‌کنند از زندگی یاد نگرفته‌اند. برخی از آدم‌های این گروه زندگی‌هایی از هم پاشیده دارند و طبیعتا تجربه‌های‌شان از همان زندگی را به شما هم منتقل می‌کنند.برای نمونه امکان دارد دوستی که زندگی‌اش به علت خیانت همسرش به طلاق رسیده است به محض اینکه درددل شما را درباره کم‌توجهی و حواس‌پرتی همسرتان بشنود به شما هشدار ‌دهد که احتمالا شریک زندگی شما هم در حال خیانت کردن است.در حقیقت این گروه تجربه‌های ناخوشایند خودشان را به زندگی دیگران «تعمیم» می‌دهند. «تعمیم‌دهی» یک «خطای شناختی» است و معمولا وقتی اتفاق می‌افتد که مهارت لازم برای تحلیل چالش‌ها را نداشته باشم.آنها با تعمیم‌دهی‌های نابجا، محیطی تاریک، ترسناک و پر از گزند و بی‌اعتمادی را در زندگی مشترک برای‌تان توصیف می‌کنند در حالی که اگر بخواهید واقع‌گرایانه به زندگی نگاه کنید، می‌فهمید آنقدرها هم که این دوستان توصیف می‌کنند تلخ نیست مگر آنکه خودتان فقط دنبال ناخوشی‌هایش بگردید.اما این دوستان گروه سومی هم دارند؛ کسانی که درکی از مشکل شما ندارند و توصیه‌هایی کلیشه‌ای و انتزاعی را برای‌تان سرهم می‌کنند. اگر شما با دوست مجردتان در مورد بدخلقی امروز همسرتان درددل کنید، احتمال اینکه فکر کند دعوا نمک زندگی شماست، بسیار کم خواهد بود.او با شنیدن توصیف‌های شما، رفتار همسرتان را به موقعیت‌های دیگر تعمیم می‌دهد و از اینکه شما آنقدر ساده‌اید که حاضر به جدا شدن از چنین مردی نیستید، عذاب می‌کشد و البته این عذاب را به شما هم منتقل می‌کند. چنین دوستی نمی‌تواند بپذیرد زندگی زیر یک سقف با چالش‌هایی هم همراه است که گذر زمان و شناخت بیشتر شما و همسرتان از یکدیگر به کم شدن‌شان کمک می‌کند.",
            "url": "/documentation/marriage/responsibility"
          }
          ,
        
          "documentation-marriage-betrayal" :{
            "title": "تعهد و عدم خیانت",
            "content": " تعهد  زمانی که یک مرد و زن مجرد در خود این توانایی را می بیند که اقدام به ازدواج و عقد قانونی آن کنند، به دنیای دیگری وارد می شوند. دنیایی که در آن از بی تعهدی احتمالی و رفع مسئولیت های دوران مجردی خبری نیست و دو طرف باید تن به یک تعهد دائم نسبت به یکدیگر دهند. این تعهد شامل تعهد زمانی، حمایتی، پشتیبانی، عاطفی و جنسی است.تعهد زمانی این معنی است که دو طرف به یکدیگر تعهد دهند که در بیشترین و مهم ترین زمان های خود در کنار یکدیگر باشند.تعهد حمایتی دال بر این است که دو طرف بکوشند که از یکدیگر در شرایط سخت حمایت کنند.تعهد پشتیبانی  به این موضوع اشاره دارد که دو طرف نسبت به هم مسئول باشند و مسئولیت ها و تکالیف شخصی خود را ادا کنند.تعهد عاطفی  بدین معنی است که دو طرف یکدیگر را دوست داشته و در تامین نیازهای عاطفی یکدیگر و پرکردن خزانه عاطفی هم کوشا باشند.تعهد جنسی  بدین معناست که زن و مرد بتوانند نیازهای غریزی و جنسی خود و همسر خویش را تامین کنند و در این زمینه کمبودی نسبت به هم وارد نکنند.خیانتخیانت ، شکستن تعهد در یک ازدواج یا رابطه است. اگر یکی از طرف های رابطه ازدواج در برآورده کردن هر یک از این کارکردهای اصلی رابطه، رجوع به فرد سومی خارج از رابطه دو نفره خود کند، اقدام به خیانت کرده است.در تعبیر خیانت ، هرگونه پنهان کاری که از جانب یکی از طرفین در رابطه ازدواج صورت گیرد، خیانت محسوب شده و سندی است دال بر بی وفایی او.    هرگونه روابط خارج از چارچوب زناشویی، خیانت محسوب می شود؛ بنابراین با این توضیحات، خیال پردازی با شخصی غیر از شریک زندگی، و روابط تلفنی و اینترنتی نیز خیانت تلقی می شود.  خیانت در رابطه خانوادگی دارای انواع و اقسام مختلفی است که عبارتند از:خیانت رفتاری :منظور از خیانت رفتاری این است که یکی از همسران به صورت رفتاری و با ارتباط برقرار کردن با شخصی خارج از سیستم خانواده به همسرش خیانت کند که بخش اعظم آن را ارتباط های جنسی تشکیل می دهد و در جامعه ما نیز رایج است.خیانت ذهنی :افرادی که در فکر و تخیلاتشان مدام به شخصی دیگر می اندیشند و از آنجا که زاده ذهنشان است، آن فرد شخصی ایده آل به شمار می آید و در این موقع است که برای زندگی مشترک خطر می آفریند چرا که آن شخص دایما شریک زندگی اش را با فرد ایده آل ساخته ذهنش مقایسه می کند و چون در حال قیاس است، در ارتباط با همسرش به مشکل برمی خورد و رابطه سرد می شود.خیانت کلامی :افرادی که در فکر و تخیلاتشان مدام به شخصی دیگر می اندیشند و از آنجا که زاده ذهنشان است، آن فرد شخصی ایده آل به شمار می آید و در این موقع است که برای زندگی مشترک خطر می آفریند چرا که آن شخص دایما شریک زندگی اش را با فرد ایده آل ساخته ذهنش مقایسه می کند و چون در حال قیاس است، در ارتباط با همسرش به مشکل برمی خورد و رابطه سرد می شود.دلایل خیانت در سبب‌شناسی خیانت دلایل متعددی را می‌توان برشمرد که به دلیل تفاوت‌های فردی این دلایل یا عوامل، می‌تواند در افراد مختلف و جوامع گوناگون و حتی در زمان‌های (شرایط) مختلف، متفاوت باشد.افراد بنا به دلايل مختلفي از جمله: كنجكاوي، تنوع طلبي، انگيزه تجربه كردن ، مبارزه با ناكارآمدي و كسب اعتماد به نفس، سرگرمي، گريز از واقعيت، مشكلاتي در رابطه با صميميت، انتقام و كنجكاوي جنسي، وارد روابط فرا زناشويي مي شوند. چهار عامل جنسي، هيجاني، انگيزه پيشرفت و عاشق شدن را به عنوان علل خيانت نام مي برند . در این زمینه، ویلیام گلاسر، روان‌شناس نامی، بیان می‌دارد: زوج‌ها زندگی مشترکشان را با عشق شروع می‌کنند، اما می‌بینند صمیمیت اولیه به‌تدریج رنگ می‌بازد. با گذشت زمان به زندگی مشترکشان با آهنگی یکنواخت و ملال‌آور ادامه می‌دهند و برای تحمل این زندگی به مشروبات الکلی، پرخوری، استفاده از مواد مخدر یا ارتباطات نامشروع روی می‌آورند. به عقیدهٔ این روان‌شناس، مهم‌ترین انگیزهٔ زن و مرد متأهلی که به‌سوی روابط نامشروع کشیده می‌شوند، تجربهٔ مجدد صمیمیت فردی و جنسی است. چیزی که دیگر آن را در زندگی مشترکشان نمی‌یابند؛ بنابراین جذابیت روابط نامشروع بدین دلیل است که هیچ یک از طرفین، عیب‌جویی، سرزنش و شکوه نمی‌کنند یا نق نمی‌زنند. بعضی مواقع هم رابطهٔ خارج از ازدواج فقط به منظور کسب هیجان و تنوع اتفاق می‌افتد؛ یعنی هیچ شکایت یا نارضایتی خاصی در ازدواج وجود ندارد فقط برخی افراد به دنبال هیجان رابطهٔ خارج از ازدواج هستند. در واقع پنهان‌کاری و راز موجود در یک رابطهٔ غیرقانونی به جذابیت رابطهٔ خارج از ازدواج می‌افزاید.مسائل گذشته قبل از ازدواج ، شامل روابط جنسي و عشقانه مي شود . خيانت در افرادي كه قبل از ازدواج رابطه جنسي و یا عاطفی داشته اند، بيشتر عنـوان شده است . این افراد، از نگرش سهل گيرانه تري نسبت به روابط فرا زناشويي برخوردار هستند. این افراد همچنان شماره تماس های فردی که در گذشته در تماس بوده اند را در گوشی خود ذخیره نگه می دارند، در شبکه های اجتماعی همچنان در ارتباط بوده و با این تفکر که در حال  حاضر فقط یک دوست هستند به خیانت می پردازند.اگرچه هیچ‌کدام از دلایل ، خیانت و بی‌وفایی را توجیه نمی‌کند .توجیه ذهنی فرد خیانتکارزنان و مردان خیانتکار وقتی دست‌شان رو می‌شود، با ناچیزانگاری و بهانه‌جویی، رفتارشان را با چنین توضیحاتی توجیه می‌کنند:هر فردی می‌خواد با فرد دیگه رابطه جنسی داشته باشه. اگر بتونند، همه این کار رو می‌کنند. چرا من باید جور دیگه‌ای باشم؟ بیشتر افراد این کار رو می‌کنند. از خودشون بپرسید.اگر تو خونه خودم از نظر جنسی ارضا می‌شدم، خیانت نمی‌کردم.اگر این‌قدر چاق نبود، با من رفتار بهتری داشت یا بیشتر به من می‌رسید، به خیانت فکر نمی‌کردم.اگر شغلم این‌قدر استرس‌‌زا نبود، برای تسکین اضطراب به‌سراغ خیانت نمی‌رفتم.کدوم خیانت؟ خوش‌وبش و کمی تفریح در کافه که خیانت نیست. این تفریح است.من فقط پیام می‌دم و خوش‌وبش می‌کنم. چه ضرری داره؟ هیچ‌کدوم از این افراد رو تابه‌حال از نزدیک ندیدم. این فقط یه بازیهدر روان‌شناسی، به چنین بهانه‌جویی‌هایی (انکار) می‌گویند. در انکار، فرد با دروغ‌ها و فریب‌های درونی خودش را قانع می‌کند که رفتار سؤال‌برانگیزش، مشکلی ندارد. او با بهانه‌های مختلف خودش را فریب می‌دهد. هر دلیل و بهانه، دروغ‌های جدیدی به دنبال دارد. در نگاه سوم‌شخص بی‌طرف، مانند روانکاو، انکار مرد خیانت‌کار مثل سستی خانه‌ای پوشالی در جریان نسیمی شدید است. اما آنها لجوجانه اصرار دارند که دلایل‌شان منطقی است.تاثیر وفاداری در افراد وفادار بودن باعث آرامش فکر و ذهن‌تان می‌شود. دیگر نیازی به پنهان‌کاری نخواهید داشت و لازم نیست تک‌تک دروغ‌هاتان را هم به خاطر بسپارید     وفاداری باعث می‌شود بهترین الگو برای فرزندان‌تان باشید. بچه‌ها از اعمال و رفتار ما درس می‌گیرند.     وفادار بودن تأثیر مثبتی بر شخصیت‌تان خواهد داشت. با این روش می‌توانید با اعتمادبه‌نفس بیشتری زندگی کنید. راستی و درستی اهمیت زیادی دارد، می‌توانید آن را از زندگی شخصی‌تان شروع کنید. اگر در زندگی شخصی‌تان راست و درست رفتار نکنید، خواهید دید که کل زندگی‌تان فرو می‌پاشد.     افراد وفادار شادتر، آرام‌تر و راضی‌تر هستند و بیشتر لبخند می‌زنند. وجدان‌شان آسوده و زندگی‌شان از استرس، خلاء و پیچیدگی به دور است.     وفادار بودن باعث می‌شود همسرتان به شما اعتماد کند و با این اعتماد صددرصد خودش را در اختیارتان قرار خواهد داد و درمقابل می‌توانید شناخت بهتری از او پیدا کنید. بدون اعتماد نخواهید توانست از تمام محبت‌های همسرتان بهره‌مند شود.     وفادار نبودن هیچ فایده‌ای برایتان نخواهد داشت و هیچ پاداشی در انتها انتظارتان را نمی‌کشد. نتیجه‌ی آن فقط درد، پشیمانی و نابودی است. فقط خودخواهی‌تان را بیشتر کرده و کورتان می‌کند.    کسی که با او به همسرتان خیانت می‌کنید صلاح شما را نمی‌خواهد و فقط می‌خواهد نیازها و خودخواهی خودش را ارضا کند. او اصلاً متوجه خرابی‌هایی که وارد زندگی شما می‌کند نیست. بله، ممکن است با هم احساس نزدیکی کنید یا حتی به هم ابراز علاقه کنید، ولی هر دو شما مجرمانی هستید که دست به جنایت زده‌اید. آن فرد مشکلات شخصی خودش را دارد و به همین دلیل است که به تعهد قانونی شما احترام نمی‌گذارد. شما هم از روی نادانی اجازه می‌دهید گمراه‌تان کند.      هیجان خیانت خیلی زود از بین می‌رود. در ابتدای کار ممکن است احساس هیجان و لذت کنید. با طرف‌تان قرارهای مخفیانه می‌گذارید و لذت می‌برید ولی خیلی زود متوجه خواهید شد که اشتباه کرده‌اید.بعد برمی‌گردید به سمت همسرتان، به گنج گرانبهایی که نادیده‌اش گرفته بودید ولی دیگر کار از کار گذشته است. چیزی بسیار پرارزش را به‌خاطر چیزی بی‌معنی و کم‌اهمیت خراب کرده‌اید.    ",
            "url": "/documentation/marriage/betrayal"
          }
          ,
        
          "documentation-marriage-life-skills" :{
            "title": "مهارت زندگی و سازگاری",
            "content": " تعریف مهارت های زندگی   توانایی هایی هستند که به ما کمک می کنند در موقعیت های گوناگون، عاقلانه و درست رفتار کنیم؛ به طوری که با خود و دیگران سازگارانه ارتباط برقرار کرده بدون استفاده از خشونت بتوانیم مسایل پیش آمده را حل نماییم و ضمن به دست آوردن موفقیت در زندگی، احساس شادمانی داشته باشیم.برای بهتر شدن درک مفهوم مهارت‌های زندگی باید از دو نگاهی حرف بزنیم که درباره زندگی وجود دارد.در یک نگاه ایده‌آلی، زندگی خوب، زندگی‌ای است که در آن هیچ تنشی وجود ندارد و هیچ دست‌اندازی، زندگی فرد را دچار تشویش نمی‌کند. فرد در موقعیتی رویایی زندگی می‌کند و هیچ‌گونه گرفتاری و کشمکشی نمی‌تواند زندگی او را دچار تغییر کند. اما یک نگاه دیگر نیز وجود دارد که اساس زندگی را با ناراحتی و سوگ، از دست‌دادن و کشمکش عجین می‌داند. این‌که با گذشت هر روز، یک روز از عمرمان از دست می‌رود و پیرتر می‌شویم، هر چند وقت یکبار متوجه موی سفیدی می‌شویم و چین و چروک‌های صورتمان را نگاه می‌کنیم.وقتی پذیرفتیم که زندگی همیشه و در همه موقعیت‌ها، خوشایند نیست، باید راهی را انتخاب کنیم که به وسیله آن آرامش بیشتری داشته باشیم.در بارزترین شکل ما معتقدیم زمان و سلامتی‌مان هر روز برای ادامه زندگی کمتر می‌شود. از طرف دیگر مدام در زندگی با این مسأله روبه‌رو هستیم که باید از خواسته‌هایمان بگذریم و با خود مرور می‌کنیم که جمع‌شدن خیلی از خواسته‌هایمان باهم، سازگاری ندارد.حالا اگر قرار باشد این دو نگاه را کنار یکدیگر بگذاریم و بعد از مهارت‌های زندگی حرف بزنیم، باید بگوییم مهارت‌های زندگی در وهله اول، پذیرش نگاه دوم و قبول آن است. بعد وقتی پذیرفتیم که زندگی همیشه و در همه موقعیت‌ها، خوشایند نیست، باید راهی را انتخاب کنیم که به وسیله آن آرامش بیشتری داشته باشیم.مهارت زندگی به ما یاد می‌دهد که چه راهی را باید انتخاب و چگونه باید زندگی کرد تا سازگاری بیشتری به دست آورد و آرامش بیشتری داشت تا بتوان از آن لذت برد.مهارت‌های زندگی ساختن یک شهر رویایی نیست که در آن هیچ گرفتاری وجود ندارد و سوگ، تلخی و ناکامی در آن بی‌معناست بلکه بخش مهمی از مهارت‌های زندگی کنار آمدن با همین تلخی‌هاست که عنصر مهمی در ساخت زندگی است و کسی که می‌تواند سازگار‌تر باشد درواقع مهارت بهتری دارد.در مجموع می‌توان گفت آدم‌هایی که مهارت بهتری دارند بهتر با ناکامی‌ها کنار می‌آیند، تنش‌های خود را حل می‌کنند و راه‌حل‌های گوناگونی دارند و می‌توانند آن را در شرایط مختلف استفاده کنند.  مهارت زندگی در ازدواج   ازدواج پیوندی است که انتظار می‌رود روزبه‌روز مستحکم‌تر شود و تا ابد ناگسستنی باقی بماند. این در حالی است که پیوند بسیاری از زوج‌ها در اثر ناملایمات زندگی سست می‌شود و در موارد حاد به جدایی می‌انجامد. در واقع، نافرجامی اغلب زندگی‌های مشترک به علت عدم تسلط طرفین بر مهارت‌‌ های زندگی زناشویی است و از بی‌توجهی به پیش‌نیازهای مهارتی ازدواج موفق ناشی می‌شود.    زندگی مشترك پهنه وسیعی از فرصت‌هاست كه زوجین با آرامش و حساب شدگی، مشكلات را پایان كار نمی‌دانند بلكه آنها را بهانه و فرصتی برای آغاز جدید می‌دانند و با همدلی و هم‌كوشی درصدد حل آنها برمی‌آیند و به هیچ وجه واقع بینی خود را قربانی ایده‌آل‌نگری نمی‌كنند.    زن و مردی كه به تازگی تشكیل زندگی داده‌اند از تجربه كافی برای حل مشكلات برخوردار نیستند و معمولا بر آتش‌های كوچك و بزرگ پدید آمده، نفت و بنزین احساسی عمل كردن می‌ریزند و حتی همان هفته‌های اول و ماه‌های اول به این نتیجه می‌رسند كه ازدواج ما از اول اشتباه بوده است و بی‌جهت نیست كه در سه سال اول زندگی پدیده پرآسیب طلاق شكل می‌گیرد.    بله، ازدواج اقدامی جدی است که آمادگی و مهارت‌های خاص خودش را می‌طلبد. دوران آشنایی پیش از ازدواج فرصت مناسبی است تا این مهارت‌‌ها را که لازمه‌ی ازدواج موفق شمرده می‌شوند، تمرین کنید و آمادگی خود را برای حضور در زندگی مشترک بالا ببرید. این دوران به هر حال با زندگی در زیر یک سقف تفاوت‌هایی دارد، اما همان‌طور که گفته شد فرصت قابل تأملی برای پرورش مهارت‌ های زندگی زناشویی است.    هر چه افراد با دانش و آگاهی بیشتری زندگی زناشویی خود را آغاز کنند، در مدیریت بحران ها و چالش هایی که در این راه با آن مواجه می شوند آماده تر میشوند، چرا که در این مسیر پر پیچ و خم زوجین ممکن است با مشکلات زیادی مواجه شوند. لازمه این آگاهی خودشناسی و شناخت بیشتر تفاوت های زن و مرد است.     آگاهی از تفاوت های جنسیتی تقویت کننده مهارت های لازم برای ازدواج     خوشحال بودن با شریک زندگی نیازمند آگاهی از تفاوت های میان زنان و مردان است. چرا که عدم آشنایی با این تفاوت ها مانند وارد شدن به دنیایی ناشناخته است. در ادامه تنها دو  مورد از این تفاوت ها توضیح داده شده است:        استقلال طلبی در مردان اولویت است:   در مردان نیاز به استقلال طلبی معمولا نسبت به زنان بیشتر است. مردان در زندگی دوست دارند بیشتر روی پای خود بایستند و از هر وابستگی دوری کنند. به طور ذاتی مردان دوست دارند که کنترل شرایط را در دست داشته باشند و چالش ها و مسائل مختلف را مدیریت کنند.          حمایت شدن در زنان اولویت است:         زنان نسبت به مردان از لحاظ عاطفی حساس ترند و نیاز به حمایت بیشتری نسبت به مردان دارند. به همین علت مسئله حمایت شدن در زنان از اهمیت زیادی برخوردار است. زنان از بی توجهی آزرده خاطر میشوند. مناسبت های مهم مانند تاریخ تولد، ازدواج و ... برای زنان از اهمیت ویژه ای برخوردار است.            کاربرد مهارت های لازم برای ازدواج در زندگی   یادگیری مهارت های لازم برای ازدواج، فرصتی مناسب است که از بایدها و نبایدهای رابطه زناشویی آگاه شوید. به عنوان مثال در مورد اینکه چه حرف هایی را نباید به همسر زد یا اینکه کنترل شوهر و عدم توجه به زن چه پیامدهای منفی در رابطه زناشویی برجای خواهد گذاشت. در ادامه به برخی از مهم ترین مهارت های لازم برای ازدواج اشاره میکنیم:    1-\tمهارت همدلی :    مهارت همدلی کردن بدین معناست که قادر باشید پاسخ عاطفی مناسب موقعیت به طرف مقابل بدهید. یعنی بتوانید از زاویه دید همسرتان به مسائل نگاه کنید و احساسات او را درک کنید. برای کسب مهارت همدلی باید سعی کنید خوب به یکدیگر گوش دهید تا از نگرانی ها و دغدغه های یکدیگر با خبر شوید.    2-\tمهارت گفتگو :  با هم صحبت كنید. این مهارت یكی از عوامل بسیار مهم در ارتباط موثر و رفع مسائل و مشكلات زندگی است. این امر، همچون كلیدی، بسیاری از درهای صمیمیت را به روی زوجین باز می‌كند و هنری است كه از طریق آن می‌توان از كاهش محبت و سوء تفاهم در زندگی مشترك پیشگیری نمود. در یك گفتگوی صحیح بایستی هر فرد برای برقراری ارتباط كارآمد مهارت‌هایی را در خود ایجاد نماید، كه در ذیل به آنان اشاره می‌شود:    اینگونه سخن بگوییم :       ابتدا در خصوص سخن مورد نظر تامل كنید.         به نرمی و تواضع همراه با خوشخویی، در فضای مهر و محبت و نه خشم و عصبانیت سخن بگویید.               از سخن بیهوده گفتن و پرگوئی بپرهیزید و در موضوع مشكلتان حرف بزنید.                  اگر لازم است كه در خصوص موضوع مورد نظر مفصل سخن به میان آید بایستی موقعیت و شرایط بیان سخن اثرگذار فراهم شده باشد.                          سعی كنید تا حدامكان سخنان را كوتاه و مفید مطرح كنید.                                برسخنتان تسلط لازم را داشته باشید و آنان را شمرده بیان كنید.                                      سخنتان همراه با نرمی باشد و آن را در قالبی نیكو «براساس موقعیت مورد نظر» آراسته نمایید.                                            از سخنان زشت كه روش انسا‌ن‌های خود باخته است جدا پرهیز نمایید.                                                 عاقل باشید و اگر موضوعی است كه برایتان مهم است كه مطرح شود، نترسید و با درایت آن را بیان كنید.                                                         مراقب باشید كه با حفظ آرامش و تدبیر از شیوه‌ی نامناسب یا كلماتی كه باعث سوء برداشت می‌شود پرهیز نمایید.                                                              به دقت به سخنان طرف مقابل گوش دهید و نسبت به آنها واكنش مناسب نشان دهید.                                                                     از مجموع سخنانتان در پایان، یك جمع‌بندی و نتیجه‌گیری روشن داشته باشید.                                                     اینگونه سوالات بپرسیم:    به همسرتان بگویید كه به او اطمینان دارید و با پاسخ سوالی كه در ذهن شما ایجاد شده، به نشاط و آرامش می‌رسید.     آن را شایسته و درست مطرح كنید چرا كه پرسش خوب، نیمی از آگاهی را برای شما فراهم می‌سازد.        هدف از پرسیدنتان فهمیدن و درك حقیقت باشد نه برای آزردن و درمانده كردن طرف مقابل.           درباره مسائل بی‌فایده از همسرتان سۆال نكنید. از لقمان پرسیدند: دانائی و حكمت تو چیست؟ گفت: از چیزی كه به آن نیاز ندارم سوال نمی‌كنم و به آنچه بیهوده است نمی‌پردازم.              در مورد پاره‌ای موضوعات كه پاسخ صریح آن باعث شرمندگی می‌شود خودداری شود.           اینگونه گوش كنیم    برای گوش دادن فعال باید با تمام وجود به صحبت های طرف مقابلتان توجه داشته باشید؛ تا او یقین داشته باشد که به او گوش می دهید و برایش ارزش قائل هستید. همچنین سعی کنید به همسرتان بازخورد دهید و نشان دهید که مطلبی که درباره اش صحبت می کند برایتان مهم است    اشتیاق خود را نسبت به شنیدن مسائلی كه برای زندگی و خصوصا همسرتان مهم است، نشان دهید.     پس از گوش كردن به تغییرات مفیدی كه لازم است ایجاد شود عمل كنید! یادتان باشد این امر نشانه اهمیت دادن شما نسبت به همسرتان است و باعث افزایش حس اعتماد محبت در روابط می‌شود.        خوب به سخن همسرتان گوش كنید و پیش از آنكه مفهوم مدنظر او را به درستی نیافته‌اید قضاوت نكنید.           از عواملی كه سبب عدم تمركز بر روی سخن همسرتان می‌شود پرهیز كنید.            در برابر سخن همسر خود فروتن و صبور باشید و به سخن او دل دهید.           داشتن یگ گفتگوی صحیح  صحبتتان را در موقعیتی مناسب و اثرگذار با همسرتان مطرح كنید              سخنانتان را بگویید نه با هدف اثبات نظر خودتان، بلكه با این هدف كه حق و حقیقت را متوجه شوید.               دنبال این نباشید كه حق توسط شما حتما باید آشكار شود بلكه اگر متوجه شدید خطا با شما بوده بپذیرید، خدا را شكر كنید و از همسرتان تشكر كنید.               سعی كنید صحبت‌هایتان درباره واقعه‌ای مهم كه اتفاق افتاده یا به زودی روی خواهد داد باشد.                با یكدیگر در خلوت و مكان مناسب گفت‌وگو كنید.               اجازه دهید همسرتان دلایل خود و سوالاتی را كه در ذهن دارد با آزادی و آرامش بیان كند.              در بین سخنان همسرتان به دنبال مطالبی باشید كه شما را به حقیقت نزدیك می‌كند.               هدفتان خیرخواهی باشد. و منطقی و خالی از هرگونه تعصب و لجاجت با همسرتان گفتگو كنید.                    از «جدال» كه زور گفتن و قبول نكردن حق و دلایل منطقی است دوری كنید زیر باعث می‌شود احترامتان را از دست بدهید.            3 - توجه به احساسات و هیجانات طرف مقابل :    ابراز احساسات و نشان دادن محبت به همسر، به منظور تجربه رابطه ای سرشار از شادی و نشاط توصیه میشود. این مسئله به خصوص زمانی که چند سال از زندگی مشترک گذشته است و به منظور برگرداندن عشق به رابطه عاطفی لازم است. توجه به این مسئله به خصوص در مردان بسیار اهمیت دارد؛ چرا که برخی از مردان گمان میکنند لازم نیست هیجانات یا عشق خود را ابراز کنند و همین که برای زندگی مشترک تلاش زیادی میکنند یا در عمل نشان میدهند کافی است.   4 - مهارت حل تعارض و مدیریت روابط :  مسلما هر زوجی در زندگی زناشویی با اختلافاتی مواجه میشوند، آنچه اهمیت دارد این است که بتوانید تعارض های پیش آمده را به درستی مدیریت کنید. در مورد کلیه مشکلات بوجود آمده بین خودتان صحبت کنید؛ اما از فریاد زدن و پرخاشگری پرهیز کنید. اینکه در زمان مناسب به اختلاف خود و طرف مقابل رسیدگی کنید بسیار مهم است. عذرخواهی کردن مهارت دیگری ست که باید تقویت کنید. هیچ شخصی کامل نیست؛ هر فردی در زندگی ایراداتی دارد و شما با پذیرش نقص هایتان و تلاش برای رفع آنها می توانید روابط خود را مدیریت کنید.   لجاجت را كنار بگذاریم  در یك ارتباط موثر زوجین باید از یك‌دندگی و اصرار بر نظر خود به جد پرهیز كنند و در مقابل برای حل مسائل زندگی، منش حق‌گرایی و خطاپذیری را داشته باشند. اگر می‌خواهید در زندگی مشترك، آرامش و نشاط داشته باشید با ترك لجبازی به این امر كمك خواهید كرد.  5 - تعریف و تحسین واقعی :  اینکه صادقانه از طرف مقابل تعریف کنید و ویژگی های مثبت او را یادآور شوید، می تواند به افزایش حس همدلی کمک کند. اما این تعاریف باید واقعی و به دور از بزرگ نمایی بوده و غلو آمیز نباشد. از همسرتان به خاطر تمام تلاش هایی که برای زندگی مشترک انجام میدهد، تشکر کنید.  6- مهارت حل مسئله و تصمیم گیری درست  :  مهارت حل مشکلات به نوعی مهم‌ترین مهارت این فهرست است، زیرا اگر بر این مهارت خاص مسلط نباشید، اوضاع به قدری آشفته می‌شود که دیگر اهمیتی نخواهد داشت تا چه حد در سایر مهارت‌ها توانا هستید. مهارت حل مشکلات یعنی اینکه اگر در موضوعی با همسرتان اختلاف نظر داشتید، بتوانید به مصالحه برسید. به‌عبارت دیگر، باید یاد بگیرید که موقعیت را بسنجید و ببینید که آیا لازم است روی موضع خود پافشاری کنید یا عاقلانه‌تر است که از موضع خود کوتاه بیایید. به عقیده‌ی دیکسون، عدم تسلط کافی بر این مهارت موجب دشواری زندگی مشترک به‌ویژه در دو سال نخست ازدواج می‌شود، چراکه طرفین در سال‌های نخست سعی دارند تا با راه و روش یکدیگر در حل مشکلات آشنا شوند و به طریقی با رویکرد طرف مقابل کنار بیایند. در واقع، در همین دو سال نخست ازدواج است که متوجه خواهید شد در زندگی مشترک نمی‌توانید همیشه حرف خودتان را به کُرسی بنشانید!  7- مقدم دانستن همسر :   بعد از ازدواج باید به این موضوع توجه کنید که نفر اول زندگی شما همسرتان است. با رعایت نکات مهم همسرداری میتوانید زندگی با ثبات و آرامبخشی را برای همسر و فرزندانتان فراهم کنید. البته این بدان معنا نیست که به عزیزان و فرزندانتان توجهی نداشته باشید ولی حفظ یک رابطه خوب با همسرتان پیش نیاز رشد و شکوفایی فرزندان و همچنین آسودگی خانواده تان است.   دیکسون معتقد است اول خدا و بعد همسر؛ او همسر را بر فرزندان، شغل، والدین، آشنایان و هر چیز یا هرکس دیگری مقدم می‌داند:  خداهمسرفرزند   دیکسون ادعا می‌کند همسرش را که همه کسِ اوست، تحت هیچ شرایطی به جایگاه‌های بعدی تنزل نمی‌دهد و حتی در مواقعی که همسرش دچار گرفتاری یا بحران خاصی می‌شود و به‌عبارتی حال و روز خوشی ندارد، هم‌چنان اولویت زندگی دیکسون باقی می‌ماند، زیرا خودش نیز انتظار دارد که همیشه نخستین اولویت همسرش در خلال مشغله‌های زندگی باشد.  8- رفتار خلاقانه در ازدواج :  سعی کنید برای پیشگیری از یکنواختی درزندگی تان، خلاقیت به خرج دهید. برای تجربیات مشترک جدید و جذاب برنامه ریزی کنید. برای سرگرمی و تفریحات خودتان زمان بگذارید مثلا با هم به پیاده روی و یا دوچرخه سواری بروید و... چرا که به تداوم یافتن رابطه شما کمک زیادی میکند.  فقط در اندیشه‌ی رابطه‌ی زناشویی امروز خود نباشید، بلکه باید به راهکارهای دوام و بهبود این رابطه در سال‌های آینده نیز بیندیشید. مثلا از خودتان بپرسید:    چی کار می‌تونم بکنم که همسر ایده‌آل‌تری باشم؟  چی کار می‌تونم بکنم که پنج سال دیگه هم به چشم همسرم جذاب به‌نظر برسم؟   بهتر نیست تحصیلاتم رو ادامه بدم؟   بهتر نیست یه کسب‌و‌کاری راه بندازم که مال خودم باشه؟   چطوری می‌تونم به همسرم نشون بدم که توی سختی‌ها پشتش هستم؟    دیکسون توصیه می‌کند که در زندگی نسبت به تغذیه‌ سالم، سلامتی و طول عمر، آینده‌نگری اقتصادی، پس‌انداز و پیشرفت شغلی بی‌اهمیت نباشید تا بتوانید آینده‌ی دلپذیرتری را برای خودتان و همسرتان رقم بزنید. خلاصه اینکه همه‌ی تلاش‌تان را به‌کار بگیرید تا برای شریک زندگی‌ خود همسر شایسته‌‌تری باشید.   9- از یكدیگر عیب‌جویی و سرزنش نكنیم :  در زندگی خانوادگی، زن و مرد بایستی بدی‌های یكدیگر را نادیده بگیرند. نقص زن، نقص مرد است و نقص مرد، نقص زن است و باید در روابطمان، نقص‌پوش باشیم. همچنان كه قرآن زن و مرد را لباس هم معرفی كرده است.  اگر خواهان محبت و حل مسائل در خانه هستیم باید منفی‌باف نباشیم. اگر به اشكال یا نقصی در طرف مقابلمان رسیدیم؛ نباید نگاه نقطه‌ای داشته باشیم و تمام تمركزمان را به آن معطوف كنیم بلكه آن را در كنار خوبی‌ها و قوت‌های او ببینیم و گاهی به نقص‌ها و عیوب خودمان هم توجه كنیم تا بتوانیم از سرزنش كردن و عیب‌جو بودن فاصله بگیریم.  وقتی پیمان ازدواج می‌بندید، لازم است که توانایی بخشش را در خود تقویت کنید و بتوانید خیلی زود ببخشید. اگر همسرتان خطایی مرتکب شد و عذرخواهی کرد، به خودتان گوشزد کنید که هیچ‌کس کامل نیست و قطعا خودتان نیز نقص‌هایی دارید و گاهی مرتکب خطا می‌شوید. درصورتی‌که در این مهارت حیاتی ضعیف هستید، حتما از یک شخص آگاه و متخصص راهنمایی و مشاوره بگیرید. هنگامی که از توانایی بخشش عاجز می‌شوید، درست همان لحظه است که ادامه‌ی ازدواج‌تان به بن‌بست می‌خورد.     یادتان باشد که خیلی اوقات دوام یک رابطه بدون بخشش ممکن نیست. دیکسون به کسانی که هیچ سررشته‌ای از این مهارت ندارند یا به هر علتی قادر به بخشش نیستند، یادآور می‌شود که مجرد بمانند!      10- احترام و اعتملد متقابل : اگر زوجین چه در محیط خانه و چه در جمع دوستان و فامیل همواره احترام همدیگر را حفظ كنند و پشتیبان همدیگر باشند، هم اعتمادشان نسبت به یكدیگر افزایش می‌یابد و هم هیچ‌كس به خود اجازه دخالت در زندگی آنان را نمی‌دهد. یادمان باشد صمیمیت زوجین همراه با حفظ حریم و رعایت ادب، یكی از مهم‌ترین مهارت‌های رفتاری برای حل مشكلات زندگی زناشویی است.     11- تمرکز روی خصوصیات مثبت :    سعی کنید روی نقاط قوت همسر خود تمرکز کنید نه اینکه فقط و فقط رفتارهای آزاردهنده‌اش را ببینید. شاید از بعضی خصوصیات همسرتان ناراضی باشید، اما قطعا خصوصیات خوشایندی نیز در او سراغ دارید که عاشقش شدید. به عقیده‌ی دیکسون، احتمالا کفه‌ی خصوصیات مثبت همسرتان از کفه‌ی خصوصیات منفی او سنگین‌تر است، که اگر جز این بود رابطه‌تان به ازدواج ختم نمی‌شد. پس تا حد امکان روی خصوصیات دل‌پسندی که دو نفرتان را به‌هم رساندند، تمرکز کنید و خوبی‌های همسرتان را به‌خاطر کفه‌ی دیگر ترازو نادیده نگیرید.     12- باور قلبی به نیک‌بختی : باید عمیقا باور داشته باشید که ازدواج‌تان پایدار خواهد ماند و هرگز قرار نیست به گزینه‌ی طلاق فکر کنید. باید بتوانید اطمینان خاطر داشته باشید که همسرتان نیز به‌اندازه‌ی شما عاشق‌ است. دیکسون توضیح می‌دهد که شاید گاهی عشق همسرتان را به وضوح احساس نکنید، اما باید بدانید که عاشق‌تان است و بتوانید عشقش را باور کنید. هر دوی شما باید بدون ذره‌ای تردید اطمینان خاطر داشته باشید که دیگری از عمل به هیچ کدام از وعده‌های خود شانه خالی نخواهد کرد. با این اطمینان متقابل می‌توانید خاطرجمع باشید که زندگی‌تان با هر تنشی رو به نابودی نخواهد رفت. این طرز فکر به همسرتان نیز منتقل می‌شود و قبل از اینکه متوجه شوید، رابطه‌تان دوباره روی غلتک می‌افتد.      13- ظرفیت شناخت مجدد : شاید یک زمانی تصور کنید که همسرتان را خیلی خوب می‌شناسید، اما اینکه فقط یک‌بار همسرتان را خوب بشناسید کافی نیست، چراکه ما انسان‌ها در طول زندگی تغییر می‌کنیم و به‌تدریج پخته‌تر می‌شویم و به شناخت مجدد یکدیگر نیاز داریم. مثلا ممکن است به خودتان بیایید و ببینید همسرتان در ۴۰ سالگی با ۲۸ سالگی‌اش فرق دارد، اما این تفاوت‌ها توجیه مناسبی برای طلاق نیستند. در طول زندگی مشترک لازم است که همسرتان را دوباره بشناسید و مجددا در مورد بعضی خصوصیاتش که با گذشت سال‌ها تغییر کرده‌اند، شناخت پیدا کنید. بنابراین تا زمانی که مایل به بازشناسی همسر آینده‌تان نباشید، یعنی اینکه از صلاحیت ازدواج برخوردار نیستید!       14- رفتار متأهلی :    دیکسون هشدار می‌دهد که بعد از ازدواج نباید طوری رفتار کنید که هم‌چنان مثل مجردها به‌نظر برسید، بلکه باید با کردارتان سعی کنید که به چشم همه‌ی دنیا یک فرد متأهل خوشبخت دیده شوید، البته خوشبخت واقعی و نه با تظاهر! یادتان باشد فرد متأهلی که مثل مجردها رفتار کند، دیر یا زود با عواقب دردسرسازی در زندگی زناشویی خود مواجه خواهد شد. زندگی متأهلی این نیست که مثل مجردها رفتار کنید و فقط هر وقت عشق‌تان کشید به اخلاق و کردار متأهلی روی بیاورید!          15- جدال منصفانه :   شاید بعضی روزها خودتان را در وضعیتی بیابید که انگار چاره‌ی دیگری جز جدال ندارید، اما یادتان باشد که اگر حالت تدافعی به خود می‌گیرید حتما منصفانه و هدفمند وارد بحث شوید و بحث را خیلی کِش ندهید. ابتدا اطمینان حاصل کنید که برای این حالت تدافعی علت موجهی وجود داشته باشد. فقط کافی است نقطه نظرات‌تان را اعلام کنید و اگر همسرتان موافقت نکرد، حداقلش این است که حرف‌تان را شنیده است و اگر به شما علاقه‌مند باشد، مطمئنا سعی خواهد کرد به طریقی رضایت‌تان را جلب کند. اگر ناعادلانه وارد بحث شوید، طرف مقابل در جهت جلب رضایت‌تان هیچ قدمی برنخواهد داشت. این در حالی است که اگر محترمانه عمل کنید، طرف مقابل متقاعد خواهد شد که با یکدیگر به مصالحه برسید. حتی اگر حق با شما باشد اما تحریک‌آمیز حمله کنید، شکی نیست که همسرتان به آنچه باعث ناراحتی‌تان شده است ادامه خواهد داد.    زندگی مشترکی که با تسلط بر این مهارت‌ها اداره شود، فواید بی‌شماری به همراه خواهد داشت. نشاط، احترام و اعتماد متقابل، زندگی باثبات، حمایت دوطرفه و عشق بی‌قید‌وشرط ازجمله‌ی بارزترینِ این فواید به شمار می‌روند. پس فرصت را از دست ندهید و هرچه زودتر پیش از ازدواج، مهارت‌هایی را که مرور کردیم تمرین کنید. البته اگر متأهل هستید و تا به حال از اهمیت مهارت‌‌ های زندگی زناشویی آگاه نبوده‌اید، باز هم جای امیدواری است که می‌توانید با یادگیری و تمرین این مهارت‌ها حین زندگی مشترک از گسستن پیمان ازدواج‌تان جلوگیری کنید.  ",
            "url": "/documentation/marriage/life-skills"
          }
          ,
        
          "documentation-vuejs-components-in-depth-components-props" :{
            "title": "props",
            "content": "Prop Casing (camelCase vs kebab-case)نام ویژگی های HTML نسبت به حروف کوچک و بزرگ حساس نیستند ، بنابراین مرورگرها هر حرف بزرگ را به صورت کوچک تفسیر می کنند. این بدان معنی است که وقتی از الگوهای in-DOM  استفاده می کنید ، نام هایprop  که بصورت  camelCased  معرفی می شوند باید از معادل kebab-cased (جدا شده با خط فاصله) استفاده کنند.Vue.component('blog-post', {  // camelCase in JavaScript  props: ['postTitle'],  template: ''})&#x3C;!-- kebab-case in HTML --&#x3E;&#x3C;blog-post post-title=&#x22;hello!&#x22;&#x3E;&#x3C;/blog-post&#x3E;باز هم ، اگر از الگوهای رشته استفاده می کنید ، این محدودیت اعمال نمی شود.  انواع Prop  (Prop Types)تاکنون ، ما فقط لیست prop هایی را مشاهده کرده ایم که به عنوان آرایه ای از رشته ها لیست شده اند:props: ['title', 'likes', 'isPublished', 'commentIds', 'author']معمولاً ، شما می خواهید هر یک از prop  ها دارای نوع خاصی از مقدار  باشد. در این موارد ، شما می توانید لیست prop ها  را به عنوان یک object فهرست کنید:props: {  title: String,  likes: Number,  isPublished: Boolean,  commentIds: Array,  author: Object,  callback: Function,  contactsPromise: Promise // or any other constructor}با اینکار نه تنها کامپوننت شما مستند می شود ، بلکه در صورت استفاده نوع اشتباه ، به کاربران در کنسول جاوا اسکریپت مرورگر نیز هشدار می دهد.  می توانید در مورد نوع بررسی و سایر اعتبار سنجی ها     type checks and other prop validationsاطلاعات بیشتری کسب کنید. Passing Static or Dynamic Propsتاکنون مشاهده کرده اید که prop  ها  یک مقدار ثابت را عبور می دادند ، مانند:&#x3C;blog-post title=&#x22;My journey with Vue&#x22;&#x3E;&#x3C;/blog-post&#x3E;همچنین شما prop  هایی را دیده اید که با استفاده از v-bind  به صورت پویا ثبت شده اند ، مانند:&#x3C;!-- Dynamically assign the value of a variable --&#x3E;&#x3C;blog-post v-bind:title=&#x22;post.title&#x22;&#x3E;&#x3C;/blog-post&#x3E;&#x3C;!-- Dynamically assign the value of a complex expression --&#x3E;&#x3C;blog-post  v-bind:title=&#x22;post.title + &#x27; by &#x27; + post.author.name&#x22;&#x3E;&#x3C;/blog-post&#x3E;در دو مثال بالا ، ما مقادیر رشته ای را منتقل کردیم ، اما هر نوع از مقدار می تواند به یک prop منتقل شود.Passing a Number&#x3C;!-- Even though &#x60;42&#x60; is static, we need v-bind to tell Vue that --&#x3E;&#x3C;!-- this is a JavaScript expression rather than a string.       --&#x3E;&#x3C;blog-post v-bind:likes=&#x22;42&#x22;&#x3E;&#x3C;/blog-post&#x3E;&#x3C;!-- Dynamically assign to the value of a variable. --&#x3E;&#x3C;blog-post v-bind:likes=&#x22;post.likes&#x22;&#x3E;&#x3C;/blog-post&#x3E;Passing a Boolean&#x3C;!-- Including the prop with no value will imply &#x60;true&#x60;. --&#x3E;&#x3C;blog-post is-published&#x3E;&#x3C;/blog-post&#x3E;&#x3C;!-- Even though &#x60;false&#x60; is static, we need v-bind to tell Vue that --&#x3E;&#x3C;!-- this is a JavaScript expression rather than a string.          --&#x3E;&#x3C;blog-post v-bind:is-published=&#x22;false&#x22;&#x3E;&#x3C;/blog-post&#x3E;&#x3C;!-- Dynamically assign to the value of a variable. --&#x3E;&#x3C;blog-post v-bind:is-published=&#x22;post.isPublished&#x22;&#x3E;&#x3C;/blog-post&#x3E;Passing an Array&#x3C;!-- Even though the array is static, we need v-bind to tell Vue that --&#x3E;&#x3C;!-- this is a JavaScript expression rather than a string.            --&#x3E;&#x3C;blog-post v-bind:comment-ids=&#x22;[234, 266, 273]&#x22;&#x3E;&#x3C;/blog-post&#x3E;&#x3C;!-- Dynamically assign to the value of a variable. --&#x3E;&#x3C;blog-post v-bind:comment-ids=&#x22;post.commentIds&#x22;&#x3E;&#x3C;/blog-post&#x3E;Passing an Object&#x3C;!-- Even though the object is static, we need v-bind to tell Vue that --&#x3E;&#x3C;!-- this is a JavaScript expression rather than a string.             --&#x3E;&#x3C;blog-post  v-bind:author=&#x22;{    name: &#x27;Veronica&#x27;,    company: &#x27;Veridian Dynamics&#x27;  }&#x22;&#x3E;&#x3C;/blog-post&#x3E;&#x3C;!-- Dynamically assign to the value of a variable. --&#x3E;&#x3C;blog-post v-bind:author=&#x22;post.author&#x22;&#x3E;&#x3C;/blog-post&#x3E;Passing the Properties of an Objectاگر می خواهید تمام خصوصیات یک شی را به prop منتقل کنید ، می توانید از v-bind بدون آرگومان استفاده کنید v-bind به جای  v-bind: prop-name . به عنوان مثال:post: {  id: 1,  title: 'My Journey with Vue'}الگوی زیر :&#x3C;blog-post v-bind=&#x22;post&#x22;&#x3E;&#x3C;/blog-post&#x3E;معادل است با :&#x3C;blog-post  v-bind:id=&#x22;post.id&#x22;  v-bind:title=&#x22;post.title&#x22;&#x3E;&#x3C;/blog-post&#x3E;جریان داده یک طرفه (One-Way Data Flow)همه prop  ها از یک اتصال یک طرفه بین ویژگی های فرزند و والد  شکل می گیرند: وقتی ویژگی والد به روز شود ، به سمت فرزند  حرکت می کند ، اما برعکس اینچنین نیست. این باعث می شود کامپوننت های  فرزند  به طور تصادفی وضعیت والدین را تغییر ندهند ، که باعث می شود جریان داده های برنامه شما دشوارتر باشد.علاوه بر این ، هر بار که  کانپوننت  والد به روز شود ، تمام prop  ها در کامپوننت فرزند با آخرین مقدار تازه می شوند. این بدان معناست که شما نباید prop  یک کامپوننت  فرزند را تغییر دهید. اگر این کار را انجام دهید ، Vue در کنسول به شما هشدار می دهد.معمولاً دو حالت وجود دارد که وسوسه انگیز است که یک prop را تغییر دهید: از prop برای عبور مقدار اولیه استفاده شود. بعد از آن ، کامپوننت فرزند از آن به عنوان یک ویژگی داده محلی استفاده می کند. در این حالت ، بهتر است یک ویژگی داده محلی را تعریف کنید که از prop به عنوان مقدار اولیه خود استفاده کند:props: [&#x27;initialCounter&#x27;],data: function () {  return {    counter: this.initialCounter  }}چنانچه بخواهیم prop به عنوان یک مقدار  raw  منتقل شود که  نیاز به تغییر دارد. در این حالت ، بهتر است یک ویژگی computed را با عنوان مقدار prop تعریف کنید:props: [&#x27;size&#x27;],computed: {  normalizedSize: function () {    return this.size.trim().toLowerCase()  }}توجه داشته باشید که objects  و arrays در JavaScript با استفاده از مرجع منتقل می شوند ، بنابراین اگر prop یک آرایه یا شی باشد ، تغییر دادن شی یا آرایه درون  کامپوننت فرزند بر وضعیت والد تأثیر می گذارد.Prop Validationکامپوننت ها می توانند الزامات مربوط به prop های خود را تعیین کنند ، مانند انواع قبلاً مشاهده شده. چنانچه شرطی برآورده نشود    Vue در کنسول جاوا اسکریپت مرورگر به شما هشدار می دهد. این امر به ویژه در هنگام توسعه کامپوننت های در حال توسعه بسیار مفید است.برای تعیین اعتبار سنجی ، می توانید به جای آرایه ای از رشته ها ، می توانید یک object را به همراه الزامات اعتبار سنجی ارائه دهید. مثلا:Vue.component(&#x27;my-component&#x27;, {  props: {    // Basic type check (&#x60;null&#x60; and &#x60;undefined&#x60; values will pass any type validation)    propA: Number,    // Multiple possible types    propB: [String, Number],    // Required string    propC: {      type: String,      required: true    },    // Number with a default value    propD: {      type: Number,      default: 100    },    // Object with a default value    propE: {      type: Object,      // Object or array defaults must be returned from      // a factory function      default: function () {        return { message: &#x27;hello&#x27; }      }    },    // Custom validator function    propF: {      validator: function (value) {        // The value must match one of these strings        return [&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27;].indexOf(value) !== -1      }    }  }})هنگامی که اعتبار سنجی مورد تایید نبود ، Vue یک هشدار کنسول تولید می کند .توجه داشته باشید که prop  ها قبل از ایجاد نمونه کامپوننت تأیید می شوند ، بنابراین خصوصیات نمونه (به عنوان مثال data ، computed و غیره) در داخل توابع پیش فرض یا اعتبارسنج در دسترس نخواهند بود.Prop Validationنوع داده می تواند یکی از سازندگان بومی زیر باشد:StringNumberBooleanStringArrayObjectDateFunctionSymbolعلاوه بر این ، type همچنین می تواند سازنده سفارشی تابع باشد و با یک instanceof   بررسی می شود. به عنوان مثال ، با توجه به عملکرد سازنده زیر:function Person (firstName, lastName) {  this.firstName = firstName  this.lastName = lastName}می توانید اینطور استفاده کنید :Vue.component(&#x27;blog-post&#x27;, {  props: {    author: Person  }})جهت تأیید مقدار author prop  ایجاد شده با  new Person .Non-Prop Attributes non-prop attribute  خاصیتی است که به یک کامپوننت منتقل می شود ، اما prop مربوطه تعریف نشده است.در حالی که props  های صریحاً تعریف شده برای انتقال اطلاعات به یک کامپوننت فرزند  ترجیح داده می شوند ، نویسندگان کتابخانه های کامپوننت همیشه نمی توانند زمینه هایی را که ممکن است کامپوننت های شان در آنها استفاده شود پیش بینی کنند. به همین دلیل کامپوننت ها می توانند صفات دلخواه را که به عنصر کامپوننت root اضافه می شوند ، بپذیرند.به عنوان مثال ، تصور کنید که ما از یک کامپوننت 3rd-party  به نام  bootstrap-date-input   به همراه پلاگین  Bootstrap  که نیاز به  ویژگی data-date-picker در input نیاز دارد استفاده می کنیم. ما می توانیم این ویژگی را به نمونه کامپوننت خود اضافه کنیم :&#x3C;bootstrap-date-input data-date-picker=&#x22;activated&#x22;&#x3E;&#x3C;/bootstrap-date-input&#x3E;و ویژگی  data-date-picker=\"activated\"  بصورت اتوماتیک به المان روت bootstrap-date-input اضافه خواهد شد.Replacing/Merging with Existing Attributes قالب زیر را برای bootstrap-date-input تصور کنید :&#x3C;input type=&#x22;date&#x22; class=&#x22;form-control&#x22;&#x3E;جهت تعیین یک قالب برای پلاگین date picker  ، ممکن است لازم باشد class  خاصی اضافه کنیم ، مانند این:&#x3C;bootstrap-date-input  data-date-picker=&#x22;activated&#x22;  class=&#x22;date-picker-theme-dark&#x22;&#x3E;&#x3C;/bootstrap-date-input&#x3E;در این حالت ، دو مقدار متفاوت برای class  تعریف می شود:form-control که توسط کامپوننت در الگوی خود تنظیم شده است :date-picker-theme-dark که توسط والد آن به کامپوننت منتقل می شوند :برای بیشتر ویژگی ها ، مقدار ارائه شده به کامپوننت جایگزین مقادیر تعیین شده توسط کامپوننت خواهد شد. بنابراین به عنوان مثال ،   type = \"text\" جایگزین type = \"date\"  می شود و احتمالاً آن را می شکند! خوشبختانه ، ویژگی های class  و style  کمی هوشمند تر هستند ، بنابراین هر دو مقدار با هم ادغام می شوند و مقدار نهایی را می سازند. form-control date-picker-theme-dark : Disabling Attribute Inheritanceاگر نمی خواهید عنصر ریشه یک کامپوننت ویژگی ها را به ارث برساند ، می توانید inheritAttrs: false را در کامپوننت تنظیم نمایید. برای مثال :Vue.component(&#x27;my-component&#x27;, {  inheritAttrs: false,  // ...})این به ویژه می تواند در ترکیب با نمونه ویژگی $attrs  که شامل نام ویژگی ها و مقادیر منتقل شده به یک کامپوننت است مفید باشد ، مانند موارد زیر:{  required: true,  placeholder: &#x27;Enter your username&#x27;}با  inheritAttrs: false و $attrs ، می توانید به صورت دستی تصمیم بگیرید که کدام ویژگی را می خواهید منتقل کنید ، که اغلب برای کامپوننت پایه مطلوب است:Vue.component(&#x27;base-input&#x27;, {  inheritAttrs: false,  props: [&#x27;label&#x27;, &#x27;value&#x27;],  template: &#x60;    &#x3C;label&#x3E;            &#x3C;input        v-bind=&#x22;$attrs&#x22;        v-bind:value=&#x22;value&#x22;        v-on:input=&#x22;$emit(&#x27;input&#x27;, $event.target.value)&#x22;      &#x3E;    &#x3C;/label&#x3E;  &#x60;})توجه داشته باشید که گزینه inheritAttrs: false  بر روی style  و class  انقیاد شده (bindings) تاثیری نمی گذارد.این الگو به شما امکان می دهد از کامپوننت های پایه بیشتر شبیه عناصر raw HTML استفاده کنید ، بدون اینکه به این عنصر توجه کنید که ریشه اصلی آن چیست:&#x3C;base-input  label=&#x22;Username:&#x22;  v-model=&#x22;username&#x22;  required  placeholder=&#x22;Enter your username&#x22;&#x3E;&#x3C;/base-input&#x3E;",
            "url": "/documentation/vuejs/Components-In-Depth/components-props"
          }
          
        
        ,
    
    
      "2020-07-03-marriage-html": {
        "title": "ازدواج",
        "author": "",
        "category": "",
        "content": "ازدواج ازدواج یکی ار مراحل مهم زندگی انسان ها محسوب می شود که بر خلاف سایر اتفاقات زندگی همچون مرگ و تولد که احساس می کنیم نقشی در آن نداریم ، در این بخش از زندگی ،نقش ما پررنگ تر دیده می شودیکی از روانشناسان به نام بارنت آر.بریکنر می گوید:موفقیت در ازدواج با پیدا کردن بهترین همسر حاصل نمی شود، بلکه با بهترین  همسر بودن به دست می آید  ",
        "url": "/2020/07/03/marriage.html"
      }
      ,
    
      "2019-10-11-vuejs-html": {
        "title": "آموزش vuejs",
        "author": "",
        "category": "",
        "content": "چرا Vue.js؟Vue (تلفظ / vjuː / ، مانند view) یک فریمورک پیشرفته برای ساخت رابط های کاربر است. برخلاف سایر فریمورک های یکپارچه ، Vue از پایه طراحی شده تا از نظر تدریجی قابل قبول باشد. کتابخانه اصلی فقط بر روی لایه view متمرکز شده است ، و انتخاب و ادغام آن با کتابخانه های دیگر یا پروژه های موجود آسان است. از طرف دیگر ، Vue همچنین قادر است در هنگام استفاده از کتابخانه های نوین و پشتیبانی از کتابخانه ها ، از برنامه های تک صفحه ای پیشرفته استفاده کند.شروعساده ترین راه برای امتحان کردن Vue.js استفاده از مثال سلام جهانی JSFiddle است. می توانید یک فایل index.html ایجاد کنید و Vue را با آن شامل کنید:&#x3C;!-- development version, includes helpful console warnings --&#x3E;&#x3C;script src=&#x22;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&#x22;&#x3E;&#x3C;/script&#x3E;یا :&#x3C;!-- production version, optimized for size and speed --&#x3E;&#x3C;script src=&#x22;https://cdn.jsdelivr.net/npm/vue&#x22;&#x3E;&#x3C;/script&#x3E;صفحه  Installation گزینه های بیشتری را برای نصب Vue ارائه می دهد. توجه: ما توصیه نمی کنیم که مبتدیان از vue-cli شروع کنند ، به خصوص اگر هنوز با ابزارهای ساخت مبتنی بر Node.js آشنا نیستید.اعلان رندرینگ (Declarative Rendering)در هسته Vue.js سیستمی است که به ما امکان می دهد تا با استفاده از نحو الگوی ساده ، داده ها را به DOM ارائه دهیم:&#x3C;div id=&#x22;app&#x22;&#x3E;  &#123;&#123; message &#125;&#125;&#x3C;/div&#x3E;var app = new Vue({  el: '#app',  data: {    message: 'Hello Vue!'  }})    &#123;&#123; message &#125;&#125;ما اولین برنامه Vue را ایجاد کرده ایم! به نظر می رسد بسیار شبیه به رندر الگوی رشته ای است ، اما Vue کارهای زیادی را در در پس زمینه انجام داده است. داده ها و DOM اکنون مرتبط شده اند ، و اکنون همه چیز واکنشی است. چگونه می دانیم؟ کنسول جاوا اسکریپت مرورگر خود را باز کنید (همین حالا) و app.message را به مقدار دیگری تنظیم کنید. بر این اساس باید مثال ارائه شده در بالا را به روز کنید.علاوه بر جاگذاری متن ، ما همچنین می توانیم ویژگی های عناصر مانند زیر را به هم پیوند دهیم:&#x3C;div id=&#x22;app-2&#x22;&#x3E;  &#x3C;span v-bind:title=&#x22;message&#x22;&#x3E;    Hover your mouse over me for a few seconds    to see my dynamically bound title!  &#x3C;/span&#x3E;&#x3C;/div&#x3E;var app2 = new Vue({  el: '#app-2',  data: {    message: 'You loaded this page on ' + new Date().toLocaleString()  }})      Hover your mouse over me for a few seconds    to see my dynamically bound title!  در اینجا با چیز جدیدی روبرو می شویم. ویژگی v-bind که می بینید دایرکتیو (directive) خوانده می شود. دایرکتیو ها با v- پیشوند شده اند تا نشان دهند که اینها ویژگی های خاصی هستند که توسط Vue ارائه شده است ، و همانطور که احتمالاً حدس زده اید ، آنها رفتار واکنشی ویژه ای را برای DOM ارائه شده اعمال می کنند. در اینجا ، اساساً گفته می شود \"ویژگی عنوان این عنصر را با ویژگی پیام در نمونه Vue به روز نگه دارید.\"اگر کنسول جاوا اسکریپت خود را دوباره باز کنید و app2.message = 'some new message'  را وارد کنید ، یک بار دیگر خواهید دید که در HTML محدود - در این مورد ویژگی title  - به روز شده است.شرط ها و حلقه ها (Conditionals and Loops)&#x3C;div id=&#x22;app-3&#x22;&#x3E;  &#x3C;span v-if=&#x22;seen&#x22;&#x3E;Now you see me&#x3C;/span&#x3E;&#x3C;/div&#x3E;var app3 = new Vue({  el: '#app-3',  data: {    seen: true  }})    Now you see meدر کنسول app3.seen = false  را وارد کنید. می بینید که پیام از بین می رود.این مثال نشان می دهد که ما می توانیم داده ها را نه تنها به متن و ویژگی ها ، بلکه به ساختار DOM متصل کنیم. علاوه بر این ، Vue همچنین یک سیستم اثر گذار قدرتمند را فراهم می کند که می تواند هنگام inserted/updated/removed عناصر توسط Vue ، اثرات انتقال را بطور خودکار اعمال کند.چند دستورالعمل دیگر نیز وجود دارد که هر کدام عملکرد ویژه خود را دارند. به عنوان مثال ، دایرکتیو v-for می تواند برای نمایش لیستی از موارد با استفاده از داده های یک Array استفاده شود:&#x3C;div id=&#x22;app-4&#x22;&#x3E;  &#x3C;ol&#x3E;    &#x3C;li v-for=&#x22;todo in todos&#x22;&#x3E;      &#123;&#123; todo.text &#125;&#125;    &#x3C;/li&#x3E;  &#x3C;/ol&#x3E;&#x3C;/div&#x3E;var app4 = new Vue({  el: '#app-4',  data: {    todos: [      { text: 'Learn JavaScript' },      { text: 'Learn Vue' },      { text: 'Build something awesome' }    ]  }})                        &#123;&#123; todo.text &#125;&#125;            در کنسول ، app4.todos.push({ text: 'New item' }) را وارد کنید.  شما باید مورد جدید اضافه شده ای را در لیست ببینید.کار با ورودی کاربران (Handling User Input)برای اینکه کاربران بتوانند با برنامه شما ارتباط برقرار کنند ، می توانیم از دایرکتیو v-on برای پیوستن به شنوندگان رویداد که در نمونه های Vue از متدها استفاده می کنند استفاده کنیم:&#x3C;div id=&#x22;app-5&#x22;&#x3E;  &#x3C;p&#x3E;&#123;&#123; message &#125;&#125;&#x3C;/p&#x3E;  &#x3C;button v-on:click=&#x22;reverseMessage&#x22;&#x3E;Reverse Message&#x3C;/button&#x3E;&#x3C;/div&#x3E;var app5 = new Vue({  el: '#app-5',  data: {    message: 'Hello Vue.js!'  },  methods: {    reverseMessage: function () {      this.message = this.message.split('').reverse().join('')    }  }})    &#123;&#123; message &#125;&#125;    Reverse Messageتوجه داشته باشید که در این روش وضعیت برنامه خود را بدون دست زدن به DOM به روز می کنیم - کلیه دستکاری های DOM توسط Vue انجام می شود و کدی که می نویسید بر روی منطق اساسی متمرکز است.Vue همچنین دایرکتیو v-model را ارائه می دهد که باعث می شود اتصال دو طرفه بین ورودی فرم و حالت برنامه برقرار شود:&#x3C;div id=&#x22;app-6&#x22;&#x3E;  &#x3C;p&#x3E;&#123;&#123; message &#125;&#125;&#x3C;/p&#x3E;  &#x3C;input v-model=&#x22;message&#x22;&#x3E;&#x3C;/div&#x3E;var app6 = new Vue({  el: '#app-6',  data: {    message: 'Hello Vue!'  }})    &#123;&#123; message &#125;&#125;    ترکیب با کامپوننت ها (Composing with Components)سیستم کامپوننت مفهوم مهم دیگری در Vue است ، زیرا انتزاعی است که به ما امکان می دهد برنامه های بزرگی ایجاد کنیم که از اجزای کوچک ، خودمحور و اغلب قابل استفاده مجدد ساخته شده است.:در Vue ، یک کامپوننت در اصل یک نمونه Vue با گزینه های از پیش تعریف شده است. ثبت کامپوننت در Vue ساده است:// Define a new component called todo-itemVue.component('todo-item', {  template: '&#x3C;li&#x3E;This is a todo&#x3C;/li&#x3E;'})var app = new Vue(...)اکنون می توانید آن را در الگوی کامپوننت دیگر تنظیم کنید:&#x3C;ol&#x3E;  &#x3C;!-- Create an instance of the todo-item component --&#x3E;  &#x3C;todo-item&#x3E;&#x3C;/todo-item&#x3E;&#x3C;/ol&#x3E;اما این متن مشابه را برای هر یک از todo ارائه می دهد ، که اصلا جالب نیست. ما باید بتوانیم داده ها را از دامنه والدین به اجزای کودک منتقل کنیم. بیایید کامپوننت را با  prop تغییر دهیم:Vue.component('todo-item', {  // The todo-item component now accepts a  // \"prop\", which is like a custom attribute.  // This prop is called todo.  props: ['todo'],  template: '&#123;&#123; todo.text &#125;&#125;'})اکنون می توانیم todo را به هر کامپوننت تکراری دیگر با استفاده از v-bind منتقل نماییم: &#x3C;div id=&#x22;app-7&#x22;&#x3E;  &#x3C;ol&#x3E;    &#x3C;!--      Now we provide each todo-item with the todo object      it&#x27;s representing, so that its content can be dynamic.      We also need to provide each component with a &#x22;key&#x22;,      which will be explained later.    --&#x3E;    &#x3C;todo-item      v-for=&#x22;item in groceryList&#x22;      v-bind:todo=&#x22;item&#x22;      v-bind:key=&#x22;item.id&#x22;    &#x3E;&#x3C;/todo-item&#x3E;  &#x3C;/ol&#x3E;&#x3C;/div&#x3E;Vue.component('todo-item', {  props: ['todo'],  template: '&#123;&#123; todo.text &#125;&#125;'})var app7 = new Vue({  el: '#app-7',  data: {    groceryList: [      { id: 0, text: 'Vegetables' },      { id: 1, text: 'Cheese' },      { id: 2, text: 'Whatever else humans are supposed to eat' }    ]  }})                        این یک مثال معقول است ، ما موفق شده ایم که برنامه خود را به دو واحد کوچکتر جدا کنیم و کودک به طور منطقی از والدین با استفاده از props جدا شده است. اکنون می توانیم مؤلفه &#x3C;todo-item&#x3E; خود را با الگوی و منطق پیچیده تری بهبود بخشیم بدون اینکه روی برنامه والدین تأثیر بگذارد.در یک برنامه بزرگ ، لازم است کل برنامه را به اجزای کوچکتر تقسیم کنید تا توسعه برنامه قابل مدیریت باشد. ما بعداً در راهنمای بیشتر در مورد مؤلفه ها صحبت خواهیم کرد ، اما یک مثال (تخیلی) که قالب یک برنامه ممکن است با اجزای کامپوننت چگونه باشد:&#x3C;div id=&#x22;app&#x22;&#x3E;  &#x3C;app-nav&#x3E;&#x3C;/app-nav&#x3E;  &#x3C;app-view&#x3E;    &#x3C;app-sidebar&#x3E;&#x3C;/app-sidebar&#x3E;    &#x3C;app-content&#x3E;&#x3C;/app-content&#x3E;  &#x3C;/app-view&#x3E;&#x3C;/div&#x3E;",
        "url": "/2019/10/11/vuejs.html"
      }
      ,
    
      "2017-12-18-laravel-html": {
        "title": "آموزش Laravel",
        "author": "",
        "category": "",
        "content": "لاراول (به انگلیسی Laravel) یک چارچوب متن باز پی اچ پی (PHP) است که توسط تیلور اوتول، برای توسعه نرم‌افزارهای وب بر پایه معماری MVC طراحی شده‌است. بعضی از ویژگی‌های لاراول به صورت ماژولار و بسته‌بندی شده ارائه شده‌است. در مارس ۲۰۱۵، لاراول به عنوان معروف‌ترین فریم ورک php شناخته شد، سایر فریم ورک‌های محبوب از قبیل symfony2,Nette,CodeIgniter,Yii2 و سایر فریم ورک‌ها بودند. کدهای باز لاراول برروی github میزبانی می‌شود؛ و تحت لیسانس MIT License ارائه شده‌است.پیدایش لاراول به این صورت بود که تیلور اوتول قصد داشت فریم ورکی ایجاد کند که بر پایه CodeIgniter باشد، در حالی که قابلیت‌های پیشرفته‌تری نسبت به آن ارائه دهد. زیرا با رشد CodeIgniter مشکلاتی برای برنامه نویسان و طراحان وب به وجود آمده بود. اگر دوست دارید بدانید لاراول تا الان که به نسخه لاراول 5.5 رسیده است، چه مسیری را طی کرده، با ادامه مقاله همراه لیداوب باشید تا نسخه‌های مختلف لاراول را با هم بررسی کنیم.پیدایش لاراول به این صورت بود که تیلور اوتول قصد داشت فریم ورکی ایجاد کند که بر پایه CodeIgniter باشد، در حالی که قابلیت‌های پیشرفته‌تری نسبت به آن ارائه دهد. زیرا با رشد CodeIgniter مشکلاتی برای برنامه نویسان و طراحان وب به وجود آمده بود. اگر دوست دارید بدانید لاراول تا الان که به نسخه لاراول 5.5 رسیده است، چه مسیری را طی کرده، با ادامه مقاله همراه لیداوب باشید تا نسخه‌های مختلف لاراول را با هم بررسی کنیم.لاراول 1تیلور اوتول در سال ۲۰۱۱ اولین نسخه از لاراول را منتشر کرد که مکانیزم‌های model، session، view و مسیریابی را ارائه می‌داد، ولی این نسخه در نبود کنترلر حالت mvc واقعی را از دست داده بود.لاراول 2در سپتامبر ۲۰۱۱ اوتول با انجام بهینه سازی‌های متعدد لاراول&nbsp;2 را منتشر کرد. از مهم‌ترین تغییرات نسخه ۲ وجود کنترلرها بود که باعث می‌شد لاراول رسماً به عنوان یک فریم ورک MVC شناخته شود. همچنین سیستم قالب بندی blade نیز در نسخه&nbsp;دوم&nbsp;به این فریم ورک اضافه شد.لاراول 3در فوریه سال ۲۰۱۲ لاراول&nbsp;3 با تغییرات جدیدی وارد عرصه شد. انتشار لاراول&nbsp;3 با معرفی سایت این فریم ورک با آدرس&nbsp;http://laravel.com&nbsp;که امکان استفاده از یک داکیومنت قوی را برای کاربرانش فراهم می‌کرد، همراه بود. از مهم‌ترین قابلیت‌های لاراول&nbsp;3 استفاده از خط فرمان CLI به نام artisan بود. پشتیبانی داخلی از مدیریت سیستم بانک اطلاعاتی، migrationها، لایه‌های بانک اطلاعاتی، پشتیبانی از رویدادها، همگام سازی لاراول با unit testing و همچنین سیستم پکیجینگ یا bundle از دیگر قابلیت‌های مهم لاراول در نسخه&nbsp;سوم لاراول بود که محبوبیت آن را فزونی بخشید.لاراول 4اکنون دیگر لاراول به جایگاه خوبی در بین کاربران دست یافته بود. پس از آن در می سال ۲۰۱۳ نسخه&nbsp;چهارم لاراول&nbsp;بر پایه کدهای Illuminate منتشر شد. در نسخه&nbsp;4 با بهره بردن از مدیر بسته‌ها یا composer تحول بزرگی در چارچوب لاراول ایجاد شد. زیرا این امکان فراهم شده بود که توسط composer کاربران بتوانند از بسته‌ها و کامپوننت‌های متعددی که توسط برنامه نویسان PHP در سراسر جهان نوشته شده بود، استفاده کنند. از قابلیت‌های دیگر ارائه شده توسط نسخه ۴ لاراول پشتیبانی از database seeding، پشتیبانی از صف‌های پیام، ارسال انواع مختلفی از ایمیل و پشتیبانی از soft deletion یا تاخیر در حذف رکوردهای پایگاه داده بود.لاراول 5سیر تکامل لاراول ادامه داشت تا اینکه در فوریه سال ۲۰۱۵ نسخه&nbsp;پنجم لاراول&nbsp;با تغییر در نسخه&nbsp;4.3 منتشر شد. قابلیت‌های مهم و ویژه‌ای به این نسخه اضافه شده بود. برنامه‌ ریزی برای اجرای وظایف از طریق بسته‌ای به نام scheduler، بهینه سازی بسته‌های assets از طریق Elixir، ساده شدن عملیات احراز هویت از طریق بسته Socialite، همچنین ارائه ساختار درختی برای توسعه برنامه از قابلیت‌های لاراول در نسخه&nbsp;5 بود.پس از آن، نسخه‌های لاراول&nbsp;5 به ترتیب منتشر شدند و در هر کدام از آن‌ها ویژگی‌های جدید و منحصربه فردی ارائه شد. نتیجه این تلاش‌ها این است که هم اکنون یک فریم ورک PHP با امکانات کامل و جامع در اختیار برنامه نویسان قرار دارد که تمام نیازهای یک برنامه نویس تحت وب را برطرف می‌کند. در عین حال راحتی و سهولت استفاده از آن مهم‌ترین ویژگی آن به شمار می‌رود. در ادامه نسخه‌های مختلف ورژن 5 لاراول را جهت درک بهتر تفاوت آن‌ها بررسی می‌کنیم.لاراول 5.1لاراول&nbsp;5.1 در ژوئن سال ۲۰۱۵ منتشر شد. باگ‌های زیادی در نسخه&nbsp;5.1&nbsp;لاراول برطرف شده بود. در عین حال مهم‌ترین ویژگی نسخه 5.1 انتشار آن به صورت یک نسخه با پشتیبانی طولانی مدت یا LTS بود. امکان پشتیبانی رفع مشکلات تا ۲ سال و پشتیبانی امنیتی تا سه سال در این نسخه فراهم شده بود.لاراول&nbsp;5.2در ۲۱ دسامبر ۲۰۱۵ لاراول&nbsp;5.2 منتشر شد که تغییرات کوچکی در آن اعمال شده بود.لاراول&nbsp;5.3لاراول&nbsp;5.3 با پشتیبانی ۶ ماهه برای رفع مشکلات و پشتیبانی یک ساله برای مشکلات امنیتی در ۲۳ اوت ۲۰۱۶ منتشر شد. ویژگی‌های جدید زیادی به این نسخه اضافه شده بود که مهم‌ترین آن تمرکز بر بهبود سرعت توسعه برای برنامه نویسان با ایجاد بهبود‌های خلاقانه جهت انجام کارهای رایج بود.لاراول&nbsp;5.4لاراول&nbsp;۵/۴ در ۲۴ ژانویه ۲۰۱۷ منتشر شد. این نسخه بسیاری از ویژگی‌های جدید لاراول از جمله Laravel Dusk، Laravel Mix، Blade Components and Slots، Markdown Emails، Automatic Facades، بهبود مسیر یا route و ویژگی‌های دیگر را شامل می‌شد.لاراول&nbsp;5.5تیم توسعه لاراول همواره درصدد توسعه و افزودن قابلیت‌های جدید به آن هستند و در همین راستا لاراول&nbsp;5.5 را در ۳۰ اگوست ۲۰۱۷ با پشتیبانی طولانی مدت و به صورت LTS منتشر کردند. این نسخه کامل امکان پشتیبانی برای رفع مشکلات تا دو سال و پشتیبانی برای رفع مسائل امنیتی تا سه سال را ایجاد کرده است. این نسخه ویژگی‌های مهم و جدید بسیاری دارد که ما در لیداوب به شرح کامل تمام ویژگی‌های جدید نسخه&nbsp;5.5 پرداخته ایم.&lt;h3مزایای استفاده از فریم ورک لاراول&lt;/h3&gt;در ادامه دلیل رشد بسیار سریع لاراول و اینکه چرا در مدت زمان کوتاهی توانسته در رقابت با فریم ورک‌های دیگر PHP، نظر جامعه برنامه ‌نویسان را به خود جلب کند را بررسی می‌کنیم. مهم‌ترین ویژگی‌ لاراول سرعت بالا و همچنین سادگی و سهولت کار با‌ آن است. لاراول قابلیت‌های مهم فراوانی دارد که آن را به انتخاب اول برنامه نویسان PHP تبدیل کرده است. از جمله مهم‌ترین قابلیت‌های لاراول می‌توان به موارد زیر اشاره کرد:استفاده از معماری MVC در لاراول:&nbsp;در تعریف معماری MVC و فریم ورک‌های مبتنی بر آن می‌توان گفت که این معماری تلفیقی از سه لایه model-view-controller است. کار با پایگاه داده از وظایف بخش model است. وظیفه ارتباط با کاربر نهایی بر عهده بخش view است. و وظیفه کنترل و ایجاد ارتباط بین دو لایه view و model برعهده بخش controller است. تقسیم بندی برنامه به این سه قسمت مزایای فراوانی دارد که از جمله مهم‌ترین مزیت‌های آن جداسازی منطق برنامه از بخش view سایت است که این امر باعث می‌شود؛ هنگام ایجاد تغییر در view، این تغییرات منطق برنامه را تحت تاثیر قرار ندهند. فریم ورک لاراول بر پایه معماری MVC است.&nbsp;انتشار به صورت متن باز:&nbsp;انتشار به صورت متن باز امکان تغییر این فریم ورک طبق چیزی که می‌خواهید را فراهم می‌کند.امکان تعریف RESTFUL controllers:&nbsp;منطقی برای سهولت استفاده از کنترلرها و کاهش کدها در آن بر پایه درخواست‌های GET و POST است.استفاده از خصوصیت auto-loading:&nbsp;خصوصیت auto-loading در لاراول امکان لود اتوماتیک کلاس‌ها و کامپوننت‌ها را در صورت نیاز به‌ آن‌ها فراهم کرده است.راحتی استفاده از پایگاه داده:&nbsp;با استفاده از سیستم ORM یا همان ابزار Elequent در لاراول می‌توانید با انواع پایگاه داده‌ها ارتباط برقرار کرده و انواع کوئری‌ها را در آن به کار بگیرید.استفاده از ابزار unit testing:&nbsp;با استفاده از ابزار تست لاراول به راحتی می‌توانید برنامه‌های خود را تست کنید.استفاده از قالب blade:&nbsp;می‌توان از داده‌های برنامه در view توسط قالب blade استفاده کرد.ایجاد پکیج‌ها:&nbsp;در لاراول به راحتی می‌توانید پکیج‌های موردنظر خود را ایجاد کنید و از آن در برنامه‌های خود بهره ببرید، یا آن را با دیگران به اشتراک بگذارید.استفاده از خط فرمان artisan:&nbsp;استفاده از خط فرمان artisan این امکان را می‌دهد تا کارهای پیچیده‌ای را توسط چند خط کد ساده انجام دهیم.استفاده از migration:&nbsp;استفاده از این قابلیت این امکان را فراهم کرده است که تغییرات بانک اطلاعاتی به همراه سورس کد پروژه قابل انتقال باشد.نصب آسان:&nbsp;از مزیت‌های لاراول این است که نصب این فریم ورک و کار با آن بسیار راحت است.استفاده از کامپوننت‌ها:&nbsp;لاراول از پکیج‌ها و کامپوننت‌های زیادی بهره می‌برد که به راحتی بر روی پروژه نصب و استفاده می‌شوند.امنیت:&nbsp;یکی از مهم‌ترین مسائلی که برای یک برنامه نویس اهمیت دارد، امنیت برنامه‌ی در حال ساخت است. لاراول از سطح بالایی از امنیت برخوردار است.مسیریابی:&nbsp;راحتی کار و قدرت مسیریابی لاراول از مهم‌ترین ‌ویژگی‌های لاراول است.",
        "url": "/2017/12/18/laravel.html"
      }
      ,
    
      "articles-2017-12-13-laravelcollective-html": {
        "title": "معرفی Laravel Collective",
        "author": "",
        "category": "",
        "content": "Laravel Collective جهت ایجاد فرم های ایمن و سریع در فریم ورک laravel کاربرد دارد به عبارتی پس از آنکه ما این امکان جانبی را نصب نمودیم دیگر نیاز به کدنویسی های پیچیده html برای فرم های خود نداریم و به سادگی می توانیم از طریق داکیومنتی که خود لاراول کالکتیو در اختیار ما قرار می دهد هر عملیاتی را انجام دهیم.نصبجهت نصب این پکیج با استفاده از composer ، فایل composer.json پروژه خود را همانند زیر ویرایش نمائید :composer require \"laravelcollective/html\":\"^5.4.0\"سپس، provider جدید خود را به آرایه providers واقع در config / app.php اضافه کنید:'providers' =&gt; [    // ...    Collective\\Html\\HtmlServiceProvider::class,    // ...  ],نهایتا دو نام مستعار کلاس  را به آرایه aliases واقع در config / app.php اضافه نمایید :  'aliases' =&gt; [    // ...      'Form' =&gt; Collective\\Html\\FormFacade::class,      'Html' =&gt; Collective\\Html\\HtmlFacade::class,    // ...  ],ایجاد Form{{ Form::open(['url' =&gt; 'foo/bar']) }}    //{{ Form::close() }}به طور پیش فرض، از روش POST جهت ارسال اطلاعات در فرم استفاده می شود، با این حال، شما می توانید روش دیگری را مشخص کنید:echo Form::open(['url' =&gt; 'foo/bar', 'method' =&gt; 'put'])توجه داشته باشید: از آنجا که فرمهای HTML فقط از POST و GET پشتیبانی می کنند، جهت استفاده از روشهای  PUT و DELETE ، بطور اتوماتیک  یک فیلد پنهان method_ به فرم شما اضافه می گردد.جهت ارسال اطلاعات فرم به route و یا action  کنترلر همانند زیر عمل می کنیم :echo Form::open(['route' =&gt; 'route.name'])echo Form::open(['action' =&gt; 'Controller@method'])همچنین جهت ارسال پارامتر به route و یا action کنترلر  همانند زیر عمل می کنیم:echo Form::open(['route' =&gt; ['route.name', $user-&gt;id]])echo Form::open(['action' =&gt; ['Controller@method', $user-&gt;id]])همچنین جهت آپلود و ارسال فایل مانند زیر عمل کنید :echo Form::open(['url' =&gt; 'foo/bar', 'files' =&gt; true])استفاده از توکن CSRF در فرمLaravel  روش آسانی برای حفاظت از اپلیکیشن شما در برابر حملات cross-site request forgeries  فراهم کرده است. اگر شما از روش Form::open با استفاده از POST، PUT یا DELETE استفاده کنید، نشانه CSRF به صورت خودکار به عنوان فیلد پنهان به فرم شما اضافه می شود. همچنین، اگر شما مایل به ایجاد HTML برای فیلد پنهان CSRF هستید، می توانید از روش  token استفاده کنید:echo Form::token();افزودن CSRF به Route :Route::post('profile',    [        'before' =&gt; 'csrf',        function()        {            //        }    ]);ایجاد فرم با استفاده از Modelممکن است بخواهید فرم را بر اساس محتویات یک model پر کنید. برای انجام این کار، از روش Form::model استفاده کنید:echo Form::model($user, ['route' =&gt; ['user.update', $user-&gt;id]])زمانیکه که شما یک عنصر در فرم همانند یک text input را تولید می کنید، ، مقدار این text input به صورت خودکار برابر با مقدار نام آیتم موجود در Model تنظیم می گردد. با این حال موارد دیگری نیز وجود دارد. اگر یک آیتم در Session flash data مطابق با نام ورودی وجود داشته باشد، بر روی مقدار مدل اولویت خواهد داشت. بنابراین ترتیب اولویت ها بدین صورت است :Session Flash Data (Old Input)Explicitly Passed ValueModel Attribute Dataاین امر به شما اجازه می دهد تا سریعا فرم هایی را ایجاد کنید که نه تنها به مقادیر model پیوند دارند، بلکه اگر خطای اعتبارسنجی روی سرور وجود داشته باشد، به راحتی مقادیر فرم دوباره پر شود!توجه: هنگام استفاده از Form :: model، باید فرم خود را با Form::close ببندید!بررسی Form Model AccessorsEloquent Accessor  در Laravel  اجازه می دهد ویژگی model را تا قبل از بازگشت دستکاری کنید. برای مثال، برای تعیین فرمت های تاریخ جهانی، این می تواند بسیار مفید باشد. با این حال، فرمت تاریخ مورد استفاده برای نمایش ممکن است با قالب تاریخی مورد استفاده برای عناصر فرم سازگار نباشد. شما می توانید این را با ایجاد دو دسترسی جداگانه حل کنید: یک دسترسی استاندارد و یا یک فرم دسترسی.برای تعریف دسترسی به فرم، یک متد formFooAttribute را در model خود ایجاد کنید که در آن Foo نام ستونی است که میخواهید به آن دسترسی پیدا کنید.در این مثال، یک accessor برای ویژگی date_of_birth تعریف می کنیم. زمانیکه   ()Form::model جهت پر کردن  فرم استفاده شود، Accessor به صورت خودکار توسط ایجاد کننده فرم فراخوانی می  گردد.شما باید با استفاده از روش trait کلاس FormAccessible را به model خود include  نمایید.&lt;?phpnamespace App;use Carbon\\Carbon;use Illuminate\\Database\\Eloquent\\Model;use Collective\\Html\\Eloquent\\FormAccessible;class User extends Model{    use FormAccessible;         /**     * Get the user's first name.     *     * @param  string  $value     * @return string     */    public function getDateOfBirthAttribute($value)    {        return Carbon::parse($value)-&gt;format('m/d/Y');    }    /**     * Get the user's first name for forms.     *     * @param  string  $value     * @return string     */    public function formDateOfBirthAttribute($value)    {        return Carbon::parse($value)-&gt;format('Y-m-d');    }}ایجاد Label در فرمecho Form::label('email', 'E-Mail Address');تعیین ویژگی های HTML  در Label :echo Form::label('email', 'E-Mail Address', ['class' =&gt; 'awesome']);نکته: پس از ایجاد یک Label، هر عنصر فرم که با نامی مطابق با نام Label ایجاد می کند، به طور خودکار یک شناسه مطابق با نام Label نیز دریافت می کند.ایجاد Text Inputecho Form::text('username');تعیین  یک مقدار پیش فرض در Text Input :echo Form::text('email', 'example@gmail.com');ایجاد Password Inputecho Form::password('password', ['class' =&gt; 'awesome']);ایجاد Input  های Email  و Fileecho Form::email('name', $value = null, $attributes = []);echo Form::file('name', $attributes = []);ایجاد Checkbox و Radio Inputecho Form::checkbox('name', 'value');echo Form::radio('name', 'value');Checkbox Or Radio Input که ویژگی تیک خورده اند :echo Form::checkbox('name', 'value', true);echo Form::radio('name', 'value', true);ایجاد Number Inputecho Form::number('name', 'value');ایجاد Date Inputecho Form::date('name', \\Carbon\\Carbon::now());ایجاد File Inputecho Form::file('image');نکته: خاصیت files  باید در هنگام ایجاد فرم برابر true باشدایجاد Drop-Down Listecho Form::select('size', ['L' =&gt; 'Large', 'S' =&gt; 'Small']);ایجاد Drop-Down List با گزینه انتخاب شده پیش فرض :echo Form::select('size', ['L' =&gt; 'Large', 'S' =&gt; 'Small'], 'S');ایجاد Drop-Down List همراه با placeholder : echo Form::select('size', ['L' =&gt; 'Large', 'S' =&gt; 'Small'], null, ['placeholder' =&gt; 'Pick a size...']);در زیر نحوه ایجاد Grouped List را مشاهده می کنید :echo Form::select('animal',[    'Cats' =&gt; ['leopard' =&gt; 'Leopard'],    'Dogs' =&gt; ['spaniel' =&gt; 'Spaniel'],]);ایجاد Grouped List با یک رنج عددی :echo Form::selectRange('number', 10, 20);ایجاد List  با یک Month Names :echo Form::selectMonth('month');ایجاد Submit Buttonecho Form::submit('Click Me!');ایجاد Form Macroبه Form class helpers شخصی، اصطلاحا macro  گفته می شود.جهت ایجاد Macro  همانند زیر عمل می کنیم :Form::macro('myField', function(){    return '&lt;input type=\"awesome\"&gt;';});هم اکنون با استفاده از نام Macro  می توانیم آنرا فراخوانی کنیم :echo Form::myField();ایجاد Custom Componentcomponent  شبیه macro  های سفارشی می باشند با این تفاوت که در ماکروها خروجی مستقیما تگ های HTML  است ولی در کامپوننت محتوای موجود در قالب Laravel Blade Templates  می باشدجهت ثبت یک کامپوننت از روش زیر استفاده می کنیمForm::component('bsText', 'components.form.text', ['name', 'value', 'attributes']);برای مثال فرض کنید یک view  مانند زیر داشته باشیم :// resources/views/components/form/text.blade.php&lt;div class=\"form-group\"&gt;    {{ Form::label($name, null, ['class' =&gt; 'control-label']) }}    {{ Form::text($name, $value, array_merge(['class' =&gt; 'form-control'], $attributes)) }}&lt;/div&gt;آنگاه جهت ثبت آن بصورت component  خواهیم داشت :Form::component('bsText', 'components.form.text', ['name', 'value' =&gt; null, 'attributes' =&gt; []]);و برای فراخوانی components  ثبت شده :{{ Form::bsText('first_name') }}که خروجی آن HTML  موجود در view  مشخص شده می باشد :&lt;div class=\"form-group\"&gt;    &lt;label for=\"first_name\"&gt;First Name&lt;/label&gt;    &lt;input type=\"text\" name=\"first_name\" value=\"\" class=\"form-control\"&gt;&lt;/div&gt;ایجاد URLsایجاد یک لینک به یک آدرس URL  مشخص :echo link_to('foo/bar', $title = null, $attributes = [], $secure = null);ایجاد یک لینک برای اتصل به یک asset :echo link_to_asset('foo/bar.zip', $title = null, $attributes = [], $secure = null);ایجاد لینک به یک route :echo link_to_route('route.name', $title = null, $parameters = [], $attributes = []);ایجاد لینک به یک controller action :echo link_to_action('HomeController@getIndex', $title = null, $parameters = [], $attributes = []);",
        "url": "/articles/2017/12/13/laravelcollective.html"
      }
      ,
    
      "2017-12-06-design-patterns-html": {
        "title": "معرفی  Design Pattern",
        "author": "",
        "category": "",
        "content": "Design Patternها یکسری جواب های ثابت شده به مشکلات رایج در طراحی هستند. به وسیله آنها می توان یکسری راهکار برای حل مسائل بازگشتی در طراحی برنامه تعریف کرد.به طور واضح، Design Patternها کدهای آماده ای نیستند که بتوان مستقیماً از آن ها استفاده کرد. اما یکسری رویکرد یا نظریه برای حل چالش های عادی طراحی ارائه می دهند.هر الگو بیانگر یک مسئله و مشکل است که می تواند بارها و بارها روی بدهد همراه با راه حل آن مسئله، وشما می تواند از این راه حل برای میلیون ها بار استفاده کند بدون نیاز مجدد برای پیدا کردن راه حل.دسته بندی الگو هادر اوایل دهه ۱۹۹۰، افرادی زیادی روی الگوهای طراحی کار می کردند. اما چهار نفر به نام های، گاما، جاکوبسون، هلم و ولسایدز بیشترین تاثیر را در این زمینه با نوشتن کتابی به نام “Design Pattern: Elements of Reusable Object-Oriented Software”، داشتند. این چهار نویسنده به Gang of Four مشهور شدند. آنها در این کتاب ایده استفاده از الگوها را در طراحی نرم افزار به کار بردند و یک فرمت استاندارد را برای مستندسازی الگوها ایجاد کردند. الگوهای طراحی بیان شده در سه دسته تقسیم بندی شده اند و در مجموع 23 الگو هستند :الگوهای بوجود آورنده(Creational Pattern): همه الگو های که در این دسته قرار می کیرند در ارتباط با روش های ایجاد اشیاء هستند.آنها مسئولیت نمونه سازی از کلاس­ها را به یک نقطه منتقل می­کنند تا قواعد SRP و SoC رعایت گردند. الگوهای این گروه عبارتند از:Factory : یک کلاس، وظیفه ایجاد یک شیء معتبر را به کلاسی دیگر واگذار می کند.Abstract Factory : واسط هایی را ایجاد می­کند برای ساخت خانواده ای از&nbsp; اشیای مرتبط.Builder : امکان ساخت ویرایش های مختلف از یک شیء را با جدا سازی سازنده آن شیء فراهم می کند.Prototype : امکان کپی اشیاء را به ایجاد یک نمونه جدید فراهم می کند.Singleton : به کلاس این امکان را می دهد که فقط یک نمونه از خود ایجاد کرده و فقط یک نقطه واحد برای دسترسی به آن نمونه باشد.الگوهای ساختاری(Structural Patten): این نوع الگوها شرح می دهند چگونه اشیاء و کلاس ها می توانند در ساختارهای بزرگتر باهم ترکیب شوند. الگوهای این گروه عبارتند از:Adapter : به کلاس­هایی از واسط های ناسازگاز اجازه کار با یکدیگر را می دهد.Bridge : یک انتزاع را از پیاده سازی آن جدا می کند و اجازه می دهد که آنها مستقل از یکدیگر تغییر کند.Composite : اجازه می دهد که یک گروه از اشیاء که به صورت سلسله مراتبی نمایش داده&nbsp; می­شوند، درست مانند یک نمونه از یک شیء مورد استفاده قرار گیرد.Decorator : به صورت پویا می­تواند یک کلاس را پوشش داده و رفتارهای آن را توسعه دهد.Facade : یک واسط ساده ایجاد می­کند برای کنترل دسترسی به تعدادی از واسط­ها و زیر سیستم­های پیچیده.Flyweight : روشی را برای اشتراک داده­ها بین تعداد زیادی از کلاس­های کوچک فراهم می­نماید.Proxy : یک نگهداره برای یک کلاس پیچیده که نمونه گیری از آنها هزینه­ بر است را فراهم می­نماید.الگوهای رفتاری(Behavioral Pattern):به ارتباطات بین اشیاء بر مبنای مسئولیت­ها و الگوریتم­های آنها می­پردازد. این الگوها رفتارهای پیچیده سیستم را بسته بندی می­کنند و آن را از جریان کلی سیستم جدا می­نمایند تا سیستم­های پیچیده به خوبی درک شده و نگهداری شوند. الگوهای این گروه عبارتند از:Chain of Responsibility : اجازه می­دهد که دستورات با یکدیگر زنجیر شوند تا یک درخواست را انجام دهند.Command : یک متد را در قالب یک شیء بسته بندی می کند و اجرای دستور &nbsp;را از صادر کننده آن جدا می­سازد.Interpreter : نحوه ارزیابی جملات در یک زبان را مشخص می­کند.Iterator : نحوه پیمایش یک مجموعه را به صورت فرموله شده تعیین می­کند.Mediator : شیء ایی را تعریف می­کند که امکان برقراری ارتباط بین دو شیء دیگر را فراهم می­نماید بدون آنکه آنها از یکدیگر مطلع باشند.Memento : امکان برگشت دادن وضعیت یک شیء به حالت قبلی­اش را فراهم می­نماید.Observer : روشی را تعریف می­کند که یک یا چند کلاس از تغییرات در یک کلاس مطلع گردند.State : اجازه می­دهد که یک شیء تغییر رفتار خود را به یک شیء دیگری واگذار کند.Strategy : اجازه می­دهد که یک الگوریتم در یک کلاس بسته بندی شود و در زمان اجرا تعویض شود برای تغییر رفتار&nbsp; یک شیء.Template Method : کلاسی که کنترل جریان یک الگوریتم را تعریف نماید ولی به کلاس های مشتق اجازه می دهد گام های اجرایی آن را پیاده سازی نمایند.Visitor : امکان کارکرد جدید برای یک کلاس را فراهم می نمایند بدون آنکه ساختار آن تغییر کند.",
        "url": "/2017/12/06/design-patterns.html"
      }
      ,
    
      "2017-11-27-php-unit-html": {
        "title": "آموزش PHPUnit",
        "author": "",
        "category": "",
        "content": "PHPUnit فریم ورکی جهت تست کدهای php است، این فریمورک از معماری xUnit استفاده می‌کند.  سازندگان آن آلمانی هستند و هدف خودشان را از تولید این فریم ورک، استفاده خودشان جهت تست کدهایشان اعلام کرده اند. آنها میخواستند چند چیز مثل آرایه ها و … را در کدهایشان آزمایش کنند و به این فکر افتاده اند «ما که داریم این tester را می نویسیم، چرا کامل و کاربردی نباشد تا بتوان همیشه از آن استفاده کرد».  این ابزار کمک می کند تا پایداری و مقیاس پذیری(scalability) برنامه تان را تست کنید.نصب PHPUnitجهت نصب PHP unit  می توان از برنامه composer استفاده نمائیم . بنابراین دستور زیر را در ترمینال وارد نمائید تا مراحل نصب تکمیل گردد :$ composer global require phpunit/phpunitبرنامه بصورت global  نصب گرددید به این معنا که در تمامی پروژه ها و دایرکتوری ها می توان از این برنامه استفاده کرد. جهت اطمینان از صحت نصب، دستور زیر را در ترمینال وارد تا ورژن نصب شده نمایش داده شود :$ phpunit --vبسیار خب... می خواهیم از این قسمت به بعد مراحل تنظیمات و نوشتن تست را بصورت یک پروژه بیان کنیم. بنابراین دایرکتوری به نام myproject ایجاد و درون آن دایرکتوری دیگری به نام test  ایجادمی کنیم.همچنین چون ما از روش PSR-4  جهت لودینگ کلاس ها استفاده می کنیم بنابراین فایلی به نام composer.json  را در مسیر اصلی پروژه ایجاد و کد زیر را درون آن قرار دهید :{}سپس درون ترمینال دستور زیر را وارد تا پوشه vendor  ایجاد گردد :composer dumpتنظیمات PHP Unit  در پروژهجهت تنظیمات مورد نظرمان  از فایل phpunit.xml در شاخه اصلی پروژه استفاده می نمائیم. همانند کد زیر :&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?در کد بالا دو تنظیم انجام داده ایم که عبارتند از :با استفاده از ویژگی colors=\"true\" تعیین کردیم که نتایج آزمایش بصورت رنگی در ترمینال نمایش داده شودبا استفاده از تگ directory تعیین کردیم که مسیر فایل های تست ما درون پوشه test  در شاخه اصلی قرار دارند.",
        "url": "/2017/11/27/php-unit.html"
      }
      ,
    
      "2017-11-15-test-driven-development-html": {
        "title": "اصول Test Driven Development",
        "author": "",
        "category": "",
        "content": " تست واحد نوع خاصی از آزمون با یک هدف بسیار مشخص و مجموعه ای از ویژگی ها است. خوشبختانه، تعریف پایه تست واحد نسبتا ساده است :  Unit Test  یک تست است که یک نیاز مشخص برای یک متد مشخص را آزمایش می‌کند(قانون یک نیاز/یک متد one requirement/one method rule)آزمون‌های واحد که قانون یک نیاز/یک متد  را رعایت می‌کنند، ویژگی‌های زیر را هم به عنوان یک unit test‌ دارند: هدفمند (Targeted) :  آزمون‌های واحدی که یک چیز (شامل مجموعه‌ای از ورودی‌ها) را در یک زمان آزمایش می‌کنند، هدف‌گیری‌شده هستند. جدا شده  (Isolated) : کدی که در حال تست آن هستید باید از کد اصلی برنامه و وابستگی‌های خارجی یا رویدادها جدا بوده و ایزوله شده باشد.قابل تکرار و قابل پیش بینی  (Repeatable &amp; Predictable) : یک آزمون واحد باید قابلیت بارها تکرار مجدد را داشته باشد (Repeatable باشد) و با فرض اینکه کد در حال تست و خود تست تغییر نکنند، هر دفعه همان نتیجه را تولید کند (قابل پیش‌بینی یا Predictable باشد)مستقل  (Independent) : این آزمون‌ها باید مستقل باشد، به صورت کلی هیچ تضمینی در خصوص ترتیب اجرا unit test ها وجود ندارد و بنابراین تست‌های نوشته شده توسط شما نباید انتظار یا نیاز به این مساله داشته باشند.مفهوم Test DRIVEN Developmentبیشتر برنامه‌نویس‌هایی که کار با آزمون‌های واحد را شروع می‌کنند، ابتدا کد برنامه‌شان را می‌نویسند و بعد unit test ها را. این گام مشترک و حتی می‌توان گفت اولین گام منطقی برای ورود به دنیای TDD و unit testing است. بالاخره نمی‌شود یک تست نوشت وقتی چیزی برای تست کردن وجود ندارد. خیلی از این برنامه‌نویس‌ها این کار را با یک روش و نیت خوب شروع می‌کنند: حتماً بعد از نوشتن کد، تست مربوط به کد را هم می‌نویسند. آن‌ها نوشتن تست‌ها را فراموش نمی‌کنند یا به خاطر یک کار مهم دیگر به تاخیر نمی‌اندازند. اما در واقعیت، تعهد به نوشتن تست کار بسیار دشواری است و تقریباً همه برنامه‌نویس‌ها بعد از مدتی دچار TED یا Test Eventually Develpoment می‌شوند و در واقع می‌گویند که بالاخره یک روزی تستش می‌کنیم و تا آن یک روزی ممکن است زمان زیادی طول بکشد یا حتی هرگز فرا نرسد!اولین D در TDD مخفف Driven هست. ایده این روش این است که اولین کاری که برنامه‌نویس انجام می‌دهد نوشتن تست بر اساس ویژگی مورد انتظار فعلی نرم‌افزار (specification) است که روی آن کار می‌کند. این تست‌ها باید fail شوند چرا که قابلیتی که می‌خواهند آزمایش کنند هنوز به وجود نیامده است. در این شرایط کار برنامه‌نویس این خواهد بود که ساده‌ترین کد ممکن را بنویسد یا تست pass شود. اگر نرم‌افزار امکانات مورد انتظار (specification) بیشتری دارد، تست‌های بیشتری بنویسید و چرخه refactor و بهینه کردن کد را ادامه دهید. وقتی همه مشخصات نرم‌افزار تست داشتند و تست‌هایشان pass می‌شد نرم‌افزار شما آماده است. عرضه‌اش کنید!عمل TDD به نظر ساده است، اما این نشان دهنده یک تغییر اساسی در نحوه توسعه دهندگان برای دستیابی به توسعه نرم افزار است. در نتیجه، تمرین و نوشت تست کمی طول می کشد و چند بار استفاده از آن ممکن است کمی طبیعی باشد. اما اکثر توسعه دهندگان متوجه می شوند که در نهایت فقط نوشتن کد است، فقط شما ابتدا کد آزمون را می نویسید. سخت ترین بخش TDD حفظ نظم و انضباط و ادامه تمرین است.چرا باید از TDD استفاده کنم؟  برخی از این مزایا واضح هستند و بعضی نه. شاید واضح‌ترین مزیت این باشد که کد شما وقتی کاملاً منطبق بر نیازهای مورد انتظار نرم‌افزار نیست،‌ مشکلات و باگ‌های کمتری خواهد داشت. یکی از انواع باگ‌هایی که TDD می‌تواند به صورت کامل حذفشان کند، \"باگ‌های زامبی\" هستند: باگ‌هایی که به نظر می‌رسد رفع شده‌اند ولی چند build‌ بعدتر دوباره ظاهر می‌شوند! وقتی رسیدگی به یک باگ یا مشکل به یک TDD کار محول می‌شود، اولین کاری که انجام می‌دهد نوشتن یک تست جدید است که باگ را آشکار و تست را fail می‌کند. بعد از این کار، برنامه‌نویس روش عادی کار در TDD را دنبال می‌کند: آن‌قدر کد بنویس که تست مورد نظر pass شود و بقیه تست‌ها هم همچنان pass شده باقی بمانند. مزیت دیگر استفاده از TDD بهبود کیفیت کد است. همان‌طور که گفته شد در TDD برنامه‌نویس‌ها باید ساده‌ترین کد برای pass شدن تست‌ها را بنویسند: ساده‌ترین و کوتاه‌ترین کد که معمولاً کیفیت بیشتری دارد. همچنین این کدها خوانایی بیشتری دارند که باعث می‌شود نگهداری کد ساده‌تر شود.  مزیت دیگر استفاده از TDD حذف موثر کدهای مرده از برنامه شماست.   کدهای مرده یا Dead Code کدهایی هستند که در برنامه هستند اما هیچ وقت اجرا نمی‌شوند. این کد ممکن است یک متد یا کلاس باشند که هیچ وقت فراخوانی یا ارجاع داده نشدند یا بخشی از یک شرط باشند که هیچ وقت محقق نخواهد شد.   با استفاده از TDD شما فقط کدهایی را می‌نویسید که برای pass شدن تست نیاز دارید. اگر تست‌ها بر اساس نیازمندی‌های نرم‌افزار باشند، هیچ کدی از برنامه نیست که اجرا نشود و کدهایی که با روش TDD ایجاد می‌شوند همیشه مورد استفاده قرار می‌گیرند. با این حال تغییرات در نرم‌افزار به مرور زمان ممکن است باعث شوند یک متد که امروز مورد استفاده قرار می‌گیرد فردا هیچ استفاده‌ای نداشته باشد.   با مانیتور کردن کدها در TDD اگر کدی داشته باشید که در تستی مورد استفاده قرار نگرفته از دو حال خارج نیست:   یا یک تست از دست شما در رفته، یا آن کد یک کد مرده (dead code) است و باید حذف شود.   شناخت و فهمیدن چندریختی مبتنی بر اینترفیس (interface based Polymorphism) از مهارت‌های ضروری TDD‌ است. وقتی در این سری نوشته‌ها به مبحث mocking‌ و وابستگی‌ها (dependencies) برسیم، دانش شما در این حوزه هر روز به کار خواهد آمد.  ",
        "url": "/2017/11/15/test-driven-development.html"
      }
      ,
    
      "articles-2017-11-14-dependency-injection-html": {
        "title": "مفهوم Dependency Injection در PHP",
        "author": "",
        "category": "",
        "content": "تزریق وابستگی یا Dependency Injection یک پترن و الگوی طراحی است که هدف اصلی آن حذف وابستگی‌ های موجود بین دو کلاس با استفاده از یک رابط (Interface) است. در تزریق وابستگی ها دو اصطلاح داریم:loosely coupled: بدین معنی‌ست که کمترین وابستگی بین دو کلاس وجود دارد.tight coupled: بدین معنی‌ست که بیشترین وابستگی بین دو کلاس وجود دارد.بنابراین باید برنامه و نرم‌افزار خود را طوری طراحی کنیم که تا حد ممکن استحکام ضعیف (loosely coupled) باشد. هنگامیکه دو کلاس tight coupled هستند (یعنی به همدیگر وابستگی بسیار دارند یا به اصطلاح دیگری در هم چفت شده‌اند) با استفاده از یک رابطه‌ی باینری به یکدیگر متصل هستند و این امر انعطاف‌پذیری نرم‌افزار را به شدت پایین می‌آورد.چرا بایستی کد وابستگی پایینی داشته باشد؟Extensibility (توسعه پذیری) : با افزودن یک کلاس به برنامه نیازمند تغییرات در بخش های دیگر نباشیمTestability (قابلیت تست پذیری) : فرآیند تست واحد به سهولت و بدون نیاز به در نظرگرفتن بخش های دیگر در آزمون انجام گیردLate Binding (انقیاد پویا) : بتوان در زمان اجرا و کامپایل خدمات مورداستفاده برنامه را تغییر دادParallel Development (توسعه موازی) : توسعه یک بخش از برنامه منوط به توسعه بخش خاص دیگری نباشدMaintainability (قابلیت نگه داری) : افزودن بخش های جدید به برنامه و تغییرات پرهزینه نشوند.استفاده از DI یک آینده نگری است. همه ما میدانیم که احتمال تغییرات در سورس همیشه وجود دارد. پس نحوه کد نویسی در بهترین حالت خود, با کمترین تغییرات در آینده بیشترین کارایی را فراهم می نماید. در حالت های کد نویسی آشفته و بی برنامه ممکن است کوچکترین تغییری نیازمند بررسی و تغییر چندین کلاس و چندین فایل و چندین ماژول باشد. اما با برنامه ریزی این تغییرات به حداقل خود خواهد رسید علاوه بر آن مدیریت تغییرات را برای شما آسوده تر خواهد کرد.جهت مفهوم این مطلب به مثال زیر توجه کنید :&lt;?phpclass Photo {    /**     * @var PDO The connection to the database     */    protected $db;    /**     * Construct.     */    public function __construct()    {        $this-&gt;db = DB::getInstance();    }}در نگاه اول، این کد ممکن است به نظر بی عیب و بی نقص باشد. اما باید درنظر گرفت کلاس Photo وابستگی زیادی  به اتصال پایگاه داده دارد(ممکن است در آینده بخواهیم از انواع مختلف پایگاه داده ها همانند sqlserver,mysql,oracle ... استفاده نماییم که مجبور به تغییرات زیاد در این بخش شده و  حتی منجر به ایجاد باگ های زیاد در صورت فراموشی تغییرات مربوطه می گردد). آیا به این فکر می کنید چرا باید کلاس Photo  با منابع خارجی ارتباط برقرار کند؟ایده اصلی این است که هر کلاس مسئول یک وظیفه باشد و با توجه به این نکته مسئولیت اتصال به پایگاه داده طبیعی نیست. (اصل Single Responsibility Principle)بیایید نگاه دوباره ای به  کلاس Photo بیاندازیم و اتصال پایگاه داده را به خارج از این کلاس انتقال دهیم. دو راه برای انجام این کار وجود دارد:Constructor Injection (تزریق با استفاده از سازنده کلاس)Setter Injection (تزریق با استفاده از متدهای setter  کلاس)تزریق با استفاده از سازنده کلاس (Constructor Injection)در این روش، زمانی که متد سازنده کلاس اجرا می شود، همه وابستگی های مورد نیاز را تزریق می کنیم. همانند کد زیر :&lt;?phpclass Photo {    /**     * @var PDO The connection to the database     */    protected $db;    /**     * Construct.     * @param PDO $db_conn The database connection     */    public function __construct($dbConn)    {        $this-&gt;db = $dbConn;    }}$photo = new Photo($dbConn);تزریق با استفاده از متدهای setter  کلاس (Setter Injection)در این روش می توان با استفاده از متدهایی که درون کلاس تعریف می کنیم اشیا کلاس های دیگر را به درون کلاس تزریق نماییم. همانند کد زیر :&lt;?phpclass Photo {    /**     * @var PDO The connection to the database     */    protected $db;    public function __construct() {}    /**     * Sets the database connection     * @param PDO $dbConn The connection to the database.     */    public function setDB($dbConn)    {        $this-&gt;db = $dbConn;    }}$photo = new Photo;$photo-&gt;setDB($dbConn);با این تغییر ساده، کلاس دیگر وابسته به هیچ ارتباط خاص نیست. سیستم بیرونی کنترل کامل را حفظ می کند. این تکنیک باعث می شود که کلاس به راحتی تست شود، زیرا ما می توانیم در هنگام عملیات mock کردن دیتابیس در فرآیند تست واحد،از متد setDB استفاده نمائیم.مشکل اساسی جهت استفاده از تزریق کننده ها این است که کاربر باید از وابستگی های کلاس کاملا آگاه باشد و باید آن را به نحوی تنظیم کند. همانند زیر :$photo = new Photo;$photo-&gt;setDB($dbConn);$photo-&gt;setConfig($config);$photo-&gt;setResponse($response); قبل از این کاربر به سادگی می توانست نمونه جدیدی از کلاس Photo را ایجاد کند، اما اکنون باید تمام این وابستگی ها را به یاد داشته باشد که با همچنین در سردرگمی و پیچیدگی مواجه شدیم!!!راه حل این مشکل استفاده از مفهوم  Inversion of Control) IoC) می باشد.مفهوم Inversion of Control) IoC)مفهوم Inversion of Control) IoC) بدین صورت بیان می گردد: در این فریم ورک امکان تنظیم اولیه وابستگی‌های سیستم وجود دارد. برای مثال زمانیکه برنامه از یک IoC Container، نوع اینترفیس خاصی را درخواست می‌کند، این فریم ورک با توجه به تنظیمات اولیه‌اش، کلاسی مشخص را بازگشت خواهد داد.به کلاس IoC کد زیر دقت نمایید :// Also frequently called \"Container\"class IoC {    /**     * @var PDO The connection to the database     */    protected $db;    /**     * Create a new instance of Photo and set dependencies.     */    public static newPhoto()    {        $photo = new Photo;        $photo-&gt;setDB(static::$db);        // $photo-&gt;setConfig();        // $photo-&gt;setResponse();        return $photo;    }}همانطور که در کد بالا مشاهده می کنید ایجاد یک نمونه از کلاس و نیز فراخوانی وابستگی های مرتبط با آن درون متد newPhoto که بصورت static تعریف شده انجام می گردد. بنابراین هر زمان که به کلاس Photo نیاز داشتیم نیازی به خاطر سپردن وابستگی های مرتبط با آن نیست و تنها کافی است بصورت زیر عمل می کنیم :$photo = IoC::newPhoto();بسیار خب فرض کنید علاوه بر کلاس Photo  کلاس های دیگری  نیز داشته باشیم، به جای ایجاد یک متد جدید در IoC  به ازای هر کلاس می توانیم از روش عمومی تر همانند زیر استفاده نمائیم :// Also frequently called \"Container\"class IoC {    /**     * @var PDO The connection to the database     */    protected static $registry = array();    /**     * Add a new resolver to the registry array.     * @param  string $name The id     * @param  object $resolve Closure that creates instance     * @return void     */    public static function register($name, Closure $resolve)    {        static::$registry[$name] = $resolve;    }    /**     * Create the instance     * @param  string $name The id     * @return mixed     */    public static function resolve($name)    {        if ( static::registered($name) )        {            $name = static::$registry[$name];            return $name();        }        throw new Exception('Nothing registered with that name, fool.');    }    /**     * Determine whether the id is registered     * @param  string $name The id     * @return bool Whether to id exists or not     */    public static function registered($name)    {        return array_key_exists($name, static::$registry);    }}در کد بالا یک آرایه به نام  registry$ ایجاد کرده ایم که با استفاده از متد register مقادیر کلید (نام کلاس) و دیتای متناظر با آن که یک تابع از نوع Closure می باشد مقدار دهی می شود. همچنین از تابع resolve و registered برای بررسی اینکه آیا نام کلاس در آرایه قبلا ثبت شده است و یا  خیر استفاده می شود.بنابراین تنها کافی است  برای ثبت یک کلاس و وابستگی های مرتبط با آن و سپس فراخوانی کلاس مربوط به آن بدین صورت عمل کنیم :// Add `photo` to the registry array, along with a resolverIoC::register('photo', function() {    $photo = new Photo;    $photo-&gt;setDB('...');    $photo-&gt;setConfig('...');    return $photo;});// Fetch new photo instance with dependencies set$photo = IoC::resolve('photo');",
        "url": "/articles/2017/11/14/dependency-injection.html"
      }
      ,
    
      "2017-11-10-solid-object-oriented-design-html": {
        "title": "اصول S.O.L.I.D  در طراحی شی گرا  (OOD)",
        "author": "",
        "category": "",
        "content": "SOLID مخفف پنج اصل زیر بنایی طراحی شی گرا (Object-Oriented Design) است که اوایل سال ۲۰۰۰ میلادی توسط Robert C. Martin یا همان Uncle Bob معرفی شد.یکی از مشکلاتی که طراحی نامناسب برنامه های شی گرا برای برنامه نویسان ایجاد می کند موضوع مدیریت وابستگی در اجزای برنامه می باشد. اگر این وابستگی به درستی مدیریت نشود مشکلاتی شبیه موارد زیر در برنامه ایجاد می شوند:مشکل  Rigidity : برنامه ی نوشته شده را نمی توان تغییر داد و یا قابلیت جدید اضافه کرد. دلیل آن هم این است که با ایجاد تغییر در قسمتی از برنامه، این تغییر به صورت آبشاری در بقیه ی قسمت ها منتشر می شود و مجبور خواهیم بود که قسمت های زیادی از برنامه را تغییر دهیم.مشکل  Fragility : تغییر دادن برنامه مشکل است و آن هم به این دلیل که با ایجاد تغییر در یک قسمت از برنامه، قسمت های دیگر برنامه از کار می افتند و دچار مشکل می شوند.مشکل  Immobility : قابلیت استفاده مجدد از اجزای برنامه وجود ندارد. در واقع، قسمت های مجدد برنامه ی شی گرای شما آنچنان به هم وابستگی تو در تو دارند که به هیچ وجه نمی توانید یک قسمت را جدا کرده و در برنامه ی دیگری استفاده کنید.اگر هنگام طراحی و برنامه نویسی از این اصول پیروی کنیم و رعایت این اصول و قوانین را مد نظر داشته باشیم، نرم افزار توسعه یافته شده را میتوان راحتتر در طول زمان توسعه (Extensibility) داد و نگهداری (Maintainable) کرد.اگر با Unit Testing یا همان تست واحد! آشنا باشید و در یک پروژه نسبتا قدیمی کار کنید و بخواهید برای این سیستم Unit Test بنویسید به زودی متوجه میشود که به راحتی نمیتوان برای آن تست درست حسابی نوشت. امکان دست زدن به کلاسها، جدا کردن کلاسها، جایگزین کردن آنها توسط Mock ها و Stub ها وجود ندارد و عملا امکان نوشتن Unit Test استاندارد و مفید وجود ندارد.دلیل این مشکل این است که هنگام توسعه اولیه نرم افزار، نوشتن کدی که قابل تست باشد مد نظر نبوده است (یا اولویت نداشته) و یا اصول و قوانین پایه ای طراحی شی گرا رعایت نشده است. خب در این مرحله اکثر برنامه نویسان و توسعه دهندگان شروع به Refactoring یا بهینه سازی کدها میکنند. ولی باید از کجا شروع کرد؟دقیقا در این نقطه این ۵ اصل به کمک ما می آیند و با استفاده از آنها میتوانیم کدهای فعلی را تا حد زیادی بهبود داده و مرحله به مرحله قابلیت تست را به آنها اضافه کنیم.اگر هم از متدهای جدید برنامه نویسی مانند توسعه آزمایش محور (Test Driven Development) استفاده کنیم و واقعا TDD کار کنیم! ناخودآگاه بسیاری از این اصول در کدهای و کلاس های نوشته شده وجود دارند.Solid پنج اصل پایه ای است که به ما کمک می کند معماری نرم افزار خوبی داشته باشیم. Solid مخفف:S مخفف SRP) Single responsibility principle)یک کلاس باید یک و تنها یک دلیل برای تغییر داشته باشد، به این معنی که یک کلاس فقط باید یک مسئولیت داشته باشدO مخفف OCP) Open closed principle)شما باید بتوانید رفتار یک کلاس را توسعه دهید بدون اینکه آنرا تغییر دهید. (کد آنرا دستکاری کنید)L مخفف LSP) Liskov substitution principle)کلاسهای به ارث رفته (مشتق شده) باید بتوانند جایگزین کلاسهای اصلی شوند.I مخفف ISP) Interface segregation principle)تعداد بیشتری اینترفیس کوچک و خاص، بهتر از یک اینترفیس بزرگ (چاق) با متدهای بیشتر است.D مخفف DIP) Dependency inversion principle)وابستگی به Abstraction و نه Concrete Implementation",
        "url": "/2017/11/10/solid-object-oriented-design.html"
      }
      ,
    
      "articles-2017-11-09-composer-autoloading-html": {
        "title": "Autoloading کلاس ها با Composer",
        "author": "",
        "category": "",
        "content": "  همانطور که می دانیم در php برای استفاده از هر کلاسی باید اون کلاس رو در صفحه ای که لازم داریم include یا require کنیم تا php آن کلاس را بشناسد و بتوان از آن استفاده کرد . خب مشکل اینجاست که اگر تعداد کلاس های مورد استفاده زیاد شود این include کردن هر کلاس واقعا مشکل ساز میشه و تمرکز مارو کم می کنه و بیشتر وقتمون میره سمت اینکه کلاس ها در داخل کدام دایرکتوری هستند و تک تک آن ها را به صفحه ی خودمون include کنیم . خوشبختانه composer این مشکل را برای ما حل کرده و خودش این موضوع را به عهده می گیرد و ما فقط کافی است بسته به نیازمون یکی از 3 روش زیر را که در فایل composer.json می باشد استفاده نماییم . داخل فایل composer آبجکتی به نام&nbsp;autoload وجود دارد که داخل آن تعریف می کنیم که چه فایل هایی را و از چه طریق برای ما autoload بسازد.3روش autoloading در composer عبارتند از :File Based AutoloadingClassmap Based AutoloadingPSR-4 Autoloadingسایت اصلی composer روش&nbsp;PSR-4 Autoloading را پیشنهاد می کند اما ما در این مقاله &nbsp;هر 4 روش را بررسی می نماییم .روش File Based Autoloadingدر روت (root) پروژه خودتون یک فولدر به نامaldemo ایجاد کنید .سپس داخل فولدرaldemo یک فولدر دیگر به نام&nbsp;mylibrary ایجاد می کنیم تا فایل های خودمون را داخل اش قرار بدهیم .داخل فولدر&nbsp;mylibrary یک فایل به نام&nbsp;functions.php ایجاد و کدهای زیر را قرار دهید :&lt;?phpfunction lego () {    return 'You are now a master builder.';}حالا داخل فولدر(aldemo) پروژه امون فایل composer.json را ایجاد و کدهای زیر را قرار می دهیم :{    \"autoload\": {        \"files\": [\"mylibrary/functions.php\"]    }}همانطور که در بالا مشاهده می کنید یک آبجکت به نام autoload داریم و داخل آن &nbsp;مشخص کردیم که به چه روشی&nbsp;autoload برای ما ساخته شود . ما روش files را تعیین کردیم و جلوی آن فایل هایی که قرار است به صورت&nbsp;autoload درآیند  را بصورت عناصر آرایه  مشخص می کنیم .حالا برای ایجاد autoload باید ترمینال را باز کرده و به روت پروژه بروید و یکی از دستورات زیر را اجرا کنید :composer dumpیاcomposer dumpautoloadبعد از اجرای فرمان بالا و زدن دکمه اینتر مشاهده می کنید که در روت پروژه , فولدری به نام vendor ساخته می شود .جهت مشاهده تغییرات وارد پوشه  vendor سپس پوشه composer شده و   فایل autoload_files.php را باز نمائید.&lt;?php// autoload_files.php @generated by Composer$vendorDir = dirname(dirname(__FILE__));$baseDir = dirname($vendorDir);return array(    '239a881d87672da709af2b939c130dab' =&gt; $baseDir . '/mylibrary/functions.php',);در خط 8 مشاهده می کنید مسیر فایل function.php به این فایل افزوده شده است.اگر تمام مراحل بالا به درستی انجام شده باشد, فرایند ساخت autoload به وسیله composer و از روش files به موفقیت به اتمام رسیده است . حالا برای استفاده از فایل function.php کافی است در فولدر aldemo فایلی به نام index.php ایجاد کنید و کدهای زیر را قرار دهید :&lt;?phprequire 'vendor/autoload.php';echo lego();در کدهای بالا در خط اول لازم بود که autoload.php را به فایل index امان require کنید . و در خط بعدی از فانکشن lego که در فایل function.php موجود هست استفاده کردیم .روش Classmap Based Autoloadingاین روش از روش File Based Autoloading بهتر است به این خاطر که شما لازم نیست مسیر واقعی فایل خود را مشخص کنید و تنها دایرکتوری که فایل در آن قرار دارد را مشخص می کنیم.نکته : در این روش فقط می توان از کلاس ها استفاده نمود .فولدری به نام classes در شاخه aldemo ایجاد نمائید.سپس فایل myclass.php را در آن ایجاد و کدهای زیر را در آن قرار دهید :&lt;?phpClass Cmautoload { \t  public function classmap () {\t\t  return 'that knows how to autoload with a classmap! ';\t  }}فایل index.php  را مطابق زیر تغییر دهید :&lt;?php require 'vendor/autoload.php'; echo lego(); $cm = new Cmautoload;echo $cm-&gt;classmap();فایل composer.json  را مطابق زیر تغییر دهید :{    \"autoload\": {        \"files\": [\t\t\t\"mylibrary/functions.php\"\t\t],\t\t\"classmap\": [\t\t\t\"classes\"\t\t]\t}}حالا برای ایجاد autoload باید ترمینال را باز کرده و به روت پروژه بروید و یکی از دستورات زیر را اجرا کنید :composer dumpیاcomposer dumpautoloadجهت مشاهده تغییرات وارد پوشه vendor سپس پوشه composer شده و فایل autoload_classmap.php را باز نمائید.&lt;?php// autoload_classmap.php @generated by Composer$vendorDir = dirname(dirname(__FILE__));$baseDir = dirname($vendorDir);return array(    'Cmautoload' =&gt; $baseDir . '/classes/myclass.php',);در خط شماره 9 مشاهده می کنید مسیر کلیه کلاس های موجود در پوشه classes  افزوده شده است.روش PSR-4 Based Autoloadingاستاندارد psr-4 بر خلاف دو روش قبلی یعنی File Based Autoloading , Classmap Based Autoloading با namespace ها در کلاس ها سرو کار دارد .مسیر زیر را در پروژه خود ایجاد نمائید:src/vegibit/libraryفایل greeting.php را در مسیر بالا ایجاد و کدهای زیر را در آن قرار دهید:&lt;?phpnamespace VegibitLibrary; Class Greeting{    public function hi()    {        return \"We got you covered\";    }}فایل index.php  را مطابق زیر تغییر دهید :&lt;?php require 'vendor/autoload.php'; echo lego(); $cm = new Cmautoload;echo $cm-&gt;classmap(); $obj = new VegibitLibrary\\Greeting();echo $obj-&gt;hi();فایل composer.json را مطابق زیر تغییر دهید:{    \"autoload\": {        \"files\": [\t\t\t\"mylibrary/functions.php\"\t\t],\t\t\"classmap\": [\t\t\t\"classes\"\t\t],\t\t\"psr-4\": {\t\t\t\"VegibitLibrary\\\\\" : \"src/vegibit/library/\"\t\t}\t}}حالا برای ایجاد autoload باید ترمینال را باز کرده و به روت پروژه بروید و یکی از دستورات زیر را اجرا کنید :composer dumpیاcomposer dumpautoloadجهت مشاهده تغییرات وارد پوشه vendor سپس پوشه composer شده و فایل autoload_psr4.php را باز نمائید.&lt;?php// autoload_psr4.php @generated by Composer$vendorDir = dirname(dirname(__FILE__));$baseDir = dirname($vendorDir);return array(    'VegibitLibrary\\\\' =&gt; array($baseDir . '/src/vegibit/library'),);در خط شماره 9 مشاهده می کنید آدرس فضای نام VegibitLibrary بصورت عنصر آرایه  افزوده شده است.کلیه فایل های بالا را می توانید از لینک زیر دانلود نمایید:aldemo.zip",
        "url": "/articles/2017/11/09/composer-autoloading.html"
      }
      ,
    
      "articles-2017-11-05-namespace-html": {
        "title": "مفهوم namespace  در PHP",
        "author": "",
        "category": "",
        "content": "یکی از ویژگی های مهمی که در 5.3 PHP اضافه شد، namespace بود. برنامه نویس های #C و جاوا با این ویژگی آشنا هستند.namespace باعث بهبود ساختار اپلیکیشن‌های PHP میشود به طوری که مشکل نام گذاری‌های یکتا حل، همچنین امکان بخش بندی کدها را به توسعه دهندگان می‌دهد، و سازماندهی و پکیج بندی کدها در آن خیلی شبیه به ساختار دایرکتوری‌ها در فایل سیستم هست.علاوه بر موارد بالا شما را قادر می سازد تا از تمام مزایای autoloaderهایی که از جدیدترین استانداردها پیروی می کنند، که شامل اتولودر کامپوزر (Composer’s autoloader) هم می‌شود بهره ببرید.مفهوم و مقدمات namespaceاز مزایای namespace گفتیم، اما بیایید کمی دقیق‌تر به موضوع نگاه کنیم. چه زمانی به استفاده از آنها نیاز پیدا می کنیم؟فضای پیش فرض، که شما در آن به نوشتن کد PHP می‌پردازید فضای سراسری یا global space نام دارد در این فضا شما اجازه تعریف دو کلاس با نام یکسان را ندارید و اگر این کار را انجام دهید با Fatal error روبرو میشوید. این موضوع برای نام تابع‌ها و ثابت‌ها نیز صدق می‌کند.مثال مشابه برای روشن‌تر شدن موضوع، ساختار دایرکتوری‌ها در سیستم عامل‌ها است که امکان ندارد در یک مسیر واحد دو فایل foo.txt ایجاد کرد ولی برای گروه بندی فایل‌های مرتبط می‌توان دایرکتوری دیگری تعریف کرد و یک فایل foo.txt در یک دایرکتوی و فایل foo.txt دیگر را در دایرکتوری دیگر ایجاد کرد.وقتی پروژه گسترده می‌شود این احتمال بالاتر می‌رود که دوباره بخواهیم از نام تابع یا کلاسی که قبلا تعریف شده برای تعریف مجدد استفاده کنید. اوضاع وقتی بدتر می‌شود که بخواهید کامپوننت یا پلاگین شخص دیگری را به پروژه اضافه کنید.این احتمال وجود دارد که در کامپوننتی که میخواهید به پروژه اضافه کنید هم، نام چند تا از کلاسها با نام کلاس‌هایی که شما انتخاب کردید یکی باشد.بنابراین پیامدهایی که بوجود می‌آید شامل موارد زیر هستند:تداخل نام بین کدهایی که شما ایجاد کردید، و کلاس ها و ثابت ها و توابع داخلی PHP و یا کلاس ها و ثابت ها و توابع یک کامپوننت&nbsp;دیگر.برای حل مشکل اول از نام های طولانی و توصیفگر یا پیشوند گذاری قبل بعضی نام ها استفاده می‌شد. که این کار خودش به نوعی کار برنامه‌نویس را سخت‌تر می‌کند.اما حالا براحتی می‌توانیم فضای نام یا namespace تعریف کنیم که با این کار به نوعی کلاس ها و تابع ها و ثابت‌هامون رو بخش بندی خواهیم کرد و دیگر خبری از تداخل نیست.نکته: داخل یک namespace هم طبیعتا نمی توان کلاس‌ها یا تابع‌ها یا ثابت‌های هم نام تعریف کرد.تعریف namespaceخط تعریف namespace باید اولین دستور در بالای کدهایتان و قبل از هر کد دیگری باشد. طبق استاندار PSR-2 یک خط خالی بعد از تعریف آن با بقیه کدها باید وجود داشته باشد.&lt;?phpnamespace FooProject;const CONNECT_OK = 1;class Connection { /* ... */ }function connect() { /* ... */  }تعریف Sub-namespacesمانند فایل‌ها و دایرکتوری‌ها، میتوانید یک ساختار سلسله مراتبی و تو در تو برای کدهایتان درست کنید که با کاراکتر backslash (\\)  از هم جدا میشوند.&lt;?phpnamespace MyProject1;class Foo {\tpublic function Bar()\t{\t\techo 'Bar method for MyProject1, Foo class. ';\t}}$objFoo1=new Foo;$objFoo1-&gt;bar();namespace MyProject2;class Foo {\tpublic function Bar()\t{\t\techo 'Bar method for MyProject2, Foo class. ';\t}}$objFoo2=new Foo;$objFoo2-&gt;bar();در مثال بالا ما دو namespace در یک فایل PHP تعریف کردیم که اینکار امکان پذیر است، اما هرگز توصیه نمی‌شود و برای هر فایل بایستی یک namespace تعریف کرد.نکته: اگر در یک فایل بخواهید از کد namespace شده و کد namespace نشده (Global code) استفاده کنید. باید از ساختار براکت شده مثل زیر استفاده کنید:&lt;?phpnamespace MyProject { // MyProject namespace code}namespace { // global code}فراخوانی کدهای Namespace شدهدر فایل lib1.php، یک ثابت و یک تابع و یک کلاس تعریف کرده ایم و namespace آنرا App\\Lib1 قرار داده ایم:&lt;?php// application library 1namespace App\\Lib1;const MYCONST = 'App\\Lib1\\MYCONST';function MyFunction() {\treturn __FUNCTION__;}class MyClass {\tstatic function WhoAmI() {\t\treturn __METHOD__;\t}}حال برای صدا زدن (call) کدهای بالا در فایل دیگر برای مثال فایل myapp.php یک روش استفاده از کدی مشابه کد زیر است:&lt;?phpheader('Content-type: text/plain');require_once('lib1.php');echo \\App\\Lib1\\MYCONST . \"\\n\";echo \\App\\Lib1\\MyFunction() . \"\\n\";echo \\App\\Lib1\\MyClass::WhoAmI() . \"\\n\";بسیارخب، در کد myapp.php هیچ namespaceایی تعریف نشده، بنابراین در فضای global هستیم. از آنجاییکه MYCONST و MyFunction و MyClass در فضای نام App\\Lib1 تعریف شده‌اند شما به طور مستقیم قادر به فراخوانی آنها نیستید و بایستی پیشوند \\App\\Lib1 را اضافه کنید تا یک نام fully-qualified داشته باشید. در نهایت خروجی زیر را خواهید داشت:&lt;?phpApp\\Lib1\\MYCONSTApp\\Lib1\\MyFunctionApp\\Lib1\\MyClass::WhoAmIاما نام های fully-qualified خیلی طولانی هستند و مزیت زیادی نسبت به مثلا نامگذاری کلاس به صورت App-Lib1-MyClass ندارند.قبل از اینکه بخواهید استفاده از namespaceها را یاد بگیرید مهم است که بدانید PHP چطور تشخیص میدهد که کدام بخش از کد namespace شده درخواست شده است. یک قیاس ساده بین namespaces در PHP و فایل سیستم می‌تواند مثال خوبی باشد.در فایل سیستم 3 راه برای دسترسی به یک فایل داریم:نام فایل به صورت نسبی (Relative) باشد مانند foo.txt. که این مسیر به currentdirectory/foo.txt تبدیل می‌شود که currentdirectory همان دایرکتوری جاری است که در آن قرار داریم.آدرس دهی نسبی مثل subdirectory/foo.txt که به currentdirectory/subdirectory/foo.txt تبدیل میشود.آدرس دهی مطلق مانند main/foo.txt/&nbsp;که تبدیل می‌شود&nbsp;به main/foo.txt/&nbsp;(یعنی به خودش).همین قاعده نیز برای عناصر namespace شده PHP کاربرد دارد. مثلا نام کلاس به سه روش زیر معرفی شده:1. Unqualified name یا نام کلاس بدون پیشوند مثل :$a = new foo();یاfoo::staticmethod();اگر namespace جاری currentnamespace باشد، تبدیل می‌شود به currentnamespace\\foo اگر هم بدون namespace باشد تبدیل می شود به foo.نکته: وقتی علامت \\ را قبل از نام تابع یا ثابت قرار بدهیم تابع یا ثابت global هدف قرار میگیرد.&lt;?phpnamespace A\\B\\C;function strlen($str){\treturn 'ok';}echo strlen('hi'), \"\"; // prints \"ok\"echo \\strlen('hi'), \"\"; // prints \"2\"2. Qualified name یا نام کلاس همراه با پیشوند مثل :$a = new subnamespace\\foo();یاsubnamespace\\foo::staticmethod();اگر namespace جاری currentnamespace باشد تبدیل به currentnamespace\\subnamespace\\foo می‌شود و اگر  بدون namespace باشد، subnamespace\\foo اجرا می‌شود.3. Fully qualified name یا نام پیشوند گذاری شده با پیشوند global \\ مثل :new \\currentnamespace\\foo();یا\\currentnamespace\\foo::staticmethod();همیشه تبدیل می‌شود به همان نام مشخص شده یعنی خودشcurrentnamespace\\foo",
        "url": "/articles/2017/11/05/namespace.html"
      }
      ,
    
      "articles-2017-11-05-anonymous-functions-html": {
        "title": "مفهوم توابع بی‌نام (anonymous function)",
        "author": "",
        "category": "",
        "content": "نیمه دوم سال 2009 بود که PHP با ورژن 5.3 با ویژگی‌های زیاد جدیدی که برای برنامه نویسان جذاب بود، انتشار یافت. یکی از ویژگی‌هایی که به PHP در این نسخه اضافه شد، تابع بی‌نام بود.تابع بی‌نام (anonymous function)توابع ناشناخته که اصطلاحا به آن‌ها تابع روی هوا (on the fly) گفته می شود، به طور ساده تابعی است بدون‌نام. مانند مثال زیر:&lt;?php// Anonymous functionfunction () {  return \"Hello world\";}این مفهوم در PHP تحت قالب Lambda  وClosures پیاده سازی شده است. در ادامه مطلب بیشتر به این مورد خواهیم پرداخت.توابع Lambadaیک Lambada تابع ناشناخته‌ای است که به یک متغیر انتساب داده می شود و یا به عنوان پارامتر به تابع دیگر انتساب داده می‌شود.استفاده از Lambadaاز آن جا که این مدل از تابع‌ها نام ندارند، پس شما نمی‌توانید مثل تابع‌های معمولی آن‌ها را صدا بزنید.بلکه باید همینطور که قبلا به آن اشاره شد، تابع را به یک متغیر انتساب بدهید و یا به عنوان پارامتر به تابع دیگری ارسال کنید.&lt;?php// Anonymous function// assigned to variable$greeting = function ($world = '') {  return \"Hello\". $world;};// Call functionecho $greeting('world');// Returns \"Hello world\"نکته: همینطور که در کد بالا هم مشاهده می کنید، سمی کالن (;) را بعد از اتمام تابع قرار می‌دهیم.نکته: همینطور که در کد بالا هم مشاهده می کنید، می‌توانیم پارامتر به صورت دلخواه به تابع بدهیم (world$).به منظور استفاده از تابع ناشناخته، ما این تابع را به یک متغیر انتساب میدهیم و سپس متغیر را به عنوان یک تابع، Call یا صدا میزنیم.شما همچنین می‌توانید Lambadaایی که تعریف کرده‌اید را به عنوان پارامتر به تابع دیگر بفرستید:&lt;?php// Pass Lambda to functionfunction shout ($message) {  echo $message();}// Call functionshout(function() {  return \"Hello world\";});برای چی من باید از Lambada استفاده کنم؟شاید الان با خودتان گفتید که این تابع بدون اسم چه زمانی کارایی دارد؟Lambada از تعریف تابع هایی که معمولا کد کوچک و مختصری دارند و ممکن است شما در طول اجرای برنامه، مثلا، فقط یکبار صدا بزنید، خودداری می کند. اغلب شما، به تابعی نیاز دارید که کاری را برای شما انجام دهد، اما این نیاز را پیدا نمی کنید که آن را داخل global scope برنامه یا حتی به عنوان بخشی از بقیه کدها اضافه کنید.به جای اینکه تابعی داشته باشید که یک بار استفاده و بعد هم رها شود، میتوانید از Lambada استفاده کنید.یک مورد پر استفاده دیگر توابع ناشناخته درfunction callbackها است.اگر مفهوم توابع  callback در PHP را نمی‌دانید، یک جستجو راجع به آن انجام دهید، چرا که شرح کامل آن در این بحث نمی گنجد. اما یک نگاه سطحی با یک مثال به آن می‌اندازیم تا بحث بیشتر برایتان روشن شود.Callback هر تابعی که صدا زده شده است توسط تابع دیگری که البته آن تابع دیگر، تابع اول را به عنوان پارامتر میگیرد و Call می‌کند. معمولا callback تابعی است که زمانی صدا زده می‌شود که اتفاقی رخ داده باشد، که در دنیای برنامه نویسی به آن اتفاق، رویداد یا event گفته میشود.مثال زیر یک مثال پایه‌ایی از تابع‌های callback است:شما می‌توانید تابعی که نامش در یک متغیر ذخیره شده است را call کنید. فقط کافیست به انتهای نام متغیر، پرانتز باز و بسته () اضافه کنید. مثل ()variable$&lt;?phpfunction thisFuncTakesACallback($callbackFunc){  echo \"I'm going to call $callbackFunc!\";  $callbackFunc();}function thisFuncGetsCalled(){  echo \"I'm a callback function!\";}thisFuncTakesACallback( 'thisFuncGetsCalled' );خب در مثال بالا، ما نام تابع thisFuncGetsCalled را به تابع ()thisFuncTakesACallback ارسال کردیم که سپس این تابع، تابعی که به آن فرستاده شده بود رو صدا زد.از توابع ناشناخته در توابع بومی PHP استفاده شده، که مثال‌های فوق العاده‌ای در این زمینه هستند، از جمله array_walk, array_map, array_reduce و array_filter usort.در مثال زیر نمونه‌ایی از callback function را مشاهده می‌کنید که با Lambada و در تابع array_filter پیاده سازی شده است.نکته: کار array_filter به این صورت است که پارامتر اول یک آرایه مثلا input$ را می‌گیرد و در یک Loop قرار می‌دهد و هر دفعه مقدار فعلی آرایه را به function callback ارسال یا pass میکند. اگرfunction callback مقدار true برگرداند، value جاری خانه مورد نظر از آرایه برگردانده می‌شود. در ضمن keyهای آرایه هم تغییری نمی‌کنند.&lt;?php$input = array(1, 2, 3, 4, 5);$output = array_filter($input, function ($v) { return $v &gt; 2; });// $output == array(2 =&gt; 3, 3 =&gt; 4, 4 =&gt; 5)در مثال بالا، آرایه ورودی فیلتر می‌شود؛ به طوریکه تمام اعداد بزرگتر از 2 استخراج می‌شوند.در مثال بالا، عبارت { ;function ($v) { return $v &gt; 2 یک Lambada است، که اگر میخواهید قابل استفاده مجدد باشد باید آن را داخل یک متغیر ذخیره کنید.اطلاعات بیشتر:  پیشتر می‌توانستید از create_function در PHP استفاده کنید که اساسا همین کار را انجام میدهد.&lt;?php// Use create_function$greeting = create_function('', 'echo \"Hello World!\";');// Call function$greeting();توابع Closureیک Closure (کلوژر) اساسا همان Lambada است، علاوه بر اینکه، می‌توانید به متغیرهای خارج از محدوده‌ایی که تعریف شده هم، دسترسی داشته باشد.&lt;?php// Create a user$user = \"Philip\";// Create a Closure$greeting = function() use ($user) {  echo \"Hello $user\";};// Greet the user$greeting(); // Returns \"Hello Philip\"همان طور که در بالا می بینید Closure می‌تواند به متغیر user$ دسترسی داشته باشد، به این دلیل که در عبارت use، تعریف تابع Closure آورده شده است.همچنین اگر می‌خواهید مقدار متغیر user$ را داخل Closure تغییر بدهید و بیرون آن هم این تغییر از بین نرود، باید حتما قبل از متغیر داخل عبارت use یک &amp; (امپرسند) قرار بدهید تا متغیر به صورت ارسال با مرجع فرستاده شود.بیایید مثال array_filter را نیز با Closure انجام بدهیم.&lt;?php$max_comparator = function ($max){  return function ($v) use ($max) { return $v &gt; $max; };};$input = array(1, 2, 3, 4, 5);$output = array_filter($input, $max_comparator(3)); // Array ( [3] =&gt; 4 [4] =&gt; 5 )در مثال بالا دو نکته را دیدید که یکی استفاده از توابع ناشناخته بصورت تودرتو و دیگری اینکه max$ به عنوان یک متغیر خارج از محدوده closure داخلی، مورد استفاده قرار گرفت.مثالی از Closure در array_walk:&lt;?php// Set a multiplier$multiplier = 3;// Create a list of numbers$numbers = array(1,2,3,4);// Use array_walk to iterate// through the list and multiplyarray_walk($numbers, function($number) use($multiplier) {  echo $number * $multiplier;});در مثال بالا تقریبا این نیاز احساس نمی‌شود که یک تابع بسازید که 2 عدد را در هم ضرب کند در حالی که فقط در یک جا مورد استفاده قرار میگیرد. با استفاده از یک Closure به عنوان callback، ما می‌توانیم تابع را یکبار استفاده کنیم و دیگر آن را فراموش کنیم.استفاده از this$ در توابع ناشناختهدر نیمه اول سال 2012، یعنی زمانی که PHP به نسخه 5.4 خودش رسید، قابلیت جدیدی به توابع ناشناخته اضافه شد. بوسیله این قابلیت قادر هستید به راحتی با استفاده از this$ داخل تابع ناشناخته، به یک نمونه Object دسترسی داشته باشید.&lt;?phpclass Foo{  function hello() {    echo 'Hello Nettuts!';  }  function anonymous()  {    return function() {      $this-&gt;hello(); // $this wasn't possible before    };  }}class Bar{  function __construct(Foo $Foo) // object of class Foo typehint  {    $x = $Foo-&gt;anonymous(); // get Foo::hello()    $x(); // execute Foo::hello()  }}new Bar(new Foo); // Hello Nettuts!استفاده در دنیای واقعییک مثال معروف از استفاده از این نوع توابع در routing درخواست ها در فریم ورک های مدرن است.به عنوان مثال Laravel، به شما اجازه میده که مثل زیر عمل کنید:&lt;?phpRoute::get('user/(:any)', function($name) {  return \"Hello \" . $name;});کد بالا به سادگی با URLایی مثل user/Philip/، تطبیق داده می‌شود.این یک مثال خیلی ساده بود، اما روشن میکند که چطور یک Closure در شرایطی که به آن نیاز هست می‌تواند مورد استفاده واقع شود.در دیگر زبان ها چطور؟توابع ناشناخته در خیلی از زبانهای برنامه نویسی وجود دارند (از جمله پایتون، دلفی، جاوا، C و …) و اگر Ruby و Javascript کار کرده باشید حتما به آن‌ها برخوردید، چون در این زبان‌ها بسیار متداول هستند.البته این نکته نیز ناگفته نماند که کاربرد آن در PHP، دقیقا همان کاربردی نیست که بقیه زبان ها از آن دارند.نمونه‌ایی از تابع ناشناخته در jQuery:",
        "url": "/articles/2017/11/05/anonymous-functions.html"
      }
      ,
    
      "2017-11-03-php7-html": {
        "title": "معرفی امکانات جدید PHP 7",
        "author": "",
        "category": "",
        "content": "مقدمهPHP 7  مهمترین تغییر برای (PHP) ، بعد از انتشار نسخه PHP 5 در سال 2004 است .PHP 7 از موتور zend 3.0 بهره می برد که کارایی برنامه را دو برابر کرده و 50% مصرف حافظه کمتری نسبت به  PHP 5.6 استفاده می نماید. PHP 7 با توجه به حجم کار امروزی بازنویسی و طراحی شده است .چندین ویژگی به نسخه 7 اضافه شده که مهمترین آنها در زیر ذکر شده است :Improved performance: افزودن PHPNG به این نسخه باعث دوبرابر شدن سرعت آن نسبت به PHP5.Lower Memory Consumption : نسخه 7&nbsp;بهینه شده و از منابع کمتری استفاده می کند .Scalar type declarations : می توانید نوع پارمترها و مقادیر برگشتی را &nbsp;مشخص کنید .&nbsp;Consistent 64-bit support&nbsp;:&nbsp;پشتیبانی دائمی از ماشین های معماری 64 بیتی.Improved Exception hierarchy&nbsp;: سلسله مراتب Exeption ها رعایت شده است .&nbsp;Many fatal errors converted to Exceptions&nbsp;:&nbsp;&nbsp;محدوده Exception ها افزایش یافته&nbsp;&nbsp;و خیلی از FatalError ها &nbsp;به Exception تبدیل می شوند.Secure random number generator&nbsp;: در این نسخه چندین api برای ایجاد اعداد تصادفی امن ایجاد شده است .Deprecated SAPIs and extensions removed&nbsp;:&nbsp;انواع SAPI های قدیمی و پشتیبانی نشده و&nbsp;پسوند ها از آخرین نسخه حذف شده اند.The null coalescing operator :&nbsp;&nbsp;اعمال کننده جدید برای مقادیر null اضافه شده است .Anonymous Classes&nbsp;: پشتیبانی برای کلاس های پنهان اضافه شد.Zero cost asserts&nbsp;:&nbsp;&nbsp;پشتیبانی برای&nbsp;Zero cost asserts&nbsp;اضافه شد .",
        "url": "/2017/11/03/php7.html"
      }
      ,
    
      "2017-11-01-object-oriented-programming-in-php-html": {
        "title": "آموزش شی گرایی در php",
        "author": "",
        "category": "",
        "content": "مقدمه«برنامه‌نویسی شی‌گرا» (Object-Oriented Programming) یا به اختصار OOP یک الگو یا شیوه تفکر در برنامه‌نویسی است که برگرفته از دنیای واقعی بوده و از دهه ۱۹۶۰ میلادی مطرح گشته است. به زبانی که از این الگو پشتیبانی کند، «زبان شی‌گرا» گفته می‌شود؛ Simula 67 و Smalltalk نخستین زبان‌های برنامه‌نویسی شی‌گرا هستند. ایده شی‌گرایی در پاسخ به برخی از نیازها که الگوهای موجود پاسخ‌گو آن‌ها نبودند به وجود آمد؛ نیازهایی مانند: توانایی حل تمامی مسائل پیچیده (Complex)، «پنهان‌سازی داده» (Data Hiding)، «قابلیت استفاده مجدد» (Reusability) بیشتر، وابستگی کمتر به توابع، انعطاف بالا و...رویکرد برنامه‌نویسی شی‌گرا «از پایین به بالا» (Bottom-Up) است؛ یعنی ابتدا واحدهایی کوچک از برنامه ایجاد می‌شوند و سپس با پیوند این واحدها، واحدهایی بزرگتر و در نهایت شکلی کامل از برنامه به وجود می‌آید. برنامه‌نویسی شی‌گرا در قالب دو مفهوم «کلاس» (Class) و «شی» (Object) ارایه می‌گردد. هر کلاس واحدی از برنامه است که تعدادی داده و عملیات‌ را در خود نگه‌داری می‌کند و هر شی نیز حالتی (State) مشخص از یک کلاس می‌باشد.در برنامه‌نویسی شی‌گرا، هر برنامه در قالب موجودیت‌های کوچکی که در واقع همان اشیا هستند و با یکدیگر تعامل دارند در نظر گرفته می‌شود. برای داشتن این اشیا می‌بایست ابتدا کلاس‌های برنامه را تعریف نماییم؛ هر کلاس «رفتار» (Behavior) و «صفات» (Attributes) اشیایی که قرار است از آن ایجاد شوند را تعریف می‌کند. از یک کلاس می‌توان هر تعداد که بخواهیم شی ایجاد نماییم. هر شی بیانگر یک «حالت» یا یک «نمونه» (Instance) از کلاس خود است.برای مثال، کارخانه تولید یک مدل خودرو را می‌توانیم به شکل یک کلاس بزرگ در نظر بگیریم. بدیهی است که این کارخانه شامل بخش‌های کوچکتری به مانند: سیستم الکتریکی، سیستم چرخ‌ها، سیستم سوخت، سیستم خنک کننده، موتور و... می‌باشد؛ در این مثال هر یک از این بخش‌ها کلاسی است که باید پیش از کلاس کارخانه ایجاد شود که البته آن‌‌ها هم به جای خود می‌توانند شامل کلاس‌های کوچکتر دیگری باشند. از آنجا که هر کلاس توسط اشیا خود موجودیت می‌یابد؛ می‌بایست درون کلاس کارخانه نمونه‌هایی از این کلاس‌های نام برده ایجاد گردد. قرار گرفتن اشیا در ساختار کلاسی دیگر موجودیت بزرگتری را ایجاد می‌کند. اکنون با ایجاد هر نمونه از کلاس کارخانه، یک شی‌ یا یک موجودیت جدید ایجاد می‌گردد که در درون خود شامل تمامی اشیای این کلاس‌ها می‌باشد. شی حاصل از کلاس کارخانه در این مثال، یک خودرو است.به هر شی کلاس، یک نمونه از آن کلاس گفته می‌شود و هر زمان که یک شی از کلاسی ایجاد می‌گردد در واقع یک نمونه از آن ساخته می‌شود. به این عمل در شی‌گرایی «نمونه‌سازی» (Instantiation) گفته می‌شود. بر همین اساس دو نوع کلاس در شی‌گرایی وجود دارد: ۱- کلاس‌های عادی که توانایی نمونه‌سازی دارند و به آن‌ها ”Concrete Class“ گفته می‌شود ۲- کلاس‌هایی که توانایی نمونه‌سازی ندارند و به آن‌ها ”Abstract Class“ گفته می‌شود.یکی از مفاهیم دیگر در برنامه‌نویسی شی‌گرا، «کپسوله‌سازی» (Encapsulation) است. کپسوله‌سازی به معنی قرار دادن عناصر یک ساختار در قالب موجودیتی جدید می‌باشد. در برنامه‌نویسی شی‌گرا با ایجاد هر نمونه از کلاس، عناصر آن (صفات و رفتارها) در قالب یک موجودیت جدید به نام «شی» قرار می‌گیرد. کپسوله‌سازی در شی‌گرایی امکانی است برای پنهان‌سازی داده‌ها؛ در این شرایط اشیا بدون اینکه از درون یکدیگر و چگونگی کارکرد هم کوچکترین آگاهی داشته باشند به تعامل با یکدیگر می‌پردازند.گفتیم هر کلاس از تعدادی داده و عملیات درون خود نگهداری می‌کند و همچنین گفتیم هر کلاس رفتار و صفات اشیایی که قرار است از آن ایجاد شوند را تعریف می‌کند؛ اکنون با ارایه تعریفی کامل‌تر خواهیم گفت که: هر کلاس از دو بخش «اعضای داده» (Data Members) و «توابع عضو» (Member Functions) تشکیل شده است. اعضای داده در واقع همان متغیر‌های درون کلاس هستند که خصوصیات یا صفات شی را بیان می‌کنند و در شی‌گرایی با عنوان «فیلد» (Field) یا «صفت» (Attribute) از آن‌ها یاد می‌شود. توابع عضو نیز عملیات یا کارهایی هستند که یک شی از کلاس قادر به انجام آن‌ها می‌باشد؛ می‌توان توابع عضو را بیانگر رفتار اشیا کلاس دانست. در شی‌گرایی به این توابع «متد» (Method) گفته می‌شود.همانطور که در زمان پیاده‌سازی کلاس خواهید دید؛ با ایجاد هر نمونه از کلاس یک متد خاص در آن به صورت خودکار اجرا می‌گردد. این متد «سازنده» (Constructor) نام دارد و کار آن «مقداردهی اولیه» (Initialization) شی است. این کار موجب اطمینان از مقداردهی تمامی اعضای داده پیش از استفاده شی در برنامه می‌گردد.برای مثال به کلاس خودرو برگردیم و برای آن صفات: رنگ بدنه، ظرفیت باک، بیشینه سرعت و متدهای: راندن، دریافت میزان سوخت، سوخت گیری، تنظیم سرعت، توقف را در نظر بگیریم. اکنون می‌توانیم با تنظیم صفات، نمونه‌ها یا اشیای مورد نظر خود را از این کلاس ایجاد نماییم. برای مثال: دو خودروی آبی با ظرفیت باک ۲۰ لیتر و بیشینه سرعت ۸۰ کیلومتر-ساعت یا یک خودروی صورتی با ظرفیت باک ۴۰ لیتر و بیشینه سرعت ۱۶۰ کیلومتر-ساعت که البته هر سه آن‌ها تمام متدهای کلاس را در خود دارند:برنامه نویسی شی گرا  به صورت خلاصه :برنامه نویسی شی گرا یک روش برنامه نویسی است که ساختار یا بلوک اصلی اجزای آن، شی‌ها می‌باشند. در کل این روش برنامه نویسی، برنامه به شیء گرایش پیدا می‌کند. به این معنا که داده‌ها و توابعی که قرار است بر روی این داده‌ها عمل کنند، تا جایی که ممکن است در قالبی به نام شی در کنار همدیگر قرار گرفته، جمع‌بندی شده و یک واحد (شی) را بوجود می آورند و نسبت به محیط بیرونِ خود، کپسوله می‌شوند و از این راه، توابع خارجی نا مربوط به آن شی، دیگر توانایی بوجود آوردن تغییر در داده‌های داخل آن شی را ندارند. به عنوان مثال حساب بانکی شما که حاوی مشخصه های فردی شما و مقدار سپردهٔ شما در بانک است، یک شی را بوجود می آورند و به دلیل داشتن ویژگی کپسوله، توان دستکاری در مقدار سپرده یا مشخصه های شما، بدست دیگران وجود ندارد. از دیگر ویژگی‌های برنامه نویسی شی گرا، پیچیدگی کم، هزینه کم، امکان گسترش سریع برنامه با خطای کمتر نسبت به سایر پارادیام‌های برنامه نویسی است.مفاهیم شی گراییقبل از اینکه وارد جزییات شویم بهتر است اصلاح مهم مربوط به برنامه نویسی شی گرا را تعریف کنیم: \tکلاس : یک نوع داده تعریف شده توسط برنامه نویس که شاما توابع محلی بعلاوه داده محلی است. شما می توانید کلاس را به صورت الگویی برای ساخت نمونه های زیادی از نوع یکسان اشیا در نظر بگیرید.\tشی :یک نمونه منحصربفرد از ساختار شی تعریف شده توسط یک کلاس. شما کلاس را یکبار تعریف می کنید و سپس اشیا بسیاری &nbsp;را که متعلق به آن هستند می سازید. اشیا همچنین به عنوان نمونه هم شناخته می شوند.\tمتغیر عضو :متغیرهای تعریف شده درون کلاس. این داده در خارج &nbsp;از کلاس غیر قابل مشاهده بوده و می تواند توسط توابع عضو در دسترس باشند. این متغیرها در زمانی که شی ایجاد می شود صفت نامیده می شوند.\tتابع عضو :این ها توابعی هستند که درون یک کلاس تعریف می شوند و برای دسترسی به داده شی مورد استفاده قرار می گیرند.\tارث بری :هنگامی که کلاس با ارث بردن توابع پدر تعریف می شود به عمل انجام گرفته ارث بری گفته می شود. کلاس فرزند همه یا تعدادی از توابع و متغیرهای کلاس پدر را به ارث می برد.\tکلاس پدر :کلاسی که توسط کلاس دیگر به ارث برده می شود. نام های دیگر کلاس پدر کلاس پایه یا سوپر کلاس است.\tکلاس فرزند :کلاسی که از کلاس دیگر ارث بری می کند. نام های دیگر کلاس فرزند زیرکلاس یا کلاس مشتق شده است.\tچند ریختی : این مفهوم شی گرایی برای جایی به کار می رود که یک تابع بتواند برای چند هدف مختلف استفاده شود. برای مثال نام تابع همان خواهد بود اما ممکن است تعداد مختلفی از آرگومان ها را بگیرد و بتواند وظیفه متفاوتی را انجام دهد.\tسربارگزاری :نوعی از چند ریختی که در آن تعدادی یا همه عملگرها پیاده سازی های مختلفی وابسته به انواع آرگومان های آنها دارند. به طور مشابه توابع نیز با پیاده سازی متفاوت می توانند سربارگزاری شوند.\tانتزاع داده : هر ارائه ای از داده، که در آن جزییات پیاده سازی مخفی بماند (انتزاعی شده)\tکپسوله سازی : اشاره به مفهومی دارد که در آن ما همه داده ها و توابع عضو را با هم در یک جا قرار می دهیم (کپسوله می کنیم) تا یک شی را شکل دهیم.\tسازنده :اشاره به نوع ویژه ای از یک تابع دارد که در زمانی ایجاد شی ای از کلاس به طور خودکار فراخوانی می شود.\tمخرب :اشاره به نوع ویژه ای از یک تابع دارد که در زمان پاک شدن شی به طور خودکار فراخوانی می شود.",
        "url": "/2017/11/01/object-oriented-programming-in-php.html"
      }
      ,
    
      "articles-2017-10-29-composer-html": {
        "title": "ابزار Composer جهت مدیریت پکیج ها در php",
        "author": "",
        "category": "",
        "content": "ابزار composer یک dependency managemer برای برنامه های نوشته شده به زبان php است. این ابزار کمکی به شما اجازه می دهد تا کتابخانه های و پلاگین های مورد نیاز پروژه اتان را تعریف و آن ها را در پروژه اتان نصب کنید.Composer   تمام بسته های مورد نیاز برای پروژه شما را مدیریت می کند. به این معنی که کامپوزر تمام کتابخانه های مورد نیاز را دانلود و آنها را در یک محل ذخیره و مدیریت می کند. این نوع از مدیریت برای وابستگی ها در پروژه مفهوم جدیدی نیست، در واقع، ایده ساخت کامپوزر از NPM که یک پکیج منیجر برای Node.js و Bundler برای Ruby آمده است. شما همچنین ممکن است با PEAR کار کرده باشید. PEAR یک پکیج منیجر برای PHP است که برای چندین سال وجود داشته است که توسط توسعه دهندگان پی اچ پی برای تعدادی از دلایلی رها شده است. در مرحله اول بسیاری از کدهای PEAR به روز رسانی نشده اند و می شود گفت که تاریخ انقضای آنها تمام شده است. بنابراین کاری که Composer انجام می دهد این است که روشی برای استفاده مجدد هر نوع کد را فراهم می کند. به جای اینکه مجبور باشیم کدهای زیاد و اضافی بنویسیم، می توانید با این ابزار سریعا پکیج های محبوب و مورد نیاز را دانلود کنید.مفهوم Dependency managementدر واقع composer یک ابزار مدیریت کننده ی پکیج ها نیست. هر چند پکیج های زیادی را در خود دارد اما مفهومی فراتر را دنبال می کند. composer علاوه بر دارا بودن تعداد زیادی پکیج های مورد استفاده در پروژه ی شما، آنها را با یک دستور در پوشه ی vendor واقع در لیست پوشه های شما ایجاد میکند. همچنین به طور پیش فرض هیچ چیز را global نصب نمی کند.مفهوم composer در واقع مفهوم جدیدی در برنامه نویسی وب نیست و قبل از آن هم ابزارهای اینچنینی در وب وجود داشته اند. مانند npm یا node package manager که مخصوص پلت فرم NodeJS هستند یا همچنین ابزار bundler برای Ruby. در واقع فقط برای PHP تا به حال همچنین مفهوم و ابزاری وجود نداشت بلکه قبلا برای زبان های دیگر وجود داشته بود.در واقع کار اصلی که composer انجام می دهد اینست که کتابخان های مورد نیاز پروژه اتان را برایتان نصب می کند. همچنین اگر این کتابخانه ها خود به کتابخانه های دیگری نیز نیاز داشته باشند آنها را هم نصب می کند.تعریف وابستگی (Dependency)بیایید با ذکر یک مثال این داستان را شفاف تر کنیم. فرض کنیم که شما در پروژه اتان به یک کتابخانه ی کوچک جهت عمل log in دارید و برای این کار کتابخانه ی monolog را انتخاب می کنید. برای اینکه این کتابخانه را به پروژه اضافه کنیم لازم است که در فایل composer.json که در ریشه ی پروژه اتان است دستور زیر را وارد کنید:{    \"require\": {        \"monolog/monolog\": \"1.2.*\"    }}به این راحتی مشخص کردیم که پروژه ی ما نیاز به کتابخانه ی monolog دارد. دقت داشته باشید که فایل composer.json تنها یک تعریف را انجام می دهدو شما برای دانلود کتابخانه و دریافت آن باید composer را اجرا کنید.",
        "url": "/articles/2017/10/29/composer.html"
      }
      ,
    
      "articles-2017-10-20-psr-html": {
        "title": "استانداردهای سری PSR",
        "author": "",
        "category": "",
        "content": "هدف اصلی این استاندارد این است که سردرگمی شما در زمانی که کدهای دیگران را میبینید کمتر شود، که اینکار با رعایت نکات و استایل های کدنویسی توسط تمام برنامه نویسان PHP قابل انجام است.استفاده از این استانداردها در تمام پروژه های PHP چه متن باز یا تجاری توصیه می‌شود که باعث هماهنگی بیشتر بین برنامه نویسان خواهد شد.هر کدام از استانداردهای سری PSR به یک معقوله ای جدا در PHP اشاره میکنند.در جدول زیر نام و عنوان استاندارها نمایش داده است. با کلیک بر روی عنوان می توانید شرح کامل استاندارد و قوانین تعریف شده را مشاهده نمایید:جدول استاندارد های PSR            Status      Num      Title      Editor(s)      Coordinator      Sponsor                  X      0      Autoloading Standard      Matthew Weier O’Phinney      N/A      N/A              A      1      Basic Coding Standard      Paul M. Jones      N/A      N/A              A      2      Coding Style Guide      Paul M. Jones      N/A      N/A              A      3      Logger Interface      Jordi Boggiano      N/A      N/A              A      4      Autoloading Standard      Paul M. Jones      Phil Sturgeon      Larry Garfield              D      5      PHPDoc Standard      Mike van Riel      Vacant      Vacant              A      6      Caching Interface      Larry Garfield      Paul Dragoonis      Robert Hafner              A      7      HTTP Message Interface      Matthew Weier O’Phinney      Beau Simensen      Paul M. Jones              D      8      Huggable Interface      Larry Garfield      Vacant      Vacant              D      9      Security Advisories      Michael Hess      Korvin Szanto      Larry Garfield              D      10      Security Reporting Process      Michael Hess      Larry Garfield      Korvin Szanto              A      11      Container Interface      Matthieu Napoli, David Négrier      Matthew Weier O’Phinney      Korvin Szanto              D      12      Extended Coding Style Guide      Korvin Szanto      Alexander Makarov      Robert Deutz              A      13      Hypermedia Links      Larry Garfield      Matthew Weier O’Phinney      Marc Alexander              D      14      Event Manager      Chuck Reeves      Brian Retterer      Roman Tsiupa              D      15      HTTP Middlewares      Woody Gilk      Paul M Jones      Jason Coward              A      16      Simple Cache      Paul Dragoonis      Jordi Boggiano      Fabien Potencier              D      17      HTTP Factories      Woody Gilk      Roman Tsiupa      Paul M Jones                  _Legend: A = Accepted      D = Draft      R = Review      X = Deprecated_      استاندارد PSR-2 به نوعی گسترش استاندارد PSR-1 است.شما برای بررسی هر یک از استانداردهای کد نویسی میتوانید از ابزاری مانند CodeSniffer استفاده کنید. افزونه های مختلفی برای ویرایشگر های متن وجود دارند که کار مشابهی را انجام می دهند همانند sublime-phpcs که بررسی استاندارد کدهای نوشته شده توسط ویرایشگر متن Sublimetext را بعهده دارد.ابزار دیگری با نام&nbsp;PHP&nbsp;Coding Standards Fixer یا (php-cs-fixer.phar) وجود دارد که به صورت خودکار کد شما را نسبت به استاندارد های تعریف شده بررسی می کند و تغییرات لازم را بصورت اتوماتیک انجام می دهد بطوری که نیاز نیست شما کاری بصورت دستی انجام دهید.تعدادی از قوانین PSR  عبارتند از :پایه استاندارداستانداردهای PSR-1 باید رعایت شود.فایل‌هاتمام فایل‌های PHP باید از Unix LF برای ایجاد خط جدید یا شناسایی پایان خط استفاده کنند (سیستم عامل ویندوز از CR استفاده میکند).تمام فایل‌های PHP باید دارای یک خط خالی در پایان فایل باشند.علامت تگ پایان PHP یا&nbsp;&lt;؟&nbsp;باید در فایل‌هایی که تنها، حاوی کد PHP هستند حذف شوند.خط‌ هامحدودیت شدیدی در طول خط نباید وجود داشته باشد.محدودیت ملایم بر روی طول خط باید 120 کاراکتر باشد، که در صورتی که بیشتر از 120 کاراکتر شد برنامه باید هشدار بدهد، اما هیچ اجباری مبنی بر رعایت آن نباید وجود داشته باشد.خط‌ها میتوانند بیشتر از 80 کاراکتر نباشند و خط‌های طولانی‌تر به چند خط تبدیل شوند.هیچ کاراکتر فاصله‌ای نباید در انتهای خط‌های غیر خالی وجود داشته باشد.فایل‌های PHP میتوانند دارای خط‌های خالی برای افزایش خوانایی داشته باشند.در هر خط تنها باید یک statement وجود داشته باشد.تورفتگیفایل‌های PHP باید از 4 کاراکتر فاصله برای تورفتگی استفاده کنند. همچنین برای اینکار نباید از Tab استفاده شود.کلمات کلیدیکلمات کلیدی PHP باید به صورت حروف کوچک (Lower Case) استفاده شوند.کلمات کلیدی (ثابت‌های)&nbsp;true,&nbsp;false&nbsp;و&nbsp;null&nbsp;باید به صورت حروف کوچک (Lower Case) استفاده شوند.فضای نام (Namespace) و Useزمانی که از&nbsp;namespace&nbsp;استفاده می‌شود باید یک خط خالی بعد از آن وجود داشته باشد.تمام استفاده از کلمه کلیدی&nbsp;use&nbsp;باید بعد از&nbsp;namespace&nbsp;مورد استفاده قرار بگیرد.هر&nbsp;use&nbsp;فقط باید برای یک کلاس مورد استفاده قرار بگیرد.یک خط خالی بعد از استفاده از کلمات کلیدی&nbsp;use&nbsp;باید وجود داشته باشد.",
        "url": "/articles/2017/10/20/psr.html"
      }
      
    
  };
</script>

<script src="/assets/js/jquery-3.2.1.min.js"></script>

<script src="/assets/js/lunr.min.js"></script>

<script src="/assets/js/search.js"></script>

<script src="/assets/js/anchor.min.js"></script>

<script>
    anchors.options = {
        placement: 'left',
        visible: 'always',
//        icon: '#',
    };
    anchors.add('.anchored h2,.anchored h3,.anchored h4,.anchored h5,.anchored h6');

    (function($){
        if(window.location.hash) {
            var hash = decodeURIComponent(window.location.hash);
            gotohash($(hash).offset().top);
        }
        $('a.anchorjs-link').click(function(){
			gotohash($(this).offset().top);
        });
        $('a.anchorjs').click(function(){
			var id = '#' + $(this).attr('title');
			gotohash($(id).offset().top);
        });		
        function gotohash(top){
            var headerHeight = 70; // Get fixed header height
            $('html,body').animate({
                scrollTop: top - headerHeight
            }, 20);
        }
    })(jQuery);
</script>


    <div id="back-to-top" role="button" aria-label="Back to top">
        <i class="fa fa-angle-double-up" aria-hidden="true"></i>
    </div>
</main>
<!-- footer -->

<footer class="footer" role="contentinfo" aria-label="Site footer">
    <div class="navigation" role="navigation" aria-label="Footer links">
        <a href="http://localhost:4000" class="avatar" role="link"></a>
        <ul role="menubar" aria-label="Footer links menubar">
            <li class="footer-products" role="menuitem" aria-label="Products">
                تولیدات
                <ul role="menu" aria-hidden="true" aria-label="Products link">
                </ul>
            </li>
            <li class="footer-blog" role="menuitem" aria-label="Blog">
                مقالات
                <ul role="menu" aria-hidden="true" aria-label="Blog link">
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2020/07/03/marriage.html" role="link" aria-label="ازدواج">ازدواج</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2019/10/11/vuejs.html" role="link" aria-label="آموزش vuejs">آموزش vuejs</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2017/12/18/laravel.html" role="link" aria-label="آموزش Laravel">آموزش Laravel</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/articles/2017/12/13/laravelcollective.html" role="link" aria-label="معرفی Laravel Collective">معرفی Laravel Collective</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2017/12/06/design-patterns.html" role="link" aria-label="معرفی  Design Pattern">معرفی  Design Pattern</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/blog" role="link" aria-label="Read more">Read More</a></li>
                </ul>
            </li>

            <li class="footer-connect" role="menuitem" aria-label="Connect">
                تماس
                <ul role="menu" aria-hidden="true" aria-label="Connect link">
                    <li role="listitem" aria-label="Connect link item"><a href="https://github.com/farhadmirzapour" target="_blank" role="link" aria-label="GitHub">GitHub</a></li>
                    <li role="listitem" aria-label="Connect link item"><a href="https://www.linkedin.com/in/farhad-mirzapour/" target="_blank" role="link" aria-label="Linkedin">Linkedin</a></li>
                    <li role="listitem" aria-label="Connect link item"><a href="https://twitter.com/farhadmirzapour" target="_blank" role="link" aria-label="Twitter">Twitter</a></li>
                </ul>
            </li>
        </ul>
    </div>
    <div class="socials" role="navigation" aria-label="Social links">
        <ul role="menu" aria-hidden="true" aria-label="Social link">
            <li role="listitem" aria-label="Social link item"><a href="https://github.com/farhadmirzapour" target="_blank" role="link" aria-label="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a></li>
            <li role="listitem" aria-label="Social link item"><a href="https://twitter.com/farhadmirzapour" target="_blank" role="link" aria-label="Twitter"><i class="fa fa-twitter" aria-hidden="true"></i></a></li>
            <li role="listitem" aria-label="Social link item"><a href="https://www.linkedin.com/in/farhad-mirzapour-0043b862/" target="_blank" role="link" aria-label="Linkedin"><i class="fa fa-linkedin-square" aria-hidden="true"></i></a></li>
            <li role="listitem" aria-label="Social link item"><a href="/feed.xml" role="link" aria-label="RSS"><i class="fa fa-rss-square" aria-hidden="true"></i></a></li>
        </ul>
    </div>
    <div class="copyright" role="contentinfo" aria-label="Copyright">
        <p>© <script type="text/javascript">document.write(new Date().getFullYear());</script> Farhad Mirzapour</p>
    </div>
</footer>

<!-- scripts -->
<script src="/assets/js/hamburger-menu.js"></script>

<script src="/assets/js/elevator.min.js"></script>
<script src="/assets/js/back-to-top.js"></script>
<script src="/assets/prisma/prism.js"></script>
<!-- google analytics -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-108878564-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-108878564-1');
</script>

</body>
</html>