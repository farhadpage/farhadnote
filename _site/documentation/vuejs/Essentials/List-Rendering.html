<!DOCTYPE html>
<html lang="">
<!-- head -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>رندر List (List Rendering) | مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="رندر List (List Rendering)" />
<meta name="author" content="Farhad Mirzapour" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="نگاشت آرایه به عناصر HTML با v-for ما می توانیم از دایرکتیو v-for برای تهیه لیست از آیتم های موجود در آرایه استفاده کنیم. دایرکتیو v-for به صورت item in items به یک نحو خاص نیاز دارد ، که در آن items منبع دیتای آرایه و item یک نام مستعار برای عنصر آرایه که در آن تکرار می شود: &amp;#x3C;ul id=&amp;#x22;example-1&amp;#x22;&amp;#x3E; &amp;#x3C;li v-for=&amp;#x22;item in items&amp;#x22;&amp;#x3E; &#123;&#123; item.message &#125;&#125; &amp;#x3C;/li&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; var example1 = new Vue({ el: &#39;#example-1&#39;, data: { items: [ { message: &#39;Foo&#39; }, { message: &#39;Bar&#39; } ] } }) نتیجه : &#123;&#123; item.message &#125;&#125; در داخل بلوکهای v-for ، دسترسی کامل به ویژگیهای دامنه والدین داریم. v-for همچنین از یک آرگومان دوم اختیاری برای index آیتم فعلی پشتیبانی می کند. &amp;#x3C;ul id=&amp;#x22;example-2&amp;#x22;&amp;#x3E; &amp;#x3C;li v-for=&amp;#x22;(item, index) in items&amp;#x22;&amp;#x3E; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &amp;#x3C;/li&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; var example2 = new Vue({ el: &#39;#example-2&#39;, data: { parentMessage: &#39;Parent&#39;, items: [ { message: &#39;Foo&#39; }, { message: &#39;Bar&#39; } ] } }) نتیجه : &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; شما همچنین می توانید از of به جای in استفاده نمایید که به نحو جاوا اسکریپت برای تکرار کنندگان(iterators) نزدیکتر می باشد: &amp;#x3C;div v-for=&amp;#x22;item of items&amp;#x22;&amp;#x3E;&amp;#x3C;/div&amp;#x3E; استفاده از v-for به همراه object همچنین می توانید از v-for برای تکرار از طریق خواص یک object استفاده کنید. &amp;#x3C;ul id=&amp;#x22;v-for-object&amp;#x22; class=&amp;#x22;demo&amp;#x22;&amp;#x3E; &amp;#x3C;li v-for=&amp;#x22;value in object&amp;#x22;&amp;#x3E; &#123;&#123; value &#125;&#125; &amp;#x3C;/li&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; new Vue({ el: &#39;#v-for-object&#39;, data: { object: { title: &#39;How to do lists in Vue&#39;, author: &#39;Jane Doe&#39;, publishedAt: &#39;2016-04-10&#39; } } }) نتیجه : &#123;&#123; value &#125;&#125; همچنین می توانید یک آرگومان دوم برای نام ویژگی ارائه دهید ( a.k.a. key): &amp;#x3C;div v-for=&amp;#x22;(value, name) in object&amp;#x22;&amp;#x3E; &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125; &amp;#x3C;/div&amp;#x3E; &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125; و برای index: &amp;#x3C;div v-for=&amp;#x22;(value, name, index) in object&amp;#x22;&amp;#x3E; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125; &amp;#x3C;/div&amp;#x3E; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125; هنگام تکرار از طریق یک object ، مرتب سازی بر اساس ترتیب ()Object.keys صورت می گیرد ، که تضمینی ندارد مطابق با پیاده سازی موتور جاوا اسکریپت باشد. حفظ وضعیت (Maintaining State) هنگامی که Vue در حال به روزرسانی لیستی از عناصر رندر شده با v-for است ، به طور پیش فرض از استراتژی &quot; in-place patch &quot; استفاده می کند. اگر ترتیب داده ها تغییر کند ، به جای حرکت دادن عناصر DOM جهت تطبیق با ترتیب آیتم ها ، Vue هر عنصر را در جای خود قرار داده و اطمینان می دهد آنچه باید در آن index خاص رندر شود انعکاس یابد. این شبیه به رفتار track-by=&quot;$index&quot; در Vue 1.x می باشد. این حالت پیش فرض کارآمد است ، اما تنها در شرایطی مناسب است که خروجی لیست رندر شده شما به وضعیت کامپوننت فرزند یا وضعیت DOM موقتی متکی نباشد (مثلاً مقادیر ورودی فرم). برای اشاره و راهنمایی به Vue که هویت هر گره را ردیابی کرده تا بتواند از آن ها استفاده مجدد و عناصر موجود را دوباره مرتب سازی نماید ، نیاز دارید یک ویژگی key منحصر به فرد برای هر آیتم در نظر بگیرید: &amp;#x3C;div v-for=&amp;#x22;item in items&amp;#x22; v-bind:key=&amp;#x22;item.id&amp;#x22;&amp;#x3E; &amp;#x3C;!-- content --&amp;#x3E; &amp;#x3C;/div&amp;#x3E; توصیه می شود در هر زمان ممکن یک ویژگی key با v-for ارائه دهید ، مگر اینکه محتوای DOM تکرار شونده ساده باشد ، یا عمداً جهت افزایش عملکرد ، بر رفتار پیش فرض تکیه می کنید. از آنجا که این یک مکانیسم عمومی جهت شناسایی گره ها توسط Vue است ، این key دارای کاربردهای دیگری نیز می باشد که به طور خاص با V-for گره خورده اند ، همانطور که بعداً در این راهنما خواهیم دید. از مقادیری همانند اشیاء و آرایه ها به عنوان کلیدهای v-for استفاده نکنید. به جای آن از مقادیر رشته یا عددی استفاده کنید. جهت استفاده دقیق از ویژگی key، به API documentation مراجعه نمایید. تشخیص تغییر در آرایه (Array Change Detection) متدهای جهش (Mutation Methods) Vue متدهای mutation (جهش) آرایه ارائه داده که باعث بروزرسانی های view نیز می شود. این متدها عبارتند از: push() pop() shift() unshift() splice() sort() reverse() شما می توانید console مرورگر خود را باز کرده و در مثال قبل با متدها کار کنید.برای مثال : example1.items.push({ message: &#39;Baz&#39; }). جایگیزینی یک آرایه (Replacing an Array) متدهای Mutation ، همانطور که از نام آن مشخص است ، آرایه اصلی مورد نظر را جهش و دگرگون می کنند. در مقایسه ، روشهای غیر جهش نیز وجود دارد ، به عنوان مثال . ()filter(), concat و ()slice، که آرایه اصلی را جهش نمی دهند ، اما همیشه یک آرایه جدید را برمی گردانند. هنگام کار با روش های غیر جهش ، می توانید آرایه قدیمی را با روش جدید جایگزین کنید: example1.items = example1.items.filter(function (item) { return item.message.match(/Foo/) }) ممکن است فکر کنید این امر باعث خواهد شد که DOM، Vue موجود را دور بیندازد و مجدداً لیست را ارائه دهد - خوشبختانه ، اینگونه نیست. Vue برای به حداکثر رساندن استفاده مجدد از عناصر DOM برخی از اکتشافات هوشمند را پیاده سازی می کند ، بنابراین جایگزینی یک آرایه با آرایه دیگری که حاوی اشیاء همپوشانی است ، عملیاتی بسیار کارآمد است. هشدار به دلیل محدودیت های موجود در JavaScript ، Vue نمی تواند تغییرات زیر را در یک آرایه تشخیص دهد: زمانیکه یک آیتم را مستقیما با index جایگزاری می کنید ، به عنوان مثال vm.items [indexOfItem] = newValue زمانیکه طول آرایه را تغییر می دهید ، به عنوان مثال vm.items.length = newLength برای مثال: var vm = new Vue({ data: { items: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] } }) vm.items[1] = &#39;x&#39; // is NOT reactive vm.items.length = 2 // is NOT reactive برای غلبه بر بر هشدار 1 ، هر دو کد زیر کار مشابه با vm.items [indexOfItem] = newValue انجام می دهند ، اما باعث بروزرسانی وضعیت در سیستم واکنش پذیری خواهد شد : // Vue.set Vue.set(vm.items, indexOfItem, newValue) // Array.prototype.splice vm.items.splice(indexOfItem, 1, newValue) همچنین می توانید از متد نمونه vm.$set استفاده کنید که یک نام مستعار برای Vue.set سراسری است: vm.$set(vm.items, indexOfItem, newValue) برای مقابله با هشدار 2 ، می توانید از splice استفاده کنید: vm.items.splice(newLength) Object Change Detection Caveats مجددا به دلیل محدودیت های JavaScript مدرن ، Vue نمی تواند اضافه و یا حذف ویژگی (property) را تشخیص دهد. مثلا: var vm = new Vue({ data: { a: 1 } }) // `vm.a` is now reactive vm.b = 2 // `vm.b` is NOT reactive Vue اجازه نمی دهد به صورت پویا خصوصیات واکنشی سطح ریشه به یک نمونه ایجاد شده اضافه شود. با این وجود ، می توان با استفاده از روش Vue.set(object, propertyName, value) ویژگیهای واکنشی را به یک شیء تو در تو اضافه کرد. به عنوان مثال ، var vm = new Vue({ data: { userProfile: { name: &#39;Anika&#39; } } }) می توانید یک ویژگی جدید سن age را به شیء userProfile تودرتو اضافه کنید با: Vue.set(vm.userProfile, &#39;age&#39;, 27) همچنین می توانید از متد نمونه vm.$set استفاده کنید که یک نام مستعار برای Vue.set سراسری است: vm.$set(vm.userProfile, &#39;age&#39;, 27) بعضی اوقات ممکن است بخواهید تعدادی از ویژگی های جدید را به یک شی موجود اختصاص دهید ، به عنوان مثال با استفاده از ()Object.assign یا ()extend._ . در چنین مواردی ، شما باید یک شیء تازه را با خصوصیات هر دو شی ایجاد کنید. بنابراین به جای: Object.assign(vm.userProfile, { age: 27, favoriteColor: &#39;Vue Green&#39; }) شما می توانید خصوصیات واکنشی جدید را با: vm.userProfile = Object.assign({}, vm.userProfile, { age: 27, favoriteColor: &#39;Vue Green&#39; }) نمایش نتایج Filtered/Sorted بعضی اوقات می خواهیم نسخه مرتب شده یا فیلتر شده از آرایه را نمایش دهیم بدون اینکه در واقع داده های اصلی را تغییر داده یا مجددا تنظیم کنیم. در این حالت ، می توانید یک ویژگی computed ایجاد کنید که آرایه فیلتر شده یا مرتب شده را برمی گرداند. برای مثال: &amp;#x3C;li v-for=&amp;#x22;n in evenNumbers&amp;#x22;&amp;#x3E;&#123;&#123; n &#125;&#125;&amp;#x3C;/li&amp;#x3E; data: { numbers: [ 1, 2, 3, 4, 5 ] }, computed: { evenNumbers: function () { return this.numbers.filter(function (number) { return number % 2 === 0 }) } } در شرایطی که ویژگی های computed امکان پذیر نیست (به عنوان مثال در داخل حلقه های تودردتو v-for ) ، می توانید از یک متد استفاده کنید: &amp;#x3C;li v-for=&amp;#x22;n in even(numbers)&amp;#x22;&amp;#x3E;&#123;&#123; n &#125;&#125;&amp;#x3C;/li&amp;#x3E; data: { numbers: [ 1, 2, 3, 4, 5 ] }, methods: { even: function (numbers) { return numbers.filter(function (number) { return number % 2 === 0 }) } } v-for با یک رنج v-for همچنین می تواند یک عدد صحیح را دریافت نماید. در این حالت این قالب را بارها تکرار می کند. &amp;#x3C;div&amp;#x3E; &amp;#x3C;span v-for=&amp;#x22;n in 10&amp;#x22;&amp;#x3E;&#123;&#123; n &#125;&#125; &amp;#x3C;/span&amp;#x3E; &amp;#x3C;/div&amp;#x3E; نتیجه: 1 2 3 4 5 6 7 8 9 10 v-for با &amp;#x3C;template&amp;#x3E; شبیه به الگوی v-if ، می توانید از تگ &amp;#x3C;template&amp;#x3E; با v-for نیز استفاده کنید تا بتوانید از چندین عنصر از یک بلاک را رندر نمایید. مثلا: &amp;#x3C;ul&amp;#x3E; &amp;#x3C;template v-for=&amp;#x22;item in items&amp;#x22;&amp;#x3E; &amp;#x3C;li&amp;#x3E;&#123;&#123; item.msg &#125;&#125;&amp;#x3C;/li&amp;#x3E; &amp;#x3C;li class=&amp;#x22;divider&amp;#x22; role=&amp;#x22;presentation&amp;#x22;&amp;#x3E;&amp;#x3C;/li&amp;#x3E; &amp;#x3C;/template&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; v-for با v-if توجه داشته باشید که توصیه نمی شود از v-if و v-for با هم استفاده کنید. برای جزئیات بیشتر به style guideمراجعه کنید. هنگامی که آنها در همان گره وجود دارند ، v-for دارای اولویت بالاتری نسبت به v-if است. این بدان معنی است که v-if در هر تکرار حلقه به طور جداگانه اجرا می شود. این می تواند زمانی مفید باشد که می خواهید گره ها را فقط برای برخی موارد ، مانند زیر ارائه دهید: &amp;#x3C;li v-for=&amp;#x22;todo in todos&amp;#x22; v-if=&amp;#x22;!todo.isComplete&amp;#x22;&amp;#x3E; &#123;&#123; todo &#125;&#125; &amp;#x3C;/li&amp;#x3E; موارد فوق فقط todos هایی را که کامل نیستند رندر می شوند. اگر هدف شما از اجرای شرط حلقه بطور شرطی باشد ، می توانید v-if را روی یک عنصر بسته (یا &amp;#x3C;template&amp;#x3E;) قرار دهید. مثلا: &amp;#x3C;ul v-if=&amp;#x22;todos.length&amp;#x22;&amp;#x3E; &amp;#x3C;li v-for=&amp;#x22;todo in todos&amp;#x22;&amp;#x3E; &#123;&#123; todo &#125;&#125; &amp;#x3C;/li&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; &amp;#x3C;p v-else&amp;#x3E;No todos left!&amp;#x3C;/p&amp;#x3E; v-for با Component شما می توانید به طور مستقیم مانند هر عنصر عادی از v-for در یک کامپوننت سفارشی استفاده کنید: &amp;#x3C;my-component v-for=&amp;#x22;item in items&amp;#x22; :key=&amp;#x22;item.id&amp;#x22;&amp;#x3E;&amp;#x3C;/my-component&amp;#x3E; در 2.2.0+ ، هنگام استفاده از v-for با یک کامپوننت ، یک key لازم است. با این وجود ، داده ها به طور خودکار به کامپوننت منتقل نمی شوند ، زیرا کامپوننت دارای محدوده های جدا شده از خود هستند. برای انتقال داده های تکرار شونده در کامپوننت ، باید از props نیز استفاده کنیم: &amp;#x3C;my-component v-for=&amp;#x22;(item, index) in items&amp;#x22; v-bind:item=&amp;#x22;item&amp;#x22; v-bind:index=&amp;#x22;index&amp;#x22; v-bind:key=&amp;#x22;item.id&amp;#x22; &amp;#x3E;&amp;#x3C;/my-component&amp;#x3E; دلیل عدم تزریق خودکار item به کامپوننت این است که باعث می شود این کامپوننت با نحوه کار v-for پیوستگی محکمی ایجاد کند. صریح بودن اطلاعات مربوط به اینکه از کجا تهیه می شود باعث می شود کامپوننت در موقعیت های دیگر قابل استفاده مجدد باشد. در اینجا یک مثال کامل از یک لیست ساده TODO آمده است: &amp;#x3C;div id=&amp;#x22;todo-list-example&amp;#x22;&amp;#x3E; &amp;#x3C;form v-on:submit.prevent=&amp;#x22;addNewTodo&amp;#x22;&amp;#x3E; &amp;#x3C;label for=&amp;#x22;new-todo&amp;#x22;&amp;#x3E;Add a todo&amp;#x3C;/label&amp;#x3E; &amp;#x3C;input v-model=&amp;#x22;newTodoText&amp;#x22; id=&amp;#x22;new-todo&amp;#x22; placeholder=&amp;#x22;E.g. Feed the cat&amp;#x22; &amp;#x3E; &amp;#x3C;button&amp;#x3E;Add&amp;#x3C;/button&amp;#x3E; &amp;#x3C;/form&amp;#x3E; &amp;#x3C;ul&amp;#x3E; &amp;#x3C;li is=&amp;#x22;todo-item&amp;#x22; v-for=&amp;#x22;(todo, index) in todos&amp;#x22; v-bind:key=&amp;#x22;todo.id&amp;#x22; v-bind:title=&amp;#x22;todo.title&amp;#x22; v-on:remove=&amp;#x22;todos.splice(index, 1)&amp;#x22; &amp;#x3E;&amp;#x3C;/li&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; &amp;#x3C;/div&amp;#x3E; توجه داشته باشید که ویژگی is=&quot;todo-item&quot; است. این در الگوهای DOM ضروری است ، زیرا فقط یک عنصر &amp;#x3C;li&amp;#x3E; درون یک &amp;#x3C;ul&amp;#x3E; معتبر است. این همان کار را با &amp;#x3C;todo-item&amp;#x3E; انجام می دهد ، اما در اطراف یک خطای تجزیه مرورگر بالقوه کار می کند. برای کسب اطلاعات بیشتر به الگوی DOM Template Parsing Caveatsمراجعه کنید. Vue.component(&#39;todo-item&#39;, { template: &#39;\ &amp;#x3C;li&amp;#x3E;\ &#123;&#123; title &#125;&#125;\ &amp;#x3C;button v-on:click=&amp;#x22;$emit(\&amp;#x27;remove\&amp;#x27;)&amp;#x22;&amp;#x3E;Remove&amp;#x3C;/button&amp;#x3E;\ &amp;#x3C;/li&amp;#x3E;\ &#39;, props: [&#39;title&#39;] }) new Vue({ el: &#39;#todo-list-example&#39;, data: { newTodoText: &#39;&#39;, todos: [ { id: 1, title: &#39;Do the dishes&#39;, }, { id: 2, title: &#39;Take out the trash&#39;, }, { id: 3, title: &#39;Mow the lawn&#39; } ], nextTodoId: 4 }, methods: { addNewTodo: function () { this.todos.push({ id: this.nextTodoId++, title: this.newTodoText }) this.newTodoText = &#39;&#39; } } })" />
<meta property="og:description" content="نگاشت آرایه به عناصر HTML با v-for ما می توانیم از دایرکتیو v-for برای تهیه لیست از آیتم های موجود در آرایه استفاده کنیم. دایرکتیو v-for به صورت item in items به یک نحو خاص نیاز دارد ، که در آن items منبع دیتای آرایه و item یک نام مستعار برای عنصر آرایه که در آن تکرار می شود: &amp;#x3C;ul id=&amp;#x22;example-1&amp;#x22;&amp;#x3E; &amp;#x3C;li v-for=&amp;#x22;item in items&amp;#x22;&amp;#x3E; &#123;&#123; item.message &#125;&#125; &amp;#x3C;/li&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; var example1 = new Vue({ el: &#39;#example-1&#39;, data: { items: [ { message: &#39;Foo&#39; }, { message: &#39;Bar&#39; } ] } }) نتیجه : &#123;&#123; item.message &#125;&#125; در داخل بلوکهای v-for ، دسترسی کامل به ویژگیهای دامنه والدین داریم. v-for همچنین از یک آرگومان دوم اختیاری برای index آیتم فعلی پشتیبانی می کند. &amp;#x3C;ul id=&amp;#x22;example-2&amp;#x22;&amp;#x3E; &amp;#x3C;li v-for=&amp;#x22;(item, index) in items&amp;#x22;&amp;#x3E; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &amp;#x3C;/li&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; var example2 = new Vue({ el: &#39;#example-2&#39;, data: { parentMessage: &#39;Parent&#39;, items: [ { message: &#39;Foo&#39; }, { message: &#39;Bar&#39; } ] } }) نتیجه : &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; شما همچنین می توانید از of به جای in استفاده نمایید که به نحو جاوا اسکریپت برای تکرار کنندگان(iterators) نزدیکتر می باشد: &amp;#x3C;div v-for=&amp;#x22;item of items&amp;#x22;&amp;#x3E;&amp;#x3C;/div&amp;#x3E; استفاده از v-for به همراه object همچنین می توانید از v-for برای تکرار از طریق خواص یک object استفاده کنید. &amp;#x3C;ul id=&amp;#x22;v-for-object&amp;#x22; class=&amp;#x22;demo&amp;#x22;&amp;#x3E; &amp;#x3C;li v-for=&amp;#x22;value in object&amp;#x22;&amp;#x3E; &#123;&#123; value &#125;&#125; &amp;#x3C;/li&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; new Vue({ el: &#39;#v-for-object&#39;, data: { object: { title: &#39;How to do lists in Vue&#39;, author: &#39;Jane Doe&#39;, publishedAt: &#39;2016-04-10&#39; } } }) نتیجه : &#123;&#123; value &#125;&#125; همچنین می توانید یک آرگومان دوم برای نام ویژگی ارائه دهید ( a.k.a. key): &amp;#x3C;div v-for=&amp;#x22;(value, name) in object&amp;#x22;&amp;#x3E; &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125; &amp;#x3C;/div&amp;#x3E; &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125; و برای index: &amp;#x3C;div v-for=&amp;#x22;(value, name, index) in object&amp;#x22;&amp;#x3E; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125; &amp;#x3C;/div&amp;#x3E; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125; هنگام تکرار از طریق یک object ، مرتب سازی بر اساس ترتیب ()Object.keys صورت می گیرد ، که تضمینی ندارد مطابق با پیاده سازی موتور جاوا اسکریپت باشد. حفظ وضعیت (Maintaining State) هنگامی که Vue در حال به روزرسانی لیستی از عناصر رندر شده با v-for است ، به طور پیش فرض از استراتژی &quot; in-place patch &quot; استفاده می کند. اگر ترتیب داده ها تغییر کند ، به جای حرکت دادن عناصر DOM جهت تطبیق با ترتیب آیتم ها ، Vue هر عنصر را در جای خود قرار داده و اطمینان می دهد آنچه باید در آن index خاص رندر شود انعکاس یابد. این شبیه به رفتار track-by=&quot;$index&quot; در Vue 1.x می باشد. این حالت پیش فرض کارآمد است ، اما تنها در شرایطی مناسب است که خروجی لیست رندر شده شما به وضعیت کامپوننت فرزند یا وضعیت DOM موقتی متکی نباشد (مثلاً مقادیر ورودی فرم). برای اشاره و راهنمایی به Vue که هویت هر گره را ردیابی کرده تا بتواند از آن ها استفاده مجدد و عناصر موجود را دوباره مرتب سازی نماید ، نیاز دارید یک ویژگی key منحصر به فرد برای هر آیتم در نظر بگیرید: &amp;#x3C;div v-for=&amp;#x22;item in items&amp;#x22; v-bind:key=&amp;#x22;item.id&amp;#x22;&amp;#x3E; &amp;#x3C;!-- content --&amp;#x3E; &amp;#x3C;/div&amp;#x3E; توصیه می شود در هر زمان ممکن یک ویژگی key با v-for ارائه دهید ، مگر اینکه محتوای DOM تکرار شونده ساده باشد ، یا عمداً جهت افزایش عملکرد ، بر رفتار پیش فرض تکیه می کنید. از آنجا که این یک مکانیسم عمومی جهت شناسایی گره ها توسط Vue است ، این key دارای کاربردهای دیگری نیز می باشد که به طور خاص با V-for گره خورده اند ، همانطور که بعداً در این راهنما خواهیم دید. از مقادیری همانند اشیاء و آرایه ها به عنوان کلیدهای v-for استفاده نکنید. به جای آن از مقادیر رشته یا عددی استفاده کنید. جهت استفاده دقیق از ویژگی key، به API documentation مراجعه نمایید. تشخیص تغییر در آرایه (Array Change Detection) متدهای جهش (Mutation Methods) Vue متدهای mutation (جهش) آرایه ارائه داده که باعث بروزرسانی های view نیز می شود. این متدها عبارتند از: push() pop() shift() unshift() splice() sort() reverse() شما می توانید console مرورگر خود را باز کرده و در مثال قبل با متدها کار کنید.برای مثال : example1.items.push({ message: &#39;Baz&#39; }). جایگیزینی یک آرایه (Replacing an Array) متدهای Mutation ، همانطور که از نام آن مشخص است ، آرایه اصلی مورد نظر را جهش و دگرگون می کنند. در مقایسه ، روشهای غیر جهش نیز وجود دارد ، به عنوان مثال . ()filter(), concat و ()slice، که آرایه اصلی را جهش نمی دهند ، اما همیشه یک آرایه جدید را برمی گردانند. هنگام کار با روش های غیر جهش ، می توانید آرایه قدیمی را با روش جدید جایگزین کنید: example1.items = example1.items.filter(function (item) { return item.message.match(/Foo/) }) ممکن است فکر کنید این امر باعث خواهد شد که DOM، Vue موجود را دور بیندازد و مجدداً لیست را ارائه دهد - خوشبختانه ، اینگونه نیست. Vue برای به حداکثر رساندن استفاده مجدد از عناصر DOM برخی از اکتشافات هوشمند را پیاده سازی می کند ، بنابراین جایگزینی یک آرایه با آرایه دیگری که حاوی اشیاء همپوشانی است ، عملیاتی بسیار کارآمد است. هشدار به دلیل محدودیت های موجود در JavaScript ، Vue نمی تواند تغییرات زیر را در یک آرایه تشخیص دهد: زمانیکه یک آیتم را مستقیما با index جایگزاری می کنید ، به عنوان مثال vm.items [indexOfItem] = newValue زمانیکه طول آرایه را تغییر می دهید ، به عنوان مثال vm.items.length = newLength برای مثال: var vm = new Vue({ data: { items: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] } }) vm.items[1] = &#39;x&#39; // is NOT reactive vm.items.length = 2 // is NOT reactive برای غلبه بر بر هشدار 1 ، هر دو کد زیر کار مشابه با vm.items [indexOfItem] = newValue انجام می دهند ، اما باعث بروزرسانی وضعیت در سیستم واکنش پذیری خواهد شد : // Vue.set Vue.set(vm.items, indexOfItem, newValue) // Array.prototype.splice vm.items.splice(indexOfItem, 1, newValue) همچنین می توانید از متد نمونه vm.$set استفاده کنید که یک نام مستعار برای Vue.set سراسری است: vm.$set(vm.items, indexOfItem, newValue) برای مقابله با هشدار 2 ، می توانید از splice استفاده کنید: vm.items.splice(newLength) Object Change Detection Caveats مجددا به دلیل محدودیت های JavaScript مدرن ، Vue نمی تواند اضافه و یا حذف ویژگی (property) را تشخیص دهد. مثلا: var vm = new Vue({ data: { a: 1 } }) // `vm.a` is now reactive vm.b = 2 // `vm.b` is NOT reactive Vue اجازه نمی دهد به صورت پویا خصوصیات واکنشی سطح ریشه به یک نمونه ایجاد شده اضافه شود. با این وجود ، می توان با استفاده از روش Vue.set(object, propertyName, value) ویژگیهای واکنشی را به یک شیء تو در تو اضافه کرد. به عنوان مثال ، var vm = new Vue({ data: { userProfile: { name: &#39;Anika&#39; } } }) می توانید یک ویژگی جدید سن age را به شیء userProfile تودرتو اضافه کنید با: Vue.set(vm.userProfile, &#39;age&#39;, 27) همچنین می توانید از متد نمونه vm.$set استفاده کنید که یک نام مستعار برای Vue.set سراسری است: vm.$set(vm.userProfile, &#39;age&#39;, 27) بعضی اوقات ممکن است بخواهید تعدادی از ویژگی های جدید را به یک شی موجود اختصاص دهید ، به عنوان مثال با استفاده از ()Object.assign یا ()extend._ . در چنین مواردی ، شما باید یک شیء تازه را با خصوصیات هر دو شی ایجاد کنید. بنابراین به جای: Object.assign(vm.userProfile, { age: 27, favoriteColor: &#39;Vue Green&#39; }) شما می توانید خصوصیات واکنشی جدید را با: vm.userProfile = Object.assign({}, vm.userProfile, { age: 27, favoriteColor: &#39;Vue Green&#39; }) نمایش نتایج Filtered/Sorted بعضی اوقات می خواهیم نسخه مرتب شده یا فیلتر شده از آرایه را نمایش دهیم بدون اینکه در واقع داده های اصلی را تغییر داده یا مجددا تنظیم کنیم. در این حالت ، می توانید یک ویژگی computed ایجاد کنید که آرایه فیلتر شده یا مرتب شده را برمی گرداند. برای مثال: &amp;#x3C;li v-for=&amp;#x22;n in evenNumbers&amp;#x22;&amp;#x3E;&#123;&#123; n &#125;&#125;&amp;#x3C;/li&amp;#x3E; data: { numbers: [ 1, 2, 3, 4, 5 ] }, computed: { evenNumbers: function () { return this.numbers.filter(function (number) { return number % 2 === 0 }) } } در شرایطی که ویژگی های computed امکان پذیر نیست (به عنوان مثال در داخل حلقه های تودردتو v-for ) ، می توانید از یک متد استفاده کنید: &amp;#x3C;li v-for=&amp;#x22;n in even(numbers)&amp;#x22;&amp;#x3E;&#123;&#123; n &#125;&#125;&amp;#x3C;/li&amp;#x3E; data: { numbers: [ 1, 2, 3, 4, 5 ] }, methods: { even: function (numbers) { return numbers.filter(function (number) { return number % 2 === 0 }) } } v-for با یک رنج v-for همچنین می تواند یک عدد صحیح را دریافت نماید. در این حالت این قالب را بارها تکرار می کند. &amp;#x3C;div&amp;#x3E; &amp;#x3C;span v-for=&amp;#x22;n in 10&amp;#x22;&amp;#x3E;&#123;&#123; n &#125;&#125; &amp;#x3C;/span&amp;#x3E; &amp;#x3C;/div&amp;#x3E; نتیجه: 1 2 3 4 5 6 7 8 9 10 v-for با &amp;#x3C;template&amp;#x3E; شبیه به الگوی v-if ، می توانید از تگ &amp;#x3C;template&amp;#x3E; با v-for نیز استفاده کنید تا بتوانید از چندین عنصر از یک بلاک را رندر نمایید. مثلا: &amp;#x3C;ul&amp;#x3E; &amp;#x3C;template v-for=&amp;#x22;item in items&amp;#x22;&amp;#x3E; &amp;#x3C;li&amp;#x3E;&#123;&#123; item.msg &#125;&#125;&amp;#x3C;/li&amp;#x3E; &amp;#x3C;li class=&amp;#x22;divider&amp;#x22; role=&amp;#x22;presentation&amp;#x22;&amp;#x3E;&amp;#x3C;/li&amp;#x3E; &amp;#x3C;/template&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; v-for با v-if توجه داشته باشید که توصیه نمی شود از v-if و v-for با هم استفاده کنید. برای جزئیات بیشتر به style guideمراجعه کنید. هنگامی که آنها در همان گره وجود دارند ، v-for دارای اولویت بالاتری نسبت به v-if است. این بدان معنی است که v-if در هر تکرار حلقه به طور جداگانه اجرا می شود. این می تواند زمانی مفید باشد که می خواهید گره ها را فقط برای برخی موارد ، مانند زیر ارائه دهید: &amp;#x3C;li v-for=&amp;#x22;todo in todos&amp;#x22; v-if=&amp;#x22;!todo.isComplete&amp;#x22;&amp;#x3E; &#123;&#123; todo &#125;&#125; &amp;#x3C;/li&amp;#x3E; موارد فوق فقط todos هایی را که کامل نیستند رندر می شوند. اگر هدف شما از اجرای شرط حلقه بطور شرطی باشد ، می توانید v-if را روی یک عنصر بسته (یا &amp;#x3C;template&amp;#x3E;) قرار دهید. مثلا: &amp;#x3C;ul v-if=&amp;#x22;todos.length&amp;#x22;&amp;#x3E; &amp;#x3C;li v-for=&amp;#x22;todo in todos&amp;#x22;&amp;#x3E; &#123;&#123; todo &#125;&#125; &amp;#x3C;/li&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; &amp;#x3C;p v-else&amp;#x3E;No todos left!&amp;#x3C;/p&amp;#x3E; v-for با Component شما می توانید به طور مستقیم مانند هر عنصر عادی از v-for در یک کامپوننت سفارشی استفاده کنید: &amp;#x3C;my-component v-for=&amp;#x22;item in items&amp;#x22; :key=&amp;#x22;item.id&amp;#x22;&amp;#x3E;&amp;#x3C;/my-component&amp;#x3E; در 2.2.0+ ، هنگام استفاده از v-for با یک کامپوننت ، یک key لازم است. با این وجود ، داده ها به طور خودکار به کامپوننت منتقل نمی شوند ، زیرا کامپوننت دارای محدوده های جدا شده از خود هستند. برای انتقال داده های تکرار شونده در کامپوننت ، باید از props نیز استفاده کنیم: &amp;#x3C;my-component v-for=&amp;#x22;(item, index) in items&amp;#x22; v-bind:item=&amp;#x22;item&amp;#x22; v-bind:index=&amp;#x22;index&amp;#x22; v-bind:key=&amp;#x22;item.id&amp;#x22; &amp;#x3E;&amp;#x3C;/my-component&amp;#x3E; دلیل عدم تزریق خودکار item به کامپوننت این است که باعث می شود این کامپوننت با نحوه کار v-for پیوستگی محکمی ایجاد کند. صریح بودن اطلاعات مربوط به اینکه از کجا تهیه می شود باعث می شود کامپوننت در موقعیت های دیگر قابل استفاده مجدد باشد. در اینجا یک مثال کامل از یک لیست ساده TODO آمده است: &amp;#x3C;div id=&amp;#x22;todo-list-example&amp;#x22;&amp;#x3E; &amp;#x3C;form v-on:submit.prevent=&amp;#x22;addNewTodo&amp;#x22;&amp;#x3E; &amp;#x3C;label for=&amp;#x22;new-todo&amp;#x22;&amp;#x3E;Add a todo&amp;#x3C;/label&amp;#x3E; &amp;#x3C;input v-model=&amp;#x22;newTodoText&amp;#x22; id=&amp;#x22;new-todo&amp;#x22; placeholder=&amp;#x22;E.g. Feed the cat&amp;#x22; &amp;#x3E; &amp;#x3C;button&amp;#x3E;Add&amp;#x3C;/button&amp;#x3E; &amp;#x3C;/form&amp;#x3E; &amp;#x3C;ul&amp;#x3E; &amp;#x3C;li is=&amp;#x22;todo-item&amp;#x22; v-for=&amp;#x22;(todo, index) in todos&amp;#x22; v-bind:key=&amp;#x22;todo.id&amp;#x22; v-bind:title=&amp;#x22;todo.title&amp;#x22; v-on:remove=&amp;#x22;todos.splice(index, 1)&amp;#x22; &amp;#x3E;&amp;#x3C;/li&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; &amp;#x3C;/div&amp;#x3E; توجه داشته باشید که ویژگی is=&quot;todo-item&quot; است. این در الگوهای DOM ضروری است ، زیرا فقط یک عنصر &amp;#x3C;li&amp;#x3E; درون یک &amp;#x3C;ul&amp;#x3E; معتبر است. این همان کار را با &amp;#x3C;todo-item&amp;#x3E; انجام می دهد ، اما در اطراف یک خطای تجزیه مرورگر بالقوه کار می کند. برای کسب اطلاعات بیشتر به الگوی DOM Template Parsing Caveatsمراجعه کنید. Vue.component(&#39;todo-item&#39;, { template: &#39;\ &amp;#x3C;li&amp;#x3E;\ &#123;&#123; title &#125;&#125;\ &amp;#x3C;button v-on:click=&amp;#x22;$emit(\&amp;#x27;remove\&amp;#x27;)&amp;#x22;&amp;#x3E;Remove&amp;#x3C;/button&amp;#x3E;\ &amp;#x3C;/li&amp;#x3E;\ &#39;, props: [&#39;title&#39;] }) new Vue({ el: &#39;#todo-list-example&#39;, data: { newTodoText: &#39;&#39;, todos: [ { id: 1, title: &#39;Do the dishes&#39;, }, { id: 2, title: &#39;Take out the trash&#39;, }, { id: 3, title: &#39;Mow the lawn&#39; } ], nextTodoId: 4 }, methods: { addNewTodo: function () { this.todos.push({ id: this.nextTodoId++, title: this.newTodoText }) this.newTodoText = &#39;&#39; } } })" />
<link rel="canonical" href="http://localhost:4000/documentation/vuejs/Essentials/List-Rendering" />
<meta property="og:url" content="http://localhost:4000/documentation/vuejs/Essentials/List-Rendering" />
<meta property="og:site_name" content="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-10-08T20:08:42+03:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="رندر List (List Rendering)" />
<meta name="twitter:site" content="@farhadmirzapour" />
<meta name="twitter:creator" content="@Farhad Mirzapour" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"رندر List (List Rendering)","url":"http://localhost:4000/documentation/vuejs/Essentials/List-Rendering","datePublished":"2019-10-08T20:08:42+03:30","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/img/logo/blankspace-avatar.png"},"name":"Farhad Mirzapour"},"dateModified":"2019-10-08T20:08:42+03:30","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/documentation/vuejs/Essentials/List-Rendering"},"author":{"@type":"Person","name":"Farhad Mirzapour"},"description":"نگاشت آرایه به عناصر HTML با v-for ما می توانیم از دایرکتیو v-for برای تهیه لیست از آیتم های موجود در آرایه استفاده کنیم. دایرکتیو v-for به صورت item in items به یک نحو خاص نیاز دارد ، که در آن items منبع دیتای آرایه و item یک نام مستعار برای عنصر آرایه که در آن تکرار می شود: &amp;#x3C;ul id=&amp;#x22;example-1&amp;#x22;&amp;#x3E; &amp;#x3C;li v-for=&amp;#x22;item in items&amp;#x22;&amp;#x3E; &#123;&#123; item.message &#125;&#125; &amp;#x3C;/li&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; var example1 = new Vue({ el: &#39;#example-1&#39;, data: { items: [ { message: &#39;Foo&#39; }, { message: &#39;Bar&#39; } ] } }) نتیجه : &#123;&#123; item.message &#125;&#125; در داخل بلوکهای v-for ، دسترسی کامل به ویژگیهای دامنه والدین داریم. v-for همچنین از یک آرگومان دوم اختیاری برای index آیتم فعلی پشتیبانی می کند. &amp;#x3C;ul id=&amp;#x22;example-2&amp;#x22;&amp;#x3E; &amp;#x3C;li v-for=&amp;#x22;(item, index) in items&amp;#x22;&amp;#x3E; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &amp;#x3C;/li&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; var example2 = new Vue({ el: &#39;#example-2&#39;, data: { parentMessage: &#39;Parent&#39;, items: [ { message: &#39;Foo&#39; }, { message: &#39;Bar&#39; } ] } }) نتیجه : &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; شما همچنین می توانید از of به جای in استفاده نمایید که به نحو جاوا اسکریپت برای تکرار کنندگان(iterators) نزدیکتر می باشد: &amp;#x3C;div v-for=&amp;#x22;item of items&amp;#x22;&amp;#x3E;&amp;#x3C;/div&amp;#x3E; استفاده از v-for به همراه object همچنین می توانید از v-for برای تکرار از طریق خواص یک object استفاده کنید. &amp;#x3C;ul id=&amp;#x22;v-for-object&amp;#x22; class=&amp;#x22;demo&amp;#x22;&amp;#x3E; &amp;#x3C;li v-for=&amp;#x22;value in object&amp;#x22;&amp;#x3E; &#123;&#123; value &#125;&#125; &amp;#x3C;/li&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; new Vue({ el: &#39;#v-for-object&#39;, data: { object: { title: &#39;How to do lists in Vue&#39;, author: &#39;Jane Doe&#39;, publishedAt: &#39;2016-04-10&#39; } } }) نتیجه : &#123;&#123; value &#125;&#125; همچنین می توانید یک آرگومان دوم برای نام ویژگی ارائه دهید ( a.k.a. key): &amp;#x3C;div v-for=&amp;#x22;(value, name) in object&amp;#x22;&amp;#x3E; &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125; &amp;#x3C;/div&amp;#x3E; &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125; و برای index: &amp;#x3C;div v-for=&amp;#x22;(value, name, index) in object&amp;#x22;&amp;#x3E; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125; &amp;#x3C;/div&amp;#x3E; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125; هنگام تکرار از طریق یک object ، مرتب سازی بر اساس ترتیب ()Object.keys صورت می گیرد ، که تضمینی ندارد مطابق با پیاده سازی موتور جاوا اسکریپت باشد. حفظ وضعیت (Maintaining State) هنگامی که Vue در حال به روزرسانی لیستی از عناصر رندر شده با v-for است ، به طور پیش فرض از استراتژی &quot; in-place patch &quot; استفاده می کند. اگر ترتیب داده ها تغییر کند ، به جای حرکت دادن عناصر DOM جهت تطبیق با ترتیب آیتم ها ، Vue هر عنصر را در جای خود قرار داده و اطمینان می دهد آنچه باید در آن index خاص رندر شود انعکاس یابد. این شبیه به رفتار track-by=&quot;$index&quot; در Vue 1.x می باشد. این حالت پیش فرض کارآمد است ، اما تنها در شرایطی مناسب است که خروجی لیست رندر شده شما به وضعیت کامپوننت فرزند یا وضعیت DOM موقتی متکی نباشد (مثلاً مقادیر ورودی فرم). برای اشاره و راهنمایی به Vue که هویت هر گره را ردیابی کرده تا بتواند از آن ها استفاده مجدد و عناصر موجود را دوباره مرتب سازی نماید ، نیاز دارید یک ویژگی key منحصر به فرد برای هر آیتم در نظر بگیرید: &amp;#x3C;div v-for=&amp;#x22;item in items&amp;#x22; v-bind:key=&amp;#x22;item.id&amp;#x22;&amp;#x3E; &amp;#x3C;!-- content --&amp;#x3E; &amp;#x3C;/div&amp;#x3E; توصیه می شود در هر زمان ممکن یک ویژگی key با v-for ارائه دهید ، مگر اینکه محتوای DOM تکرار شونده ساده باشد ، یا عمداً جهت افزایش عملکرد ، بر رفتار پیش فرض تکیه می کنید. از آنجا که این یک مکانیسم عمومی جهت شناسایی گره ها توسط Vue است ، این key دارای کاربردهای دیگری نیز می باشد که به طور خاص با V-for گره خورده اند ، همانطور که بعداً در این راهنما خواهیم دید. از مقادیری همانند اشیاء و آرایه ها به عنوان کلیدهای v-for استفاده نکنید. به جای آن از مقادیر رشته یا عددی استفاده کنید. جهت استفاده دقیق از ویژگی key، به API documentation مراجعه نمایید. تشخیص تغییر در آرایه (Array Change Detection) متدهای جهش (Mutation Methods) Vue متدهای mutation (جهش) آرایه ارائه داده که باعث بروزرسانی های view نیز می شود. این متدها عبارتند از: push() pop() shift() unshift() splice() sort() reverse() شما می توانید console مرورگر خود را باز کرده و در مثال قبل با متدها کار کنید.برای مثال : example1.items.push({ message: &#39;Baz&#39; }). جایگیزینی یک آرایه (Replacing an Array) متدهای Mutation ، همانطور که از نام آن مشخص است ، آرایه اصلی مورد نظر را جهش و دگرگون می کنند. در مقایسه ، روشهای غیر جهش نیز وجود دارد ، به عنوان مثال . ()filter(), concat و ()slice، که آرایه اصلی را جهش نمی دهند ، اما همیشه یک آرایه جدید را برمی گردانند. هنگام کار با روش های غیر جهش ، می توانید آرایه قدیمی را با روش جدید جایگزین کنید: example1.items = example1.items.filter(function (item) { return item.message.match(/Foo/) }) ممکن است فکر کنید این امر باعث خواهد شد که DOM، Vue موجود را دور بیندازد و مجدداً لیست را ارائه دهد - خوشبختانه ، اینگونه نیست. Vue برای به حداکثر رساندن استفاده مجدد از عناصر DOM برخی از اکتشافات هوشمند را پیاده سازی می کند ، بنابراین جایگزینی یک آرایه با آرایه دیگری که حاوی اشیاء همپوشانی است ، عملیاتی بسیار کارآمد است. هشدار به دلیل محدودیت های موجود در JavaScript ، Vue نمی تواند تغییرات زیر را در یک آرایه تشخیص دهد: زمانیکه یک آیتم را مستقیما با index جایگزاری می کنید ، به عنوان مثال vm.items [indexOfItem] = newValue زمانیکه طول آرایه را تغییر می دهید ، به عنوان مثال vm.items.length = newLength برای مثال: var vm = new Vue({ data: { items: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] } }) vm.items[1] = &#39;x&#39; // is NOT reactive vm.items.length = 2 // is NOT reactive برای غلبه بر بر هشدار 1 ، هر دو کد زیر کار مشابه با vm.items [indexOfItem] = newValue انجام می دهند ، اما باعث بروزرسانی وضعیت در سیستم واکنش پذیری خواهد شد : // Vue.set Vue.set(vm.items, indexOfItem, newValue) // Array.prototype.splice vm.items.splice(indexOfItem, 1, newValue) همچنین می توانید از متد نمونه vm.$set استفاده کنید که یک نام مستعار برای Vue.set سراسری است: vm.$set(vm.items, indexOfItem, newValue) برای مقابله با هشدار 2 ، می توانید از splice استفاده کنید: vm.items.splice(newLength) Object Change Detection Caveats مجددا به دلیل محدودیت های JavaScript مدرن ، Vue نمی تواند اضافه و یا حذف ویژگی (property) را تشخیص دهد. مثلا: var vm = new Vue({ data: { a: 1 } }) // `vm.a` is now reactive vm.b = 2 // `vm.b` is NOT reactive Vue اجازه نمی دهد به صورت پویا خصوصیات واکنشی سطح ریشه به یک نمونه ایجاد شده اضافه شود. با این وجود ، می توان با استفاده از روش Vue.set(object, propertyName, value) ویژگیهای واکنشی را به یک شیء تو در تو اضافه کرد. به عنوان مثال ، var vm = new Vue({ data: { userProfile: { name: &#39;Anika&#39; } } }) می توانید یک ویژگی جدید سن age را به شیء userProfile تودرتو اضافه کنید با: Vue.set(vm.userProfile, &#39;age&#39;, 27) همچنین می توانید از متد نمونه vm.$set استفاده کنید که یک نام مستعار برای Vue.set سراسری است: vm.$set(vm.userProfile, &#39;age&#39;, 27) بعضی اوقات ممکن است بخواهید تعدادی از ویژگی های جدید را به یک شی موجود اختصاص دهید ، به عنوان مثال با استفاده از ()Object.assign یا ()extend._ . در چنین مواردی ، شما باید یک شیء تازه را با خصوصیات هر دو شی ایجاد کنید. بنابراین به جای: Object.assign(vm.userProfile, { age: 27, favoriteColor: &#39;Vue Green&#39; }) شما می توانید خصوصیات واکنشی جدید را با: vm.userProfile = Object.assign({}, vm.userProfile, { age: 27, favoriteColor: &#39;Vue Green&#39; }) نمایش نتایج Filtered/Sorted بعضی اوقات می خواهیم نسخه مرتب شده یا فیلتر شده از آرایه را نمایش دهیم بدون اینکه در واقع داده های اصلی را تغییر داده یا مجددا تنظیم کنیم. در این حالت ، می توانید یک ویژگی computed ایجاد کنید که آرایه فیلتر شده یا مرتب شده را برمی گرداند. برای مثال: &amp;#x3C;li v-for=&amp;#x22;n in evenNumbers&amp;#x22;&amp;#x3E;&#123;&#123; n &#125;&#125;&amp;#x3C;/li&amp;#x3E; data: { numbers: [ 1, 2, 3, 4, 5 ] }, computed: { evenNumbers: function () { return this.numbers.filter(function (number) { return number % 2 === 0 }) } } در شرایطی که ویژگی های computed امکان پذیر نیست (به عنوان مثال در داخل حلقه های تودردتو v-for ) ، می توانید از یک متد استفاده کنید: &amp;#x3C;li v-for=&amp;#x22;n in even(numbers)&amp;#x22;&amp;#x3E;&#123;&#123; n &#125;&#125;&amp;#x3C;/li&amp;#x3E; data: { numbers: [ 1, 2, 3, 4, 5 ] }, methods: { even: function (numbers) { return numbers.filter(function (number) { return number % 2 === 0 }) } } v-for با یک رنج v-for همچنین می تواند یک عدد صحیح را دریافت نماید. در این حالت این قالب را بارها تکرار می کند. &amp;#x3C;div&amp;#x3E; &amp;#x3C;span v-for=&amp;#x22;n in 10&amp;#x22;&amp;#x3E;&#123;&#123; n &#125;&#125; &amp;#x3C;/span&amp;#x3E; &amp;#x3C;/div&amp;#x3E; نتیجه: 1 2 3 4 5 6 7 8 9 10 v-for با &amp;#x3C;template&amp;#x3E; شبیه به الگوی v-if ، می توانید از تگ &amp;#x3C;template&amp;#x3E; با v-for نیز استفاده کنید تا بتوانید از چندین عنصر از یک بلاک را رندر نمایید. مثلا: &amp;#x3C;ul&amp;#x3E; &amp;#x3C;template v-for=&amp;#x22;item in items&amp;#x22;&amp;#x3E; &amp;#x3C;li&amp;#x3E;&#123;&#123; item.msg &#125;&#125;&amp;#x3C;/li&amp;#x3E; &amp;#x3C;li class=&amp;#x22;divider&amp;#x22; role=&amp;#x22;presentation&amp;#x22;&amp;#x3E;&amp;#x3C;/li&amp;#x3E; &amp;#x3C;/template&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; v-for با v-if توجه داشته باشید که توصیه نمی شود از v-if و v-for با هم استفاده کنید. برای جزئیات بیشتر به style guideمراجعه کنید. هنگامی که آنها در همان گره وجود دارند ، v-for دارای اولویت بالاتری نسبت به v-if است. این بدان معنی است که v-if در هر تکرار حلقه به طور جداگانه اجرا می شود. این می تواند زمانی مفید باشد که می خواهید گره ها را فقط برای برخی موارد ، مانند زیر ارائه دهید: &amp;#x3C;li v-for=&amp;#x22;todo in todos&amp;#x22; v-if=&amp;#x22;!todo.isComplete&amp;#x22;&amp;#x3E; &#123;&#123; todo &#125;&#125; &amp;#x3C;/li&amp;#x3E; موارد فوق فقط todos هایی را که کامل نیستند رندر می شوند. اگر هدف شما از اجرای شرط حلقه بطور شرطی باشد ، می توانید v-if را روی یک عنصر بسته (یا &amp;#x3C;template&amp;#x3E;) قرار دهید. مثلا: &amp;#x3C;ul v-if=&amp;#x22;todos.length&amp;#x22;&amp;#x3E; &amp;#x3C;li v-for=&amp;#x22;todo in todos&amp;#x22;&amp;#x3E; &#123;&#123; todo &#125;&#125; &amp;#x3C;/li&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; &amp;#x3C;p v-else&amp;#x3E;No todos left!&amp;#x3C;/p&amp;#x3E; v-for با Component شما می توانید به طور مستقیم مانند هر عنصر عادی از v-for در یک کامپوننت سفارشی استفاده کنید: &amp;#x3C;my-component v-for=&amp;#x22;item in items&amp;#x22; :key=&amp;#x22;item.id&amp;#x22;&amp;#x3E;&amp;#x3C;/my-component&amp;#x3E; در 2.2.0+ ، هنگام استفاده از v-for با یک کامپوننت ، یک key لازم است. با این وجود ، داده ها به طور خودکار به کامپوننت منتقل نمی شوند ، زیرا کامپوننت دارای محدوده های جدا شده از خود هستند. برای انتقال داده های تکرار شونده در کامپوننت ، باید از props نیز استفاده کنیم: &amp;#x3C;my-component v-for=&amp;#x22;(item, index) in items&amp;#x22; v-bind:item=&amp;#x22;item&amp;#x22; v-bind:index=&amp;#x22;index&amp;#x22; v-bind:key=&amp;#x22;item.id&amp;#x22; &amp;#x3E;&amp;#x3C;/my-component&amp;#x3E; دلیل عدم تزریق خودکار item به کامپوننت این است که باعث می شود این کامپوننت با نحوه کار v-for پیوستگی محکمی ایجاد کند. صریح بودن اطلاعات مربوط به اینکه از کجا تهیه می شود باعث می شود کامپوننت در موقعیت های دیگر قابل استفاده مجدد باشد. در اینجا یک مثال کامل از یک لیست ساده TODO آمده است: &amp;#x3C;div id=&amp;#x22;todo-list-example&amp;#x22;&amp;#x3E; &amp;#x3C;form v-on:submit.prevent=&amp;#x22;addNewTodo&amp;#x22;&amp;#x3E; &amp;#x3C;label for=&amp;#x22;new-todo&amp;#x22;&amp;#x3E;Add a todo&amp;#x3C;/label&amp;#x3E; &amp;#x3C;input v-model=&amp;#x22;newTodoText&amp;#x22; id=&amp;#x22;new-todo&amp;#x22; placeholder=&amp;#x22;E.g. Feed the cat&amp;#x22; &amp;#x3E; &amp;#x3C;button&amp;#x3E;Add&amp;#x3C;/button&amp;#x3E; &amp;#x3C;/form&amp;#x3E; &amp;#x3C;ul&amp;#x3E; &amp;#x3C;li is=&amp;#x22;todo-item&amp;#x22; v-for=&amp;#x22;(todo, index) in todos&amp;#x22; v-bind:key=&amp;#x22;todo.id&amp;#x22; v-bind:title=&amp;#x22;todo.title&amp;#x22; v-on:remove=&amp;#x22;todos.splice(index, 1)&amp;#x22; &amp;#x3E;&amp;#x3C;/li&amp;#x3E; &amp;#x3C;/ul&amp;#x3E; &amp;#x3C;/div&amp;#x3E; توجه داشته باشید که ویژگی is=&quot;todo-item&quot; است. این در الگوهای DOM ضروری است ، زیرا فقط یک عنصر &amp;#x3C;li&amp;#x3E; درون یک &amp;#x3C;ul&amp;#x3E; معتبر است. این همان کار را با &amp;#x3C;todo-item&amp;#x3E; انجام می دهد ، اما در اطراف یک خطای تجزیه مرورگر بالقوه کار می کند. برای کسب اطلاعات بیشتر به الگوی DOM Template Parsing Caveatsمراجعه کنید. Vue.component(&#39;todo-item&#39;, { template: &#39;\\ &amp;#x3C;li&amp;#x3E;\\ &#123;&#123; title &#125;&#125;\\ &amp;#x3C;button v-on:click=&amp;#x22;$emit(\\&amp;#x27;remove\\&amp;#x27;)&amp;#x22;&amp;#x3E;Remove&amp;#x3C;/button&amp;#x3E;\\ &amp;#x3C;/li&amp;#x3E;\\ &#39;, props: [&#39;title&#39;] }) new Vue({ el: &#39;#todo-list-example&#39;, data: { newTodoText: &#39;&#39;, todos: [ { id: 1, title: &#39;Do the dishes&#39;, }, { id: 2, title: &#39;Take out the trash&#39;, }, { id: 3, title: &#39;Mow the lawn&#39; } ], nextTodoId: 4 }, methods: { addNewTodo: function () { this.todos.push({ id: this.nextTodoId++, title: this.newTodoText }) this.newTodoText = &#39;&#39; } } })","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <!-- stylesheets -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css">
    <link rel="stylesheet" href="/assets/main.css">
    <link rel="stylesheet" href="/assets/prisma/prism.css">
    <!-- favicons and rss -->
    <link rel="alternate" type="application/rss+xml" title="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" href="/feed.xml">
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/img/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/img/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/img/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
</head>
<body>
<!-- header -->
<header class="header" role="banner" aria-label="Header">
    <button class="hamburger-button" onclick="hamburgerMenu();" role="button" aria-label="Hamburger menu button">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </button>
    <a href="/" class="logo" role="link" aria-label="Home">
        <img alt="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" src="/assets/img/logo/farhadmirzapour-logo.png" role="img" aria-label="Logo"/>
    </a>
    <nav class="navigation" role="navigation" aria-label="Navigation">
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
            <li role="menuitem" aria-label="Navigation menu item">
                <a href="/" class="logo" role="menuitem" aria-label="Home">
                    <img alt="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" src="/assets/img/logo/farhadmirzapour-logo.png" role="img" aria-label="Logo"/>
                </a>
            </li>
            
            <li role="menuitem"><a href="/blog" role="menuitem" aria-label="مقالات">مقالات</a></li>
            
            <li role="menuitem"><a href="/contactus" role="menuitem" aria-label="تماس">تماس</a></li>
            
        </ul>
    </nav>
    <div class="searchbox" role="search" aria-label="Search">
        <form action="/search" id="searchthis" method="get" role="form" aria-label="Search form">
            <i class="fa fa-search" aria-hidden="true"></i>
            <input type="search" id="search" name="query" placeholder="Search..." role="textbox" aria-label="Search textbox"/>
        </form>
    </div>
</header>

<nav id="hamburger-menu" role="navigation" aria-label="Hamburger menu">
    <div class="searchbox" role="search" aria-label="Search">
        <form action="/search" id="searchthis" method="get" role="form" aria-label="Search form">
            <i class="fa fa-search" aria-hidden="true"></i>
            <input type="search" id="search" name="query" placeholder="Search..." role="textbox" aria-label="Search textbox"/>
        </form>
    </div>
    <div class="home-nav" role="navigation" aria-label="Site navigation">
        <a href="/" role="menuitem" aria-label="Home">صفحه اصلی</a>
        
        <a href="/blog" role="menuitem" aria-label="مقالات">مقالات</a>
        
        <a href="/contactus" role="menuitem" aria-label="تماس">تماس</a>
        
    </div>

    
    <div class="doc-nav" role="navigation" aria-label="Documentation navigation">
        <p role="presentation" aria-label="Category name">
            اصول آموزش vuejs
        </p>
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
            <li role="menuitem" aria-label="Navigation menu item"><a href="/2019/10/11/vuejs.html" class="doc-link" role="link" aria-label="رندر List (List Rendering)">مقدمه</a></li>
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/vuejs/Essentials/The-Vue-Instance" class="doc-link" role="link" aria-label="ایجاد نمونه Vue">ایجاد نمونه Vue</a></li>
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/vuejs/Essentials/Template-Syntax" class="doc-link" role="link" aria-label="اصول قالب در Vue">اصول قالب در Vue</a></li>
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/vuejs/Essentials/Computed-Properties-and-Watchers" class="doc-link" role="link" aria-label="خاصیت Computed و Watchers">خاصیت Computed و Watchers</a></li>
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/vuejs/Essentials/Class-and-Style-Bindings" class="doc-link" role="link" aria-label="اتصال Class و Style">اتصال Class و Style</a></li>
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/vuejs/Essentials/Conditional-Rendering" class="doc-link" role="link" aria-label="رندرینگ شرطی  (Conditional Rendering)">رندرینگ شرطی  (Conditional Rendering)</a></li>
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/vuejs/Essentials/List-Rendering" class="doc-link" role="link" aria-label="رندر List (List Rendering)">رندر List (List Rendering)</a></li>
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/vuejs/Essentials/Event-Handling" class="doc-link" role="link" aria-label="کار با رویدادها(Event Handling)">کار با رویدادها(Event Handling)</a></li>
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/vuejs/Essentials/Form-Input-Bindings" class="doc-link" role="link" aria-label="اتصال داده به ورودی فرم (Form Input Bindings)">اتصال داده به ورودی فرم (Form Input Bindings)</a></li>
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/vuejs/Essentials/Components-Basics" class="doc-link" role="link" aria-label="اصول پایه Component">اصول پایه Component</a></li>
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/vuejs/Components-In-Depth/Component-Registration" class="doc-link" role="link" aria-label="ثبت Component">ثبت Component</a></li>
            
            
            
            
            
            
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/vuejs/Components-In-Depth/components-props" class="doc-link" role="link" aria-label="props">props</a></li>
            
            
        </ul>
    </div>
    
</nav>
<!-- main content -->
<main class="container" role="main">
    <div class="rcdoccontainerimg">
<div class="rc-DRTVBanner-new rc-DRTVBanner-bigsize">
    <div style="background: url('/images/original/vuejs.jpg'); " class="blurred_img"></div>
    <div class="mask"></div>
    <div class="bot"></div>
    <div class="over">
        <div class="container-rc">
            <img class="image" src="/images/original/vuejs.jpg" alt="رندر List (List Rendering)" height="190">
            <div class="desktop-banner-container">
                <h1 class="display-5-text headline">
                    
                    
                    اصول آموزش vuejs
                    </h1>
                <!--<div class="tagslist"><ul class='lyda-tag-list'><li class='lyda-tag-list-title'>برچسب ها</li><li><a class="tags" href="/tag/لاراول">#لاراول</a></li><li><a class="tags" href="/tag/لاراول-5-5">#لاراول 5.5</a></li></ul></div>-->
            </div>
        </div>
    </div>
</div>

<!--<div class="bread-crumb">-->
<!--<div class="container   ">-->
<!--<div class="pull-right ">-->
<!--<div class="bread-button text-custom b-left">-->
<!--انتشار : 2 ماه پیش-->
<!--</div>-->
<!--<a href="/category/article/" class="bread-button back-to-all b-left hidden-xs">همه مقالات</a>-->
<!--<div class="cat-lable">-->
<!--<a href="/category/article/laravel/">-->
<!--لاراول-->
<!--</a>-->
<!--</div>-->
<!--</div>-->
<!--</div>-->
<!--</div>-->
<script>
    $(window).scroll(function(){
        var sticky = $('.doc-menu'),
            scroll = $(window).scrollTop();
        if (scroll >= 101) {sticky.addClass('doc-header-scroll'); }
        else {sticky.removeClass('doc-header-scroll'); };
    });
</script>
</div>
<div class="doc-container">

    <div class="doc-menu">
    
    <ul>
        <li>
            <a  href="/2019/10/11/vuejs.html" class="active doc-link" role="link">
                مقدمه
            </a>
        </li>
        
        <li>
            <span class="caret">مفاهیم اساسی</span>
            <ul>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        <li>
            <a title="ایجاد نمونه Vue" href="/documentation/vuejs/Essentials/The-Vue-Instance" class="active doc-link" role="link">
                ایجاد نمونه Vue
            </a>
        </li>
        
        
        
        <li>
            <a title="اصول قالب در Vue" href="/documentation/vuejs/Essentials/Template-Syntax" class="active doc-link" role="link">
                اصول قالب در Vue
            </a>
        </li>
        
        
        
        <li>
            <a title="خاصیت Computed و Watchers" href="/documentation/vuejs/Essentials/Computed-Properties-and-Watchers" class="active doc-link" role="link">
                خاصیت Computed و Watchers
            </a>
        </li>
        
        
        
        <li>
            <a title="اتصال Class و Style" href="/documentation/vuejs/Essentials/Class-and-Style-Bindings" class="active doc-link" role="link">
                اتصال Class و Style
            </a>
        </li>
        
        
        
        <li>
            <a title="رندرینگ شرطی  (Conditional Rendering)" href="/documentation/vuejs/Essentials/Conditional-Rendering" class="active doc-link" role="link">
                رندرینگ شرطی  (Conditional Rendering)
            </a>
        </li>
        
        
        
        <li>
            <a title="رندر List (List Rendering)" href="/documentation/vuejs/Essentials/List-Rendering" class="active doc-link" role="link">
                رندر List (List Rendering)
            </a>
        </li>
        
        
        
        <li>
            <a title="کار با رویدادها(Event Handling)" href="/documentation/vuejs/Essentials/Event-Handling" class="active doc-link" role="link">
                کار با رویدادها(Event Handling)
            </a>
        </li>
        
        
        
        <li>
            <a title="اتصال داده به ورودی فرم (Form Input Bindings)" href="/documentation/vuejs/Essentials/Form-Input-Bindings" class="active doc-link" role="link">
                اتصال داده به ورودی فرم (Form Input Bindings)
            </a>
        </li>
        
        
        
        <li>
            <a title="اصول پایه Component" href="/documentation/vuejs/Essentials/Components-Basics" class="active doc-link" role="link">
                اصول پایه Component
            </a>
        </li>
        
        
        
        
        
        
        
        
        
        
        
        
            </ul>
        </li>
        
        <li>
            <span class="caret">کامپوننت ها</span>
            <ul>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        <li>
            <a title="ثبت Component" href="/documentation/vuejs/Components-In-Depth/Component-Registration" class="active doc-link" role="link">
                ثبت Component
            </a>
        </li>
        
        
        
        
        
        
        
        
        
        <li>
            <a title="props" href="/documentation/vuejs/Components-In-Depth/components-props" class="active doc-link" role="link">
                props
            </a>
        </li>
        
        
            </ul>
        </li>
        
    </ul>
    
</div>

    <article class="documentation">
        <header class="doc-header">
            <div class="time">
                    تاریخ :      سه شنبه 16 مهر 1398
            </div>
                
        </header>
        <section class="anchored">
            <h3>نگاشت آرایه به عناصر HTML با v-for</h3>
<p>
ما می توانیم از دایرکتیو v-for برای تهیه لیست از آیتم های  موجود در آرایه استفاده کنیم. دایرکتیو v-for  به صورت item in items به یک نحو خاص  نیاز دارد ، که در آن items  منبع دیتای آرایه  و item   یک نام مستعار برای عنصر آرایه که در آن تکرار می شود:
</p>

<pre><code class="language-html  line-numbers">&#x3C;ul id=&#x22;example-1&#x22;&#x3E;
  &#x3C;li v-for=&#x22;item in items&#x22;&#x3E;
    &#123;&#123; item.message &#125;&#125;
  &#x3C;/li&#x3E;
&#x3C;/ul&#x3E;
</code></pre>

<pre><code class="language-javascript  line-numbers">var example1 = new Vue({
  el: '#example-1',
  data: {
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
</code></pre>

<p>
نتیجه :
</p>

<div id="app1" class="result-example">
<ul>
<li v-for="item in items">&#123;&#123; item.message &#125;&#125;</li>
</ul>
</div>

<p>
در داخل بلوکهای v-for ، دسترسی کامل به ویژگیهای دامنه والدین داریم. v-for همچنین از یک آرگومان دوم اختیاری برای index  آیتم فعلی پشتیبانی می کند.
</p>

<pre><code class="language-html  line-numbers">&#x3C;ul id=&#x22;example-2&#x22;&#x3E;
  &#x3C;li v-for=&#x22;(item, index) in items&#x22;&#x3E;
    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;
  &#x3C;/li&#x3E;
&#x3C;/ul&#x3E;
</code></pre>

<pre><code class="language-javascript  line-numbers">var example2 = new Vue({
  el: '#example-2',
  data: {
    parentMessage: 'Parent',
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
</code></pre>

<p>
نتیجه :
</p>

<div id="app2" class="result-example">
<ul>
  <li v-for="(item, index) in items">
    &#123;&#123; parentMessage &#125;&#125; -  &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;
  </li>
</ul>
</div>

<p>
شما همچنین می توانید از of به جای in استفاده نمایید که به نحو جاوا اسکریپت برای تکرار کنندگان(iterators) نزدیکتر می باشد:
</p>

<pre><code class="language-html  line-numbers">&#x3C;div v-for=&#x22;item of items&#x22;&#x3E;&#x3C;/div&#x3E;
</code></pre>

<p><br /></p>

<h3>استفاده از v-for به همراه object</h3>
<p>
همچنین می توانید از v-for برای تکرار از طریق خواص یک object استفاده کنید.
</p>

<pre><code class="language-html  line-numbers">&#x3C;ul id=&#x22;v-for-object&#x22; class=&#x22;demo&#x22;&#x3E;
  &#x3C;li v-for=&#x22;value in object&#x22;&#x3E;
    &#123;&#123; value &#125;&#125;
  &#x3C;/li&#x3E;
&#x3C;/ul&#x3E;
</code></pre>

<pre><code class="language-javascript  line-numbers">new Vue({
  el: '#v-for-object',
  data: {
    object: {
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
  }
})
</code></pre>

<p>
نتیجه :
</p>

<div id="app3" class="result-example">
<ul>
  <li v-for="value in object">
    &#123;&#123; value &#125;&#125;
  </li>
</ul>
</div>

<p>
همچنین می توانید یک آرگومان دوم برای نام ویژگی ارائه دهید ( a.k.a. key):
</p>

<pre><code class="language-html  line-numbers">&#x3C;div v-for=&#x22;(value, name) in object&#x22;&#x3E;
  &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;
&#x3C;/div&#x3E;
</code></pre>
<div id="app4" class="result-example">
<div v-for="(value, name) in object">
  &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;
</div>
</div>

<p>
و برای  index:
</p>

<pre><code class="language-html  line-numbers">&#x3C;div v-for=&#x22;(value, name, index) in object&#x22;&#x3E;
  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;
&#x3C;/div&#x3E;
</code></pre>

<div id="app5" class="result-example">
<div v-for="(value, name, index) in object">
  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;
</div>
</div>

<blockquote class="has-icon tip">
هنگام تکرار از طریق یک object ، مرتب سازی بر اساس ترتیب  ()Object.keys صورت می گیرد ، که تضمینی ندارد مطابق با پیاده سازی موتور جاوا اسکریپت باشد.
</blockquote>
<p><br /></p>

<h3>حفظ وضعیت (Maintaining State)</h3>

<p>
هنگامی که Vue در حال به روزرسانی لیستی از عناصر رندر شده با v-for است ، به طور پیش فرض از استراتژی  " in-place patch " استفاده می کند. اگر ترتیب داده ها تغییر کند ، به جای حرکت دادن عناصر DOM جهت تطبیق با ترتیب آیتم ها ، Vue هر عنصر را در جای خود قرار داده و اطمینان می دهد آنچه باید در آن index خاص رندر شود انعکاس یابد. این شبیه به رفتار track-by="$index" در Vue 1.x می باشد.
</p>

<p>
این حالت پیش فرض کارآمد است ، اما تنها در شرایطی مناسب است که خروجی لیست رندر شده شما به وضعیت کامپوننت فرزند  یا وضعیت DOM موقتی متکی نباشد (مثلاً مقادیر ورودی فرم).
</p>

<p>
برای اشاره و راهنمایی به Vue که هویت هر گره را ردیابی کرده  تا بتواند از آن ها استفاده مجدد و عناصر موجود را دوباره مرتب سازی نماید ، نیاز دارید یک ویژگی key منحصر به فرد برای هر آیتم در نظر بگیرید:
</p>

<pre><code class="language-html  line-numbers">&#x3C;div v-for=&#x22;item in items&#x22; v-bind:key=&#x22;item.id&#x22;&#x3E;
  &#x3C;!-- content --&#x3E;
&#x3C;/div&#x3E;
</code></pre>

<p>
توصیه می شود در هر زمان ممکن یک ویژگی key با v-for ارائه دهید ، مگر اینکه محتوای DOM تکرار شونده ساده باشد ، یا عمداً جهت افزایش عملکرد ، بر رفتار پیش فرض تکیه می کنید.
</p>

<p>
از آنجا که این یک مکانیسم عمومی جهت شناسایی گره ها توسط Vue است ، این key دارای کاربردهای دیگری نیز می باشد که به طور خاص با V-for گره خورده اند ، همانطور که بعداً در این راهنما خواهیم دید.
</p>

<blockquote class="has-icon tip">
از مقادیری همانند اشیاء و آرایه ها به عنوان کلیدهای v-for استفاده نکنید. به جای آن از مقادیر رشته یا عددی استفاده کنید.
</blockquote>

<p>
جهت استفاده دقیق از ویژگی key، به <a href="https://vuejs.org/v2/api/#key" target="_blank">  API documentation </a>  مراجعه نمایید.
</p>

<p><br /></p>

<h3>تشخیص تغییر در آرایه (Array Change Detection)</h3>

<h4> متدهای جهش (Mutation Methods)</h4>

<p>
Vue متدهای mutation  (جهش) آرایه ارائه داده  که باعث بروزرسانی های view نیز می شود. این متدها عبارتند از:
</p>

<p style="direction: ltr;text-align: left">
<ul style="direction: ltr;text-align: left">
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
</p>

<p>
شما می توانید console مرورگر خود را باز کرده و در مثال قبل با متدها کار کنید.برای مثال : example1.items.push({ message: 'Baz' }).
</p>

<h4>جایگیزینی یک آرایه (Replacing an Array)</h4>
<p>
متدهای Mutation ، همانطور که از نام آن مشخص است ، آرایه اصلی مورد نظر را جهش و دگرگون می کنند. در مقایسه ، روشهای غیر جهش نیز وجود دارد ، به عنوان مثال . ()filter(), concat  و ()slice، که آرایه اصلی را جهش نمی دهند ، اما همیشه یک آرایه جدید را برمی گردانند. هنگام کار با روش های غیر جهش ، می توانید آرایه قدیمی را با روش جدید جایگزین کنید:
</p>

<pre><code class="language-javascript  line-numbers">example1.items = example1.items.filter(function (item) {
  return item.message.match(/Foo/)
})
</code></pre>

<p>
ممکن است فکر کنید این امر باعث خواهد شد که DOM،  Vue موجود را دور بیندازد و مجدداً لیست را ارائه دهد - خوشبختانه ، اینگونه نیست. Vue برای به حداکثر رساندن استفاده مجدد از عناصر DOM برخی از اکتشافات هوشمند را پیاده سازی می کند ، بنابراین جایگزینی یک آرایه با آرایه دیگری که حاوی اشیاء همپوشانی است ، عملیاتی بسیار کارآمد است.
</p>

<p><br /></p>

<h4>هشدار</h4>

<p>
به دلیل محدودیت های موجود در JavaScript ، Vue نمی تواند تغییرات زیر را در یک آرایه تشخیص دهد:
</p>

<p>
<ul>
<li>
زمانیکه یک آیتم را مستقیما با index جایگزاری می کنید ، به عنوان مثال vm.items [indexOfItem] = newValue
</li>
<li>
زمانیکه طول آرایه را تغییر می دهید ، به عنوان مثال vm.items.length = newLength
</li>
</ul>
</p>

<p>
برای مثال:
</p>

<pre><code class="language-javascript  line-numbers">var vm = new Vue({
  data: {
    items: ['a', 'b', 'c']
  }
})
vm.items[1] = 'x' // is NOT reactive
vm.items.length = 2 // is NOT reactive
</code></pre>

<p>
برای غلبه بر بر هشدار 1 ، هر دو کد زیر کار مشابه با vm.items [indexOfItem] = newValue انجام می دهند ، اما باعث بروزرسانی وضعیت در سیستم واکنش پذیری خواهد شد :
</p>

<pre><code class="language-javascript  line-numbers">// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
</code></pre>

<pre><code class="language-javascript  line-numbers">// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
</code></pre>

<p>
همچنین می توانید از متد نمونه vm.$set  استفاده کنید که یک نام مستعار برای  Vue.set سراسری است:
</p>

<pre><code class="language-javascript  line-numbers">vm.$set(vm.items, indexOfItem, newValue)
</code></pre>

<p>
برای مقابله با هشدار 2 ، می توانید از splice استفاده کنید:
</p>

<pre><code class="language-javascript  line-numbers">vm.items.splice(newLength)
</code></pre>
<p><br /></p>

<h4>Object Change Detection Caveats</h4>
<p>
مجددا به دلیل محدودیت های JavaScript مدرن ، Vue نمی تواند اضافه و یا حذف ویژگی (property)  را تشخیص دهد. مثلا:
</p>

<pre><code class="language-javascript  line-numbers">var vm = new Vue({
  data: {
    a: 1
  }
})
// `vm.a` is now reactive

vm.b = 2
// `vm.b` is NOT reactive
</code></pre>

<p>
Vue اجازه نمی دهد به صورت پویا خصوصیات واکنشی سطح ریشه به یک نمونه ایجاد شده اضافه شود. با این وجود ، می توان با استفاده از روش Vue.set(object, propertyName, value)  ویژگیهای واکنشی را به یک شیء تو در تو اضافه کرد. به عنوان مثال ،
</p>

<pre><code class="language-javascript  line-numbers">var vm = new Vue({
  data: {
    userProfile: {
      name: 'Anika'
    }
  }
})
</code></pre>

<p>
می توانید یک ویژگی جدید سن age  را به شیء userProfile   تودرتو اضافه کنید با:
</p>

<pre><code class="language-javascript  line-numbers">Vue.set(vm.userProfile, 'age', 27)
</code></pre>

<p>
همچنین می توانید از متد نمونه vm.$set  استفاده کنید که یک نام مستعار برای Vue.set سراسری است:
</p>

<pre><code class="language-javascript  line-numbers">vm.$set(vm.userProfile, 'age', 27)
</code></pre>

<p>
بعضی اوقات ممکن است بخواهید تعدادی از ویژگی های جدید را به یک شی موجود اختصاص دهید ، به عنوان مثال با استفاده از ()Object.assign    یا ()extend._ . در چنین مواردی ، شما باید یک شیء تازه را با خصوصیات هر دو شی  ایجاد کنید. بنابراین به جای:
</p>

<pre><code class="language-javascript  line-numbers">Object.assign(vm.userProfile, {
  age: 27,
  favoriteColor: 'Vue Green'
})
</code></pre>

<p>
شما می توانید خصوصیات واکنشی جدید را با:
</p>

<pre><code class="language-javascript  line-numbers">vm.userProfile = Object.assign({}, vm.userProfile, {
  age: 27,
  favoriteColor: 'Vue Green'
})
</code></pre>
<p><br /></p>

<h3>نمایش نتایج  Filtered/Sorted</h3>
<p>
بعضی اوقات می خواهیم نسخه مرتب شده یا فیلتر شده از آرایه را نمایش دهیم بدون اینکه در واقع داده های اصلی را تغییر داده یا مجددا تنظیم کنیم. در این حالت ، می توانید یک ویژگی computed  ایجاد کنید که آرایه فیلتر شده یا مرتب شده را برمی گرداند.
</p>

<p>
برای مثال:
</p>

<pre><code class="language-html  line-numbers">&#x3C;li v-for=&#x22;n in evenNumbers&#x22;&#x3E;&#123;&#123; n &#125;&#125;&#x3C;/li&#x3E;
</code></pre>

<pre><code class="language-javascript  line-numbers">data: {
  numbers: [ 1, 2, 3, 4, 5 ]
},
computed: {
  evenNumbers: function () {
    return this.numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}
</code></pre>

<p>
در شرایطی که ویژگی های computed امکان پذیر نیست (به عنوان مثال در داخل حلقه های تودردتو v-for ) ، می توانید از یک متد استفاده کنید:
</p>

<pre><code class="language-html  line-numbers">&#x3C;li v-for=&#x22;n in even(numbers)&#x22;&#x3E;&#123;&#123; n &#125;&#125;&#x3C;/li&#x3E;
</code></pre>

<pre><code class="language-javascript  line-numbers">data: {
  numbers: [ 1, 2, 3, 4, 5 ]
},
methods: {
  even: function (numbers) {
    return numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}
</code></pre>
<p><br /></p>

<h3>v-for با یک رنج</h3>
<p>
v-for همچنین می تواند یک عدد صحیح را دریافت نماید. در این حالت این قالب را بارها تکرار می کند.
</p>

<pre><code class="language-html  line-numbers">&#x3C;div&#x3E;
  &#x3C;span v-for=&#x22;n in 10&#x22;&#x3E;&#123;&#123; n &#125;&#125; &#x3C;/span&#x3E;
&#x3C;/div&#x3E;
</code></pre>

<p>
نتیجه:
</p>

<p>
<div id="range" class="demo"><span>1 </span><span>2 </span><span>3 </span><span>4 </span><span>5 </span><span>6 </span><span>7 </span><span>8 </span><span>9 </span><span>10 </span></div>
</p>
<p><br /></p>

<h3>v-for با &#x3C;template&#x3E;</h3>
<p>
شبیه به الگوی v-if ، می توانید از تگ &#x3C;template&#x3E; با v-for نیز استفاده کنید تا بتوانید از چندین عنصر از یک بلاک را رندر نمایید. مثلا:
</p>

<pre><code class="language-html  line-numbers">&#x3C;ul&#x3E;
  &#x3C;template v-for=&#x22;item in items&#x22;&#x3E;
    &#x3C;li&#x3E;&#123;&#123; item.msg &#125;&#125;&#x3C;/li&#x3E;
    &#x3C;li class=&#x22;divider&#x22; role=&#x22;presentation&#x22;&#x3E;&#x3C;/li&#x3E;
  &#x3C;/template&#x3E;
&#x3C;/ul&#x3E;
</code></pre>

<p><br /></p>

<h3>v-for با v-if</h3>

<blockquote class="has-icon tip">
توجه داشته باشید که توصیه نمی شود از v-if و v-for با هم استفاده کنید. برای جزئیات بیشتر به <a href="https://vuejs.org/v2/style-guide/#Avoid-v-if-with-v-for-essential" target="_blank">style guide</a>مراجعه کنید.
</blockquote>

<p>
هنگامی که آنها در همان گره وجود دارند ، v-for دارای اولویت بالاتری نسبت به v-if است. این بدان معنی است که v-if در هر تکرار حلقه به طور جداگانه اجرا می شود. این می تواند زمانی مفید باشد که می خواهید گره ها را فقط برای برخی موارد ، مانند زیر ارائه دهید:
</p>

<pre><code class="language-html  line-numbers">&#x3C;li v-for=&#x22;todo in todos&#x22; v-if=&#x22;!todo.isComplete&#x22;&#x3E;
  &#123;&#123; todo &#125;&#125;
&#x3C;/li&#x3E;
</code></pre>

<p>
موارد فوق فقط todos هایی را که کامل نیستند رندر می شوند.
</p>

<p>
اگر هدف شما از اجرای شرط حلقه بطور شرطی باشد ، می توانید v-if را روی یک عنصر بسته (یا &#x3C;template&#x3E;) قرار دهید. مثلا:
</p>

<pre><code class="language-html  line-numbers">&#x3C;ul v-if=&#x22;todos.length&#x22;&#x3E;
  &#x3C;li v-for=&#x22;todo in todos&#x22;&#x3E;
    &#123;&#123; todo &#125;&#125;
  &#x3C;/li&#x3E;
&#x3C;/ul&#x3E;
&#x3C;p v-else&#x3E;No todos left!&#x3C;/p&#x3E;
</code></pre>

<p><br /></p>

<h3>v-for با Component</h3>

<p>
شما می توانید به طور مستقیم مانند هر عنصر عادی از v-for در یک کامپوننت سفارشی استفاده کنید:
</p>

<pre><code class="language-html  line-numbers">&#x3C;my-component v-for=&#x22;item in items&#x22; :key=&#x22;item.id&#x22;&#x3E;&#x3C;/my-component&#x3E;
</code></pre>

<blockquote class="has-icon tip">
در 2.2.0+ ، هنگام استفاده از v-for با یک کامپوننت ، یک key لازم است.
</blockquote>

<p>
با این وجود ، داده ها به طور خودکار به کامپوننت منتقل نمی شوند ، زیرا کامپوننت دارای محدوده های جدا شده از خود هستند. برای انتقال داده های تکرار شونده در کامپوننت ، باید از props  نیز استفاده کنیم:
</p>

<pre><code class="language-html  line-numbers">&#x3C;my-component
  v-for=&#x22;(item, index) in items&#x22;
  v-bind:item=&#x22;item&#x22;
  v-bind:index=&#x22;index&#x22;
  v-bind:key=&#x22;item.id&#x22;
&#x3E;&#x3C;/my-component&#x3E;
</code></pre>

<p>
دلیل عدم تزریق خودکار item  به کامپوننت این است که باعث می شود این کامپوننت با نحوه کار v-for  پیوستگی محکمی  ایجاد کند. صریح بودن اطلاعات مربوط به اینکه از کجا تهیه می شود باعث می شود کامپوننت در موقعیت های دیگر قابل استفاده مجدد باشد.
</p>

<p>
در اینجا یک مثال کامل از یک لیست ساده TODO آمده است:
</p>

<pre><code class="language-html  line-numbers">&#x3C;div id=&#x22;todo-list-example&#x22;&#x3E;
  &#x3C;form v-on:submit.prevent=&#x22;addNewTodo&#x22;&#x3E;
    &#x3C;label for=&#x22;new-todo&#x22;&#x3E;Add a todo&#x3C;/label&#x3E;
    &#x3C;input
      v-model=&#x22;newTodoText&#x22;
      id=&#x22;new-todo&#x22;
      placeholder=&#x22;E.g. Feed the cat&#x22;
    &#x3E;
    &#x3C;button&#x3E;Add&#x3C;/button&#x3E;
  &#x3C;/form&#x3E;
  &#x3C;ul&#x3E;
    &#x3C;li
      is=&#x22;todo-item&#x22;
      v-for=&#x22;(todo, index) in todos&#x22;
      v-bind:key=&#x22;todo.id&#x22;
      v-bind:title=&#x22;todo.title&#x22;
      v-on:remove=&#x22;todos.splice(index, 1)&#x22;
    &#x3E;&#x3C;/li&#x3E;
  &#x3C;/ul&#x3E;
&#x3C;/div&#x3E;
</code></pre>

<p>
توجه داشته باشید که ویژگی is="todo-item"  است. این در الگوهای DOM ضروری است ، زیرا فقط یک عنصر &#x3C;li&#x3E;
 درون یک &#x3C;ul&#x3E; معتبر است. این همان کار را با &#x3C;todo-item&#x3E;
 انجام می دهد ، اما در اطراف یک خطای تجزیه مرورگر بالقوه کار می کند. برای کسب اطلاعات بیشتر به الگوی <a href="/documentation/vuejs/Essentials/Components-Basics#نکاتی-در-عملیات-تجزیه-قالب-dom-template-parsing-caveats" target="_blank"> DOM Template Parsing Caveats</a>مراجعه کنید.
</p>

<pre><code class="language-javascript  line-numbers">Vue.component('todo-item', {
  template: '\
    &#x3C;li&#x3E;\
      &#123;&#123; title &#125;&#125;\
      &#x3C;button v-on:click=&#x22;$emit(\&#x27;remove\&#x27;)&#x22;&#x3E;Remove&#x3C;/button&#x3E;\
    &#x3C;/li&#x3E;\
  ',
  props: ['title']
})

new Vue({
  el: '#todo-list-example',
  data: {
    newTodoText: '',
    todos: [
      {
        id: 1,
        title: 'Do the dishes',
      },
      {
        id: 2,
        title: 'Take out the trash',
      },
      {
        id: 3,
        title: 'Mow the lawn'
      }
    ],
    nextTodoId: 4
  },
  methods: {
    addNewTodo: function () {
      this.todos.push({
        id: this.nextTodoId++,
        title: this.newTodoText
      })
      this.newTodoText = ''
    }
  }
})
</code></pre>

<script src="https://cdn.jsdelivr.net/npm/vue"></script>

<script>
var app1 = new Vue({
    el: '#app1',
    data: {
        items: [
          { message: 'Foo' },
          { message: 'Bar' }
        ]
  }
})

    var app2 = new Vue({
        el: '#app2',
        data: {
            parentMessage: 'Parent',
            items: [
                { message: 'Foo' },
                { message: 'Bar' }
            ]
        }
    })


var app3 = new Vue({
            el: '#app3',
            data: {
              object: {
                title: 'How to do lists in Vue',
                author: 'Jane Doe',
                publishedAt: '2016-04-10'
              }
            }
          })
var app4 = new Vue({
            el: '#app4',
            data: {
              object: {
                title: 'How to do lists in Vue',
                author: 'Jane Doe',
                publishedAt: '2016-04-10'
              }
            }
          })
          
var app5 = new Vue({
            el: '#app5',
            data: {
              object: {
                title: 'How to do lists in Vue',
                author: 'Jane Doe',
                publishedAt: '2016-04-10'
              }
            }
          })          
</script>


        </section>
        
<hr>
<p>
<div>منابع مورد مطالعه جهت جمع آوری این مطلب:</div>
<div  class="refrencehref">
        https://vuejs.org/v2/guide/list.html
</div>
</p>

        <hr>
        <style>
    #commentsdiv{
        background-color: #f5f5f5;
        border: 1px solid #c5c5c5;
        border-bottom: 0px !important;
        padding: 12px;
    }
    #commentsborder{
        background-color: #fff;
        border: 1px solid #c5c5c5;
        white-space: normal;
        padding: 20px;
    }
</style>

<div id="commentsdiv">نظرات</div>
<div id="commentsborder">
<div id="wpac-comment"></div>
</div>
<script type="text/javascript">
wpac_init = window.wpac_init || [];
wpac_init.push({widget: 'Comment', id: 7878});
(function() {
    if ('WIDGETPACK_LOADED' in window) return;
    WIDGETPACK_LOADED = true;
    var mc = document.createElement('script');
    mc.type = 'text/javascript';
    mc.async = true;
    mc.src = 'https://embed.widgetpack.com/widget.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
})();
</script>

    </article>
</div>
<script src="/assets/js/anchor.min.js"></script>
<script>
    anchors.options = {
        placement: 'left',
        visible: 'always',
//        icon: '#',
    };
    anchors.add('.anchored h2,.anchored h3,.anchored h4,.anchored h5,.anchored h6');

    (function($){
        if(window.location.hash) {
            var hash = decodeURIComponent(window.location.hash);
            gotohash($(hash).offset().top);
        }
        $('a.anchorjs-link').click(function(){
			gotohash($(this).offset().top);
        });
        $('a.anchorjs').click(function(){
			var id = '#' + $(this).attr('title');
			gotohash($(id).offset().top);
        });		
        function gotohash(top){
            var headerHeight = 70; // Get fixed header height
            $('html,body').animate({
                scrollTop: top - headerHeight
            }, 20);
        }
    })(jQuery);
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script>
   $(document).ready(function (){

     var scrollPosition = getParameterByName('scroll');
     if(scrollPosition)
      $(".doc-menu").scrollTop(scrollPosition);

     $('.doc-link').click(function(){
        var scrollTop = $(".doc-menu").scrollTop();
        if(scrollTop > 0)
          $(this).attr("href",this.href + "?scroll=" + $(".doc-menu").scrollTop());
     });

     function getParameterByName(name, url) {
        if (!url) {
          url = window.location.href;
        }
        name = name.replace(/[\[\]]/g, "\\$&");
        var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
            results = regex.exec(url);
        if (!results) return null;
        if (!results[2]) return '';
        return decodeURIComponent(results[2].replace(/\+/g, " "));
    }

   });
</script>
    <div id="back-to-top" role="button" aria-label="Back to top">
        <i class="fa fa-angle-double-up" aria-hidden="true"></i>
    </div>
</main>
<!-- footer -->

<footer class="footer" role="contentinfo" aria-label="Site footer">
    <div class="navigation" role="navigation" aria-label="Footer links">
        <a href="http://localhost:4000" class="avatar" role="link" ></a>
        <ul role="menubar" aria-label="Footer links menubar">
            <li class="footer-products" role="menuitem" aria-label="Products">
                تولیدات
                <ul role="menu" aria-hidden="true" aria-label="Products link">
                </ul>
            </li>
            <li class="footer-blog" role="menuitem" aria-label="Blog">
                مقالات
                <ul role="menu" aria-hidden="true" aria-label="Blog link">
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2020/07/03/marriage.html" role="link" aria-label="ازدواج">ازدواج</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2019/10/11/vuejs.html" role="link" aria-label="آموزش vuejs">آموزش vuejs</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2017/12/18/laravel.html" role="link" aria-label="آموزش Laravel">آموزش Laravel</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/articles/2017/12/13/laravelcollective.html" role="link" aria-label="معرفی Laravel Collective">معرفی Laravel Collective</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2017/12/06/design-patterns.html" role="link" aria-label="معرفی  Design Pattern">معرفی  Design Pattern</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/blog" role="link" aria-label="Read more">Read More</a></li>
                </ul>
            </li>

            <li class="footer-connect" role="menuitem" aria-label="Connect">
                تماس
                <ul role="menu" aria-hidden="true" aria-label="Connect link">
                    <li role="listitem" aria-label="Connect link item"><a href="https://github.com/farhadmirzapour" target="_blank" role="link" aria-label="GitHub">GitHub</a></li>
                    <li role="listitem" aria-label="Connect link item"><a href="https://www.linkedin.com/in/farhad-mirzapour/" target="_blank" role="link" aria-label="Linkedin">Linkedin</a></li>
                    <li role="listitem" aria-label="Connect link item"><a href="https://twitter.com/farhadmirzapour" target="_blank" role="link" aria-label="Twitter">Twitter</a></li>
                </ul>
            </li>
        </ul>
    </div>
    <div class="socials"  role="navigation" aria-label="Social links">
        <ul role="menu" aria-hidden="true" aria-label="Social link">
            <li role="listitem" aria-label="Social link item"><a href="https://github.com/farhadmirzapour" target="_blank" role="link" aria-label="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a></li>
            <li role="listitem" aria-label="Social link item"><a href="https://twitter.com/farhadmirzapour" target="_blank" role="link" aria-label="Twitter"><i class="fa fa-twitter" aria-hidden="true"></i></a></li>
            <li role="listitem" aria-label="Social link item"><a href="https://www.linkedin.com/in/farhad-mirzapour-0043b862/" target="_blank" role="link" aria-label="Linkedin"><i class="fa fa-linkedin-square" aria-hidden="true"></i></a></li>
            <li role="listitem" aria-label="Social link item"><a href="/feed.xml" role="link" aria-label="RSS"><i class="fa fa-rss-square" aria-hidden="true"></i></a></li>
        </ul>
    </div>
    <div class="copyright" role="contentinfo" aria-label="Copyright">
        <p>&copy; <script type="text/javascript">document.write(new Date().getFullYear());</script> Farhad Mirzapour</p>
    </div>
</footer>

<!-- scripts -->
<script src="/assets/js/hamburger-menu.js"></script>

<script src="/assets/js/elevator.min.js"></script>
<script src="/assets/js/back-to-top.js"></script>
<script src="/assets/prisma/prism.js"></script>
<!-- google analytics -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-108878564-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-108878564-1');
</script>

</body>
</html>