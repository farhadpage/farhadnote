<!DOCTYPE html>
<html lang="">
<!-- head -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Inheritance (وراثت) | مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Inheritance (وراثت)" />
<meta name="author" content="Farhad Mirzapour" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="وراثت (Inheritance) وراثت یکی از شکل‌های «قابلیت استفاده مجدد» کد بوده که برنامه‌نویس را قادر می‌سازد تا با ارث‌بری صفات و متدهای یک یا چند کلاس موجود، کلاس‌های جدیدی را ایجاد نماید. برای نمونه فرض کنیم صاحب کلاس کارخانه خودروسازی مثال پیش، قصد تولید یک مدل خودرو جدید با رویکرد باربری دارد؛ بنابراین می‌بایست کلاسی جدید برای تولید آن تهیه نماید. ولی کلاس جدید علاوه‌بر صفات (ظرفیت بارگیری و..) و متدهای (انجام بارگیری، تخلیه بار و...) خاص خودش به صفات (رنگ بدنه، ظرفیت باک و...) و متدهای (راندن، سوخت گیری، توقف و...) مشابه در کلاس قبل هم نیاز دارد؛ در این حالت نیازی به تعریف مجدد آن‌ها نیست و می‌توان صفات و متدهای کلاس پیش را در کلاس جدید به ارث برد. به کلاسی که از آن ارث‌بری می‌شود ”Parent Class“ یا ”Base Class“ (کلاس پایه) یا ”Superclass“ و به کلاسی که اقدام به ارث‌بری می‌کند ”Child Class“ (کلاس فرزند) یا ”Derived Class“ یا ”Subclass“ گفته می‌شود. ارث‌بری توسط «نسبت هست-یک» (IS-A Relationship) بیان می‌شود؛ این نسبت می‌گوید کلاس فرزند یک نوع از چیزی است که کلاس پایه هست. کلاس A از کلاس B ارث‌بری دارد؛ در این حالت می‌گوییم: A is a type of B، یعنی درست است اگر بگوییم: «سیب» یک نوع «میوه» است یا «خودرو» یک نوع «وسیله نقلیه» است ولی توجه داشته باشید که این یک ارتباط یک‌طرفه از کلاس فرزند به کلاس پایه است و نمی‌توانیم بگوییم: «میوه» یک نوع «سیب» است یا «وسیله نقلیه» یک نوع «خودرو» است. کلاس‌ها می‌توانند مستقل باشند ولی هنگامی که وارد رابطه‌های وراثت می‌شوند، یک ساختار سلسله مراتب (Hierarchy) به شکل درخت را تشکیل می‌دهند. برای نمونه به ساختار سلسله مراتب وراثت پایین که مربوط به برخی اشکال هندسی است توجه نمایید، پیکان‌ها نشانگر نسبت is-a هستند. در برنامه‌نویسی شی‌گرا نسبت دیگری نیز با عنوان «نسبت دارد-یک» (HAS-A Relationship) وجود دارد که بیانگر مفهومی به نام «ترکیب» (Composition) است که شکل دیگری از قابلیت استفاده مجدد کد می‌باشد ولی مفهومی متفاوت با وراثت دارد. این نسبت زمانی بیان می‌شود که درون یک کلاس (مانند: C) از کلاس دیگری (مانند: D) نمونه‌سازی شده باشد؛ یعنی شی کلاس C درون خودش شی‌ای از کلاس D را داشته باشد؛ در این حالت می‌گوییم: C has a D. به یاد دارید خواندیم کلاس خودرو از کلاس‌های کوچکتری ساخته شده است؛ مثلا کلاس موتور - یعنی درون این کلاس یک شی از کلاس موتور ایجاد شده است، اکنون می‌توانیم بگوییم: «خودرو» یک «موتور» دارد. وراثت در PHP در نظر بگیرید شما باید یک متدی با یک وظیفه ای خاصی بنویسید اما دقیقا این متد در پدر یا پدر پدر کلاس فعلیتون وجود داره خوب بنظرتون باید دوباره اون method رو بنویسید یا از اون متدی که در کلاس های پدر هست استفاده کنید . اول اینکه دوباره نویسی کدهاتون فوق العاده کم میشه و بعدش اینکه مدیریت روی کدهاتون به راحتی بالا میره . کیه که این روش کد نویسی رو نخواد . چون واقعا کار رو راحتتر میکنه . بزارید یک مثال ساده بزنم . در پایین من یک کلاس معمولی به اسم Father میسازم و یک method توش قرار میدم . class father { public function getEyeCount() { return 2 ; } } خب حالا که کلاس پدر رو ساختیم میخوام یک کلاس دیگه مثل زیر بسازم به اسم child و به father متصل کنم. class child extends father { } $obj = new child; echo $obj---&gt;getEyeCount; // 2 در بالا ما با کمک کلمه کلیدی extends تونستیم کلاس child رو به کلاس father مرتبط کنیم و با استفاده از متدی که در کلاس father هست مقداری رو در کلاس فرزند برگردونیم . نکته : به یاد داشته باشید property ها و method های که از نوع private باشن قابلیت ارث بری ندارن و نمیشه در کلاس های فرزند از این نوع method ها و property ها استفاده کرد . در اینجا چند مسئله پیش میاد که شاید برای شما هم سوال شده باشه ! مسئله اول اینکه یک کلاس که از کلاس پدر ارث می بره خودش (فرزند) میتونه ویزگی های ( method ها و peroperty های ) خودش رو داشته باشه ؟ مسئله دوم اینکه آیا میشه method ها و property های که در کلاس پدر هست در کلاس فرزند هم دوباره نویسی کرد با یک ویژگی خاص دیگه ؟ بزارید اینجا به این دو مسئله جواب بدیم تا دیگه سوالی در موردش نباشه . یک کلاس که از کلاس پدر ارث می بره خودش (فرزند) میتونه ویزگی های خودش رو داشته باشه ؟ جواب این مسئله بله است . چرا ؟ این دفعه بزارید با یک سوال از شما به چرایی این موضوع پی ببریم . آیا شمایی که ویژگی های رو از والدینتون به ارث میبرید . آیا خودتون اخلاق و ویژگی های خاص خودتون رو ندارید ؟ فکر کنم فهمیده باشید داستان چیه . چون مسئله سختی نیست . ولی با این حال به کد زیر توجه کنید که در داخل کلاس فرزند یک متد جدید میسازیم و به راحتی ازش استفاده میکنیم . class MyClass { public $prop1 = &quot;I&#39;m a class property!&quot;; public function setProperty($newval) { $this-&gt;prop1 = $newval; } public function getProperty() { return $this-&gt;prop1; } } class MyOtherClass extends MyClass { public function newMethod() { echo &quot;From a new method in&quot; . __CLASS__ ; } } // Create a new object $newobj = new MyOtherClass; // Output the object as a string echo $newobj-&gt;newMethod(); // Use a method from the parent class echo $newobj-&gt;getProperty(); نتیجه کد بالا بصورت زیر به نمایش در میاد اما شاید براتون سوال شده باشه که __CLASS__ دقیقا چیه این اسم کلاس رو برامون بر میگردونه . From a new method in MyOtherClass. I&#39;m a class property! مفهوم Overriding آیا میشه method ها و property های که در کلاس پدر هست در کلاس فرزند هم دوباره نویسی کرد با یک ویژگی دیگه ؟ جواب این مسئله هم بله است ، شما به راحتی مثل کد زیر می تونید همون متدی که در کلاس پدر هست با همون اسم در کلاس فرزند بسازین و دوباره نویسی کنید با ویژگی های جدید اینطوری اول چک میکنه که اون method در کلاس فزرند هست یا خیر اگر بود که برگشت داده میشه و اگر نبود به کلاس پدر میره و دنبال اون method میگرده و اگر بود برمیگردونه. class Foo { public function printItem($string) { echo &#39;Foo: &#39; . $string . PHP_EOL; } public function printPHP() { echo &#39;PHP is great.&#39; . PHP_EOL; } } class Bar extends Foo { public function printItem($string) { echo &#39;Bar: &#39; . $string . PHP_EOL; } } $foo = new Foo(); $bar = new Bar(); $foo-&gt;printItem(&#39;baz&#39;); // Output: &#39;Foo: baz&#39; $foo-&gt;printPHP(); // Output: &#39;PHP is great&#39; $bar-&gt;printItem(&#39;baz&#39;); // Output: &#39;Bar: baz&#39; $bar-&gt;printPHP(); // Output: &#39;PHP is great&#39; کلمه کلیدی Final در PHP5 کلمه کلیدی final معرفی شد که از همپوشانی یک متدی که به صورت final‌تعریف شده توسط کلاس های فرزند جلوگیری می کند. اکر کلاس خودش به صورت final تعریف شود آنگاه نمی تواند ارث بری شود. &lt;?php class BaseClass { public function test() { echo &quot;BaseClass::test() called&quot;; } final public function moreTesting() { echo &quot;BaseClass::moreTesting() called&quot;; } } class ChildClass extends BaseClass { public function moreTesting() { echo &quot;ChildClass::moreTesting() called&quot;; } } مثال بالا منجر به خطای زیر شده است : Cannot override final method BaseClass::moreTesting() عملگرهای parent و self parent و self در PHP دو کلمه کلیدی هستند که کدنویسی را در زمان نوشتن برنامه های شیء گرا راحت می کنند. از کلمه کلیدی parent برای دسترسی به سازنده و متدهای کلاس والد و از کلمه کلیدی self برای دسترسی به کلاس جاری و استفاده از اعضا و متدهای استاتیک و همچنین ثابت های کلاس استفاده می شود. نحوه استفاده از این دو کلمه برای دسترسی به اعضا و متدها به صورت زیر است : parent :: class member self :: class member یعنی مثلا اگر بخواهیم از یک ثابت در یک کلاس استفاده کنیم کافیست کلمه self و بعد از آن دو نقطه و سپس نام ثابت را بنویسیم. در کد زیر نحوه استفاده از این دو کلمه کلیدی آمده است : &lt;?php class ParentClass { const NAME = &quot;ParentClass&quot;; function __construct() { echo &quot;In &quot; . self::NAME . &quot; constructor&quot; . &quot;&quot;; } } class Child extends ParentClass { const NAME = &quot;Child&quot;; function __construct() { parent::__construct(); echo &quot;In &quot; . self::NAME . &quot; constructor&quot; . &quot;&quot;; } } $child = new Child(); خروجی : In ParentClass constructor In Child constructor همانطور که احتمالا متوجه شده اید برای دسترسی به اعضا، متدها و ثابت ها بعد از این دو کلمه کلیدی علامت دو نقطه (::) می گذاریم. کلمه کلیدی self در خط 7 به کلاس ParentClass و در خط 17 به کلاس Child اشاره دارد. در همین دو خط علامت دو نقطه و سپس نام ثابت های این دو کلاس یعنی NAME را نوشته ایم و این بدین معنی است که می خواهیم از این ثابت ها استفاده کنیم. در خط 16 برای اینکه از تمام کدهای سازنده کلاس پدر استفاده کنیم، به راحتی کلمه parent و بعد دو نقطه و در نهایت نام سازنده یعنی ()constract__ را می نویسیم. این کار باعث می شود تمام کدهای موجود در سازنده کلاس پدر در داخل کلاس فرزند اجرا شوند. برای همین است که وقتی یک شیء از کلاس فرزند ایجاد می کنیم کدهای سازنده کلاس پدر (خط 7) اجرا می شوند." />
<meta property="og:description" content="وراثت (Inheritance) وراثت یکی از شکل‌های «قابلیت استفاده مجدد» کد بوده که برنامه‌نویس را قادر می‌سازد تا با ارث‌بری صفات و متدهای یک یا چند کلاس موجود، کلاس‌های جدیدی را ایجاد نماید. برای نمونه فرض کنیم صاحب کلاس کارخانه خودروسازی مثال پیش، قصد تولید یک مدل خودرو جدید با رویکرد باربری دارد؛ بنابراین می‌بایست کلاسی جدید برای تولید آن تهیه نماید. ولی کلاس جدید علاوه‌بر صفات (ظرفیت بارگیری و..) و متدهای (انجام بارگیری، تخلیه بار و...) خاص خودش به صفات (رنگ بدنه، ظرفیت باک و...) و متدهای (راندن، سوخت گیری، توقف و...) مشابه در کلاس قبل هم نیاز دارد؛ در این حالت نیازی به تعریف مجدد آن‌ها نیست و می‌توان صفات و متدهای کلاس پیش را در کلاس جدید به ارث برد. به کلاسی که از آن ارث‌بری می‌شود ”Parent Class“ یا ”Base Class“ (کلاس پایه) یا ”Superclass“ و به کلاسی که اقدام به ارث‌بری می‌کند ”Child Class“ (کلاس فرزند) یا ”Derived Class“ یا ”Subclass“ گفته می‌شود. ارث‌بری توسط «نسبت هست-یک» (IS-A Relationship) بیان می‌شود؛ این نسبت می‌گوید کلاس فرزند یک نوع از چیزی است که کلاس پایه هست. کلاس A از کلاس B ارث‌بری دارد؛ در این حالت می‌گوییم: A is a type of B، یعنی درست است اگر بگوییم: «سیب» یک نوع «میوه» است یا «خودرو» یک نوع «وسیله نقلیه» است ولی توجه داشته باشید که این یک ارتباط یک‌طرفه از کلاس فرزند به کلاس پایه است و نمی‌توانیم بگوییم: «میوه» یک نوع «سیب» است یا «وسیله نقلیه» یک نوع «خودرو» است. کلاس‌ها می‌توانند مستقل باشند ولی هنگامی که وارد رابطه‌های وراثت می‌شوند، یک ساختار سلسله مراتب (Hierarchy) به شکل درخت را تشکیل می‌دهند. برای نمونه به ساختار سلسله مراتب وراثت پایین که مربوط به برخی اشکال هندسی است توجه نمایید، پیکان‌ها نشانگر نسبت is-a هستند. در برنامه‌نویسی شی‌گرا نسبت دیگری نیز با عنوان «نسبت دارد-یک» (HAS-A Relationship) وجود دارد که بیانگر مفهومی به نام «ترکیب» (Composition) است که شکل دیگری از قابلیت استفاده مجدد کد می‌باشد ولی مفهومی متفاوت با وراثت دارد. این نسبت زمانی بیان می‌شود که درون یک کلاس (مانند: C) از کلاس دیگری (مانند: D) نمونه‌سازی شده باشد؛ یعنی شی کلاس C درون خودش شی‌ای از کلاس D را داشته باشد؛ در این حالت می‌گوییم: C has a D. به یاد دارید خواندیم کلاس خودرو از کلاس‌های کوچکتری ساخته شده است؛ مثلا کلاس موتور - یعنی درون این کلاس یک شی از کلاس موتور ایجاد شده است، اکنون می‌توانیم بگوییم: «خودرو» یک «موتور» دارد. وراثت در PHP در نظر بگیرید شما باید یک متدی با یک وظیفه ای خاصی بنویسید اما دقیقا این متد در پدر یا پدر پدر کلاس فعلیتون وجود داره خوب بنظرتون باید دوباره اون method رو بنویسید یا از اون متدی که در کلاس های پدر هست استفاده کنید . اول اینکه دوباره نویسی کدهاتون فوق العاده کم میشه و بعدش اینکه مدیریت روی کدهاتون به راحتی بالا میره . کیه که این روش کد نویسی رو نخواد . چون واقعا کار رو راحتتر میکنه . بزارید یک مثال ساده بزنم . در پایین من یک کلاس معمولی به اسم Father میسازم و یک method توش قرار میدم . class father { public function getEyeCount() { return 2 ; } } خب حالا که کلاس پدر رو ساختیم میخوام یک کلاس دیگه مثل زیر بسازم به اسم child و به father متصل کنم. class child extends father { } $obj = new child; echo $obj---&gt;getEyeCount; // 2 در بالا ما با کمک کلمه کلیدی extends تونستیم کلاس child رو به کلاس father مرتبط کنیم و با استفاده از متدی که در کلاس father هست مقداری رو در کلاس فرزند برگردونیم . نکته : به یاد داشته باشید property ها و method های که از نوع private باشن قابلیت ارث بری ندارن و نمیشه در کلاس های فرزند از این نوع method ها و property ها استفاده کرد . در اینجا چند مسئله پیش میاد که شاید برای شما هم سوال شده باشه ! مسئله اول اینکه یک کلاس که از کلاس پدر ارث می بره خودش (فرزند) میتونه ویزگی های ( method ها و peroperty های ) خودش رو داشته باشه ؟ مسئله دوم اینکه آیا میشه method ها و property های که در کلاس پدر هست در کلاس فرزند هم دوباره نویسی کرد با یک ویژگی خاص دیگه ؟ بزارید اینجا به این دو مسئله جواب بدیم تا دیگه سوالی در موردش نباشه . یک کلاس که از کلاس پدر ارث می بره خودش (فرزند) میتونه ویزگی های خودش رو داشته باشه ؟ جواب این مسئله بله است . چرا ؟ این دفعه بزارید با یک سوال از شما به چرایی این موضوع پی ببریم . آیا شمایی که ویژگی های رو از والدینتون به ارث میبرید . آیا خودتون اخلاق و ویژگی های خاص خودتون رو ندارید ؟ فکر کنم فهمیده باشید داستان چیه . چون مسئله سختی نیست . ولی با این حال به کد زیر توجه کنید که در داخل کلاس فرزند یک متد جدید میسازیم و به راحتی ازش استفاده میکنیم . class MyClass { public $prop1 = &quot;I&#39;m a class property!&quot;; public function setProperty($newval) { $this-&gt;prop1 = $newval; } public function getProperty() { return $this-&gt;prop1; } } class MyOtherClass extends MyClass { public function newMethod() { echo &quot;From a new method in&quot; . __CLASS__ ; } } // Create a new object $newobj = new MyOtherClass; // Output the object as a string echo $newobj-&gt;newMethod(); // Use a method from the parent class echo $newobj-&gt;getProperty(); نتیجه کد بالا بصورت زیر به نمایش در میاد اما شاید براتون سوال شده باشه که __CLASS__ دقیقا چیه این اسم کلاس رو برامون بر میگردونه . From a new method in MyOtherClass. I&#39;m a class property! مفهوم Overriding آیا میشه method ها و property های که در کلاس پدر هست در کلاس فرزند هم دوباره نویسی کرد با یک ویژگی دیگه ؟ جواب این مسئله هم بله است ، شما به راحتی مثل کد زیر می تونید همون متدی که در کلاس پدر هست با همون اسم در کلاس فرزند بسازین و دوباره نویسی کنید با ویژگی های جدید اینطوری اول چک میکنه که اون method در کلاس فزرند هست یا خیر اگر بود که برگشت داده میشه و اگر نبود به کلاس پدر میره و دنبال اون method میگرده و اگر بود برمیگردونه. class Foo { public function printItem($string) { echo &#39;Foo: &#39; . $string . PHP_EOL; } public function printPHP() { echo &#39;PHP is great.&#39; . PHP_EOL; } } class Bar extends Foo { public function printItem($string) { echo &#39;Bar: &#39; . $string . PHP_EOL; } } $foo = new Foo(); $bar = new Bar(); $foo-&gt;printItem(&#39;baz&#39;); // Output: &#39;Foo: baz&#39; $foo-&gt;printPHP(); // Output: &#39;PHP is great&#39; $bar-&gt;printItem(&#39;baz&#39;); // Output: &#39;Bar: baz&#39; $bar-&gt;printPHP(); // Output: &#39;PHP is great&#39; کلمه کلیدی Final در PHP5 کلمه کلیدی final معرفی شد که از همپوشانی یک متدی که به صورت final‌تعریف شده توسط کلاس های فرزند جلوگیری می کند. اکر کلاس خودش به صورت final تعریف شود آنگاه نمی تواند ارث بری شود. &lt;?php class BaseClass { public function test() { echo &quot;BaseClass::test() called&quot;; } final public function moreTesting() { echo &quot;BaseClass::moreTesting() called&quot;; } } class ChildClass extends BaseClass { public function moreTesting() { echo &quot;ChildClass::moreTesting() called&quot;; } } مثال بالا منجر به خطای زیر شده است : Cannot override final method BaseClass::moreTesting() عملگرهای parent و self parent و self در PHP دو کلمه کلیدی هستند که کدنویسی را در زمان نوشتن برنامه های شیء گرا راحت می کنند. از کلمه کلیدی parent برای دسترسی به سازنده و متدهای کلاس والد و از کلمه کلیدی self برای دسترسی به کلاس جاری و استفاده از اعضا و متدهای استاتیک و همچنین ثابت های کلاس استفاده می شود. نحوه استفاده از این دو کلمه برای دسترسی به اعضا و متدها به صورت زیر است : parent :: class member self :: class member یعنی مثلا اگر بخواهیم از یک ثابت در یک کلاس استفاده کنیم کافیست کلمه self و بعد از آن دو نقطه و سپس نام ثابت را بنویسیم. در کد زیر نحوه استفاده از این دو کلمه کلیدی آمده است : &lt;?php class ParentClass { const NAME = &quot;ParentClass&quot;; function __construct() { echo &quot;In &quot; . self::NAME . &quot; constructor&quot; . &quot;&quot;; } } class Child extends ParentClass { const NAME = &quot;Child&quot;; function __construct() { parent::__construct(); echo &quot;In &quot; . self::NAME . &quot; constructor&quot; . &quot;&quot;; } } $child = new Child(); خروجی : In ParentClass constructor In Child constructor همانطور که احتمالا متوجه شده اید برای دسترسی به اعضا، متدها و ثابت ها بعد از این دو کلمه کلیدی علامت دو نقطه (::) می گذاریم. کلمه کلیدی self در خط 7 به کلاس ParentClass و در خط 17 به کلاس Child اشاره دارد. در همین دو خط علامت دو نقطه و سپس نام ثابت های این دو کلاس یعنی NAME را نوشته ایم و این بدین معنی است که می خواهیم از این ثابت ها استفاده کنیم. در خط 16 برای اینکه از تمام کدهای سازنده کلاس پدر استفاده کنیم، به راحتی کلمه parent و بعد دو نقطه و در نهایت نام سازنده یعنی ()constract__ را می نویسیم. این کار باعث می شود تمام کدهای موجود در سازنده کلاس پدر در داخل کلاس فرزند اجرا شوند. برای همین است که وقتی یک شیء از کلاس فرزند ایجاد می کنیم کدهای سازنده کلاس پدر (خط 7) اجرا می شوند." />
<link rel="canonical" href="http://localhost:4000/documentation/object-oriented-programming-in-php/inheritance" />
<meta property="og:url" content="http://localhost:4000/documentation/object-oriented-programming-in-php/inheritance" />
<meta property="og:site_name" content="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-11-01T20:57:42+03:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Inheritance (وراثت)" />
<meta name="twitter:site" content="@farhadmirzapour" />
<meta name="twitter:creator" content="@Farhad Mirzapour" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Farhad Mirzapour"},"dateModified":"2017-11-01T20:57:42+03:30","datePublished":"2017-11-01T20:57:42+03:30","description":"وراثت (Inheritance) وراثت یکی از شکل‌های «قابلیت استفاده مجدد» کد بوده که برنامه‌نویس را قادر می‌سازد تا با ارث‌بری صفات و متدهای یک یا چند کلاس موجود، کلاس‌های جدیدی را ایجاد نماید. برای نمونه فرض کنیم صاحب کلاس کارخانه خودروسازی مثال پیش، قصد تولید یک مدل خودرو جدید با رویکرد باربری دارد؛ بنابراین می‌بایست کلاسی جدید برای تولید آن تهیه نماید. ولی کلاس جدید علاوه‌بر صفات (ظرفیت بارگیری و..) و متدهای (انجام بارگیری، تخلیه بار و...) خاص خودش به صفات (رنگ بدنه، ظرفیت باک و...) و متدهای (راندن، سوخت گیری، توقف و...) مشابه در کلاس قبل هم نیاز دارد؛ در این حالت نیازی به تعریف مجدد آن‌ها نیست و می‌توان صفات و متدهای کلاس پیش را در کلاس جدید به ارث برد. به کلاسی که از آن ارث‌بری می‌شود ”Parent Class“ یا ”Base Class“ (کلاس پایه) یا ”Superclass“ و به کلاسی که اقدام به ارث‌بری می‌کند ”Child Class“ (کلاس فرزند) یا ”Derived Class“ یا ”Subclass“ گفته می‌شود. ارث‌بری توسط «نسبت هست-یک» (IS-A Relationship) بیان می‌شود؛ این نسبت می‌گوید کلاس فرزند یک نوع از چیزی است که کلاس پایه هست. کلاس A از کلاس B ارث‌بری دارد؛ در این حالت می‌گوییم: A is a type of B، یعنی درست است اگر بگوییم: «سیب» یک نوع «میوه» است یا «خودرو» یک نوع «وسیله نقلیه» است ولی توجه داشته باشید که این یک ارتباط یک‌طرفه از کلاس فرزند به کلاس پایه است و نمی‌توانیم بگوییم: «میوه» یک نوع «سیب» است یا «وسیله نقلیه» یک نوع «خودرو» است. کلاس‌ها می‌توانند مستقل باشند ولی هنگامی که وارد رابطه‌های وراثت می‌شوند، یک ساختار سلسله مراتب (Hierarchy) به شکل درخت را تشکیل می‌دهند. برای نمونه به ساختار سلسله مراتب وراثت پایین که مربوط به برخی اشکال هندسی است توجه نمایید، پیکان‌ها نشانگر نسبت is-a هستند. در برنامه‌نویسی شی‌گرا نسبت دیگری نیز با عنوان «نسبت دارد-یک» (HAS-A Relationship) وجود دارد که بیانگر مفهومی به نام «ترکیب» (Composition) است که شکل دیگری از قابلیت استفاده مجدد کد می‌باشد ولی مفهومی متفاوت با وراثت دارد. این نسبت زمانی بیان می‌شود که درون یک کلاس (مانند: C) از کلاس دیگری (مانند: D) نمونه‌سازی شده باشد؛ یعنی شی کلاس C درون خودش شی‌ای از کلاس D را داشته باشد؛ در این حالت می‌گوییم: C has a D. به یاد دارید خواندیم کلاس خودرو از کلاس‌های کوچکتری ساخته شده است؛ مثلا کلاس موتور - یعنی درون این کلاس یک شی از کلاس موتور ایجاد شده است، اکنون می‌توانیم بگوییم: «خودرو» یک «موتور» دارد. وراثت در PHP در نظر بگیرید شما باید یک متدی با یک وظیفه ای خاصی بنویسید اما دقیقا این متد در پدر یا پدر پدر کلاس فعلیتون وجود داره خوب بنظرتون باید دوباره اون method رو بنویسید یا از اون متدی که در کلاس های پدر هست استفاده کنید . اول اینکه دوباره نویسی کدهاتون فوق العاده کم میشه و بعدش اینکه مدیریت روی کدهاتون به راحتی بالا میره . کیه که این روش کد نویسی رو نخواد . چون واقعا کار رو راحتتر میکنه . بزارید یک مثال ساده بزنم . در پایین من یک کلاس معمولی به اسم Father میسازم و یک method توش قرار میدم . class father { public function getEyeCount() { return 2 ; } } خب حالا که کلاس پدر رو ساختیم میخوام یک کلاس دیگه مثل زیر بسازم به اسم child و به father متصل کنم. class child extends father { } $obj = new child; echo $obj---&gt;getEyeCount; // 2 در بالا ما با کمک کلمه کلیدی extends تونستیم کلاس child رو به کلاس father مرتبط کنیم و با استفاده از متدی که در کلاس father هست مقداری رو در کلاس فرزند برگردونیم . نکته : به یاد داشته باشید property ها و method های که از نوع private باشن قابلیت ارث بری ندارن و نمیشه در کلاس های فرزند از این نوع method ها و property ها استفاده کرد . در اینجا چند مسئله پیش میاد که شاید برای شما هم سوال شده باشه ! مسئله اول اینکه یک کلاس که از کلاس پدر ارث می بره خودش (فرزند) میتونه ویزگی های ( method ها و peroperty های ) خودش رو داشته باشه ؟ مسئله دوم اینکه آیا میشه method ها و property های که در کلاس پدر هست در کلاس فرزند هم دوباره نویسی کرد با یک ویژگی خاص دیگه ؟ بزارید اینجا به این دو مسئله جواب بدیم تا دیگه سوالی در موردش نباشه . یک کلاس که از کلاس پدر ارث می بره خودش (فرزند) میتونه ویزگی های خودش رو داشته باشه ؟ جواب این مسئله بله است . چرا ؟ این دفعه بزارید با یک سوال از شما به چرایی این موضوع پی ببریم . آیا شمایی که ویژگی های رو از والدینتون به ارث میبرید . آیا خودتون اخلاق و ویژگی های خاص خودتون رو ندارید ؟ فکر کنم فهمیده باشید داستان چیه . چون مسئله سختی نیست . ولی با این حال به کد زیر توجه کنید که در داخل کلاس فرزند یک متد جدید میسازیم و به راحتی ازش استفاده میکنیم . class MyClass { public $prop1 = &quot;I&#39;m a class property!&quot;; public function setProperty($newval) { $this-&gt;prop1 = $newval; } public function getProperty() { return $this-&gt;prop1; } } class MyOtherClass extends MyClass { public function newMethod() { echo &quot;From a new method in&quot; . __CLASS__ ; } } // Create a new object $newobj = new MyOtherClass; // Output the object as a string echo $newobj-&gt;newMethod(); // Use a method from the parent class echo $newobj-&gt;getProperty(); نتیجه کد بالا بصورت زیر به نمایش در میاد اما شاید براتون سوال شده باشه که __CLASS__ دقیقا چیه این اسم کلاس رو برامون بر میگردونه . From a new method in MyOtherClass. I&#39;m a class property! مفهوم Overriding آیا میشه method ها و property های که در کلاس پدر هست در کلاس فرزند هم دوباره نویسی کرد با یک ویژگی دیگه ؟ جواب این مسئله هم بله است ، شما به راحتی مثل کد زیر می تونید همون متدی که در کلاس پدر هست با همون اسم در کلاس فرزند بسازین و دوباره نویسی کنید با ویژگی های جدید اینطوری اول چک میکنه که اون method در کلاس فزرند هست یا خیر اگر بود که برگشت داده میشه و اگر نبود به کلاس پدر میره و دنبال اون method میگرده و اگر بود برمیگردونه. class Foo { public function printItem($string) { echo &#39;Foo: &#39; . $string . PHP_EOL; } public function printPHP() { echo &#39;PHP is great.&#39; . PHP_EOL; } } class Bar extends Foo { public function printItem($string) { echo &#39;Bar: &#39; . $string . PHP_EOL; } } $foo = new Foo(); $bar = new Bar(); $foo-&gt;printItem(&#39;baz&#39;); // Output: &#39;Foo: baz&#39; $foo-&gt;printPHP(); // Output: &#39;PHP is great&#39; $bar-&gt;printItem(&#39;baz&#39;); // Output: &#39;Bar: baz&#39; $bar-&gt;printPHP(); // Output: &#39;PHP is great&#39; کلمه کلیدی Final در PHP5 کلمه کلیدی final معرفی شد که از همپوشانی یک متدی که به صورت final‌تعریف شده توسط کلاس های فرزند جلوگیری می کند. اکر کلاس خودش به صورت final تعریف شود آنگاه نمی تواند ارث بری شود. &lt;?php class BaseClass { public function test() { echo &quot;BaseClass::test() called&quot;; } final public function moreTesting() { echo &quot;BaseClass::moreTesting() called&quot;; } } class ChildClass extends BaseClass { public function moreTesting() { echo &quot;ChildClass::moreTesting() called&quot;; } } مثال بالا منجر به خطای زیر شده است : Cannot override final method BaseClass::moreTesting() عملگرهای parent و self parent و self در PHP دو کلمه کلیدی هستند که کدنویسی را در زمان نوشتن برنامه های شیء گرا راحت می کنند. از کلمه کلیدی parent برای دسترسی به سازنده و متدهای کلاس والد و از کلمه کلیدی self برای دسترسی به کلاس جاری و استفاده از اعضا و متدهای استاتیک و همچنین ثابت های کلاس استفاده می شود. نحوه استفاده از این دو کلمه برای دسترسی به اعضا و متدها به صورت زیر است : parent :: class member self :: class member یعنی مثلا اگر بخواهیم از یک ثابت در یک کلاس استفاده کنیم کافیست کلمه self و بعد از آن دو نقطه و سپس نام ثابت را بنویسیم. در کد زیر نحوه استفاده از این دو کلمه کلیدی آمده است : &lt;?php class ParentClass { const NAME = &quot;ParentClass&quot;; function __construct() { echo &quot;In &quot; . self::NAME . &quot; constructor&quot; . &quot;&quot;; } } class Child extends ParentClass { const NAME = &quot;Child&quot;; function __construct() { parent::__construct(); echo &quot;In &quot; . self::NAME . &quot; constructor&quot; . &quot;&quot;; } } $child = new Child(); خروجی : In ParentClass constructor In Child constructor همانطور که احتمالا متوجه شده اید برای دسترسی به اعضا، متدها و ثابت ها بعد از این دو کلمه کلیدی علامت دو نقطه (::) می گذاریم. کلمه کلیدی self در خط 7 به کلاس ParentClass و در خط 17 به کلاس Child اشاره دارد. در همین دو خط علامت دو نقطه و سپس نام ثابت های این دو کلاس یعنی NAME را نوشته ایم و این بدین معنی است که می خواهیم از این ثابت ها استفاده کنیم. در خط 16 برای اینکه از تمام کدهای سازنده کلاس پدر استفاده کنیم، به راحتی کلمه parent و بعد دو نقطه و در نهایت نام سازنده یعنی ()constract__ را می نویسیم. این کار باعث می شود تمام کدهای موجود در سازنده کلاس پدر در داخل کلاس فرزند اجرا شوند. برای همین است که وقتی یک شیء از کلاس فرزند ایجاد می کنیم کدهای سازنده کلاس پدر (خط 7) اجرا می شوند.","headline":"Inheritance (وراثت)","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/documentation/object-oriented-programming-in-php/inheritance"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/img/logo/blankspace-avatar.png"},"name":"Farhad Mirzapour"},"url":"http://localhost:4000/documentation/object-oriented-programming-in-php/inheritance"}</script>
<!-- End Jekyll SEO tag -->

    <!-- stylesheets -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css">
    <link rel="stylesheet" href="/assets/main.css">
    <link rel="stylesheet" href="/assets/prisma/prism.css">
    <!-- favicons and rss -->
    <link rel="alternate" type="application/rss+xml" title="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" href="/feed.xml">
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/img/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/img/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/img/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
</head>
<body>
<!-- header -->
<header class="header" role="banner" aria-label="Header">
    <button class="hamburger-button" onclick="hamburgerMenu();" role="button" aria-label="Hamburger menu button">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </button>
    <a href="/" class="logo" role="link" aria-label="Home">
        <img alt="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" src="/assets/img/logo/farhadmirzapour-logo.png" role="img" aria-label="Logo"/>
    </a>
    <nav class="navigation" role="navigation" aria-label="Navigation">
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
            <li role="menuitem" aria-label="Navigation menu item">
                <a href="/" class="logo" role="menuitem" aria-label="Home">
                    <img alt="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" src="/assets/img/logo/farhadmirzapour-logo.png" role="img" aria-label="Logo"/>
                </a>
            </li>
            
            <li role="menuitem"><a href="/blog" role="menuitem" aria-label="مقالات">مقالات</a></li>
            
            <li role="menuitem"><a href="/contactus" role="menuitem" aria-label="تماس">تماس</a></li>
            
        </ul>
    </nav>
    <div class="searchbox" role="search" aria-label="Search">
        <form action="/search" id="searchthis" method="get" role="form" aria-label="Search form">
            <i class="fa fa-search" aria-hidden="true"></i>
            <input type="search" id="search" name="query" placeholder="Search..." role="textbox" aria-label="Search textbox"/>
        </form>
    </div>
</header>

<nav id="hamburger-menu" role="navigation" aria-label="Hamburger menu">
    <div class="searchbox" role="search" aria-label="Search">
        <form action="/search" id="searchthis" method="get" role="form" aria-label="Search form">
            <i class="fa fa-search" aria-hidden="true"></i>
            <input type="search" id="search" name="query" placeholder="Search..." role="textbox" aria-label="Search textbox"/>
        </form>
    </div>
    <div class="home-nav" role="navigation" aria-label="Site navigation">
        <a href="/" role="menuitem" aria-label="Home">صفحه اصلی</a>
        
        <a href="/blog" role="menuitem" aria-label="مقالات">مقالات</a>
        
        <a href="/contactus" role="menuitem" aria-label="تماس">تماس</a>
        
    </div>

    
    <div class="doc-nav" role="navigation" aria-label="Documentation navigation">
        <p role="presentation" aria-label="Category name">
            آموزش شی گرایی در php
        </p>
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
            <li role="menuitem" aria-label="Navigation menu item"><a href="/2017/11/01/object-oriented-programming-in-php.html" class="doc-link" role="link" aria-label="Inheritance (وراثت)">مقدمه</a></li>
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/object-oriented-programming-in-php/class-structure" class="doc-link" role="link" aria-label="ساختار کلاس در PHP">ساختار کلاس در PHP</a></li>
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/object-oriented-programming-in-php/encapsulation" class="doc-link" role="link" aria-label="Encapsulation (کپسوله سازی)">Encapsulation (کپسوله سازی)</a></li>
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/object-oriented-programming-in-php/inheritance" class="doc-link" role="link" aria-label="Inheritance (وراثت)">Inheritance (وراثت)</a></li>
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/object-oriented-programming-in-php/magic-methods" class="doc-link" role="link" aria-label="متدهای جادوئی در شی گرایی php">متدهای جادوئی در شی گرایی php</a></li>
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/object-oriented-programming-in-php/abstract-class" class="doc-link" role="link" aria-label="کلاس های Abstract (انتزاعی)">کلاس های Abstract (انتزاعی)</a></li>
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/object-oriented-programming-in-php/interface" class="doc-link" role="link" aria-label="interface در PHP">interface در PHP</a></li>
            
            
            
            <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/object-oriented-programming-in-php/polymorphism" class="doc-link" role="link" aria-label="چندریختی (Polymorphism)">چندریختی (Polymorphism)</a></li>
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        </ul>
    </div>
    
</nav>
<!-- main content -->
<main class="container" role="main">
    <div class="rcdoccontainerimg">
    <div class="rc-DRTVBanner-new rc-DRTVBanner-bigsize">
    <div style="background: url('/images/original/phpOOPTutorialPAGE.png'); " class="blurred_img"></div>
    <div class="mask"></div>
    <div class="bot"></div>
    <div class="over">
        <div class="container-rc">
            <img class="image" src="/images/original/phpOOPTutorialPAGE.png" alt="Inheritance (وراثت)" height="190">
            <div class="desktop-banner-container">
                <h1 class="display-5-text headline">
                    
                    
                    آموزش شی گرایی در php
                    </h1>
                <!--<div class="tagslist"><ul class='lyda-tag-list'><li class='lyda-tag-list-title'>برچسب ها</li><li><a class="tags" href="/tag/لاراول">#لاراول</a></li><li><a class="tags" href="/tag/لاراول-5-5">#لاراول 5.5</a></li></ul></div>-->
            </div>
        </div>
    </div>
</div>

<!--<div class="bread-crumb">-->
<!--<div class="container   ">-->
<!--<div class="pull-right ">-->
<!--<div class="bread-button text-custom b-left">-->
<!--انتشار : 2 ماه پیش-->
<!--</div>-->
<!--<a href="/category/article/" class="bread-button back-to-all b-left hidden-xs">همه مقالات</a>-->
<!--<div class="cat-lable">-->
<!--<a href="/category/article/laravel/">-->
<!--لاراول-->
<!--</a>-->
<!--</div>-->
<!--</div>-->
<!--</div>-->
<!--</div>-->
<script>
    $(window).scroll(function(){
        var sticky = $('.doc-menu'),
            scroll = $(window).scrollTop();
        if (scroll >= 101) {sticky.addClass('doc-header-scroll'); }
        else {sticky.removeClass('doc-header-scroll'); };
    });
</script>
</div>
<div class="doc-container">

    <div class="doc-menu">
        
        <ul>
            <li>
                <a  href="/2017/11/01/object-oriented-programming-in-php.html" class="active doc-link" role="link">
                    مقدمه
                </a>
            </li>
            
            
            <li>
                <a title="ساختار کلاس در PHP" href="/documentation/object-oriented-programming-in-php/class-structure" class="active doc-link" role="link">
                    ساختار کلاس در PHP
                </a>
            </li>
            
            
            
            <li>
                <a title="Encapsulation (کپسوله سازی)" href="/documentation/object-oriented-programming-in-php/encapsulation" class="active doc-link" role="link">
                    Encapsulation (کپسوله سازی)
                </a>
            </li>
            
            
            
            <li>
                <a title="Inheritance (وراثت)" href="/documentation/object-oriented-programming-in-php/inheritance" class="active doc-link" role="link">
                    Inheritance (وراثت)
                </a>
            </li>
            
            
            
            <li>
                <a title="متدهای جادوئی در شی گرایی php" href="/documentation/object-oriented-programming-in-php/magic-methods" class="active doc-link" role="link">
                    متدهای جادوئی در شی گرایی php
                </a>
            </li>
            
            
            
            <li>
                <a title="کلاس های Abstract (انتزاعی)" href="/documentation/object-oriented-programming-in-php/abstract-class" class="active doc-link" role="link">
                    کلاس های Abstract (انتزاعی)
                </a>
            </li>
            
            
            
            <li>
                <a title="interface در PHP" href="/documentation/object-oriented-programming-in-php/interface" class="active doc-link" role="link">
                    interface در PHP
                </a>
            </li>
            
            
            
            <li>
                <a title="چندریختی (Polymorphism)" href="/documentation/object-oriented-programming-in-php/polymorphism" class="active doc-link" role="link">
                    چندریختی (Polymorphism)
                </a>
            </li>
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        </ul>
        
    </div>

    <article class="documentation">
        <header class="doc-header">
            <div class="time">
                تاریخ :      چهارشنبه 10 آبان 1396
            </div>
            
        </header>
        <section class="anchored">
            <h3>وراثت (Inheritance)</h3>
<p>
وراثت یکی از شکل‌های «قابلیت استفاده مجدد» کد بوده که برنامه‌نویس را قادر می‌سازد تا با ارث‌بری صفات و متدهای یک یا چند کلاس موجود، کلاس‌های جدیدی را ایجاد نماید.
</p>

<p>
برای نمونه فرض کنیم صاحب کلاس کارخانه خودروسازی مثال پیش، قصد تولید یک مدل خودرو جدید با رویکرد باربری دارد؛ بنابراین می‌بایست کلاسی جدید برای تولید آن تهیه نماید. ولی کلاس جدید علاوه‌بر صفات (ظرفیت بارگیری و..) و متدهای (انجام بارگیری، تخلیه بار و...) خاص خودش به صفات (رنگ بدنه، ظرفیت باک و...) و متدهای (راندن، سوخت گیری، توقف و...) مشابه در کلاس قبل هم نیاز دارد؛ در این حالت نیازی به تعریف مجدد آن‌ها نیست و می‌توان صفات و متدهای کلاس پیش را در کلاس جدید به ارث برد.
</p>

<p>
به کلاسی که از آن ارث‌بری می‌شود ”Parent Class“ یا ”Base Class“ (کلاس پایه) یا ”Superclass“ و به کلاسی که اقدام به ارث‌بری می‌کند ”Child Class“ (کلاس فرزند) یا ”Derived Class“ یا ”Subclass“ گفته می‌شود.
</p>

<p>
ارث‌بری توسط «نسبت هست-یک» (IS-A Relationship) بیان می‌شود؛ این نسبت می‌گوید کلاس فرزند یک نوع از چیزی است که کلاس پایه هست. کلاس A از کلاس B ارث‌بری دارد؛ در این حالت می‌گوییم: A is a type of B، یعنی درست است اگر بگوییم: «سیب» یک نوع «میوه» است یا «خودرو» یک نوع «وسیله نقلیه» است ولی توجه داشته باشید که این یک ارتباط یک‌طرفه از کلاس فرزند به کلاس پایه است و نمی‌توانیم بگوییم: «میوه» یک نوع «سیب» است یا «وسیله نقلیه» یک نوع «خودرو» است.
</p>

<p>
کلاس‌ها می‌توانند مستقل باشند ولی هنگامی که وارد رابطه‌های وراثت می‌شوند، یک ساختار سلسله مراتب (Hierarchy) به شکل درخت را تشکیل می‌دهند. برای نمونه به ساختار سلسله مراتب وراثت پایین که مربوط به برخی اشکال هندسی است توجه نمایید، پیکان‌ها نشانگر نسبت is-a هستند.
</p>

<div align="center">
<img src="/images/post/l05-Inheritance-Hierarchy-Sample.png" alt="Inheritance (وراثت)" />
</div>

<p>
در برنامه‌نویسی شی‌گرا نسبت دیگری نیز با عنوان «نسبت دارد-یک» (HAS-A Relationship) وجود دارد که بیانگر مفهومی به نام «ترکیب» (Composition) است که شکل دیگری از قابلیت استفاده مجدد کد می‌باشد ولی مفهومی متفاوت با وراثت دارد. این نسبت زمانی بیان می‌شود که درون یک کلاس (مانند: C) از کلاس دیگری (مانند: D) نمونه‌سازی شده باشد؛ یعنی شی کلاس C درون خودش شی‌ای از کلاس D را داشته باشد؛ در این حالت می‌گوییم: C has a D. به یاد دارید خواندیم کلاس خودرو از کلاس‌های کوچکتری ساخته شده است؛ مثلا کلاس موتور - یعنی درون این کلاس یک شی از کلاس موتور ایجاد شده است، اکنون می‌توانیم بگوییم: «خودرو» یک «موتور» دارد.
</p>

<div align="center">
<img src="/images/post/l05-has-a-Sample.png" alt="Inheritance (وراثت)" />
</div>

<h3>
وراثت در PHP
</h3>

<p>
در نظر بگیرید شما باید یک متدی با یک وظیفه ای خاصی بنویسید اما دقیقا این متد در پدر یا پدر پدر کلاس فعلیتون وجود داره خوب بنظرتون باید دوباره اون method رو بنویسید یا از اون متدی که در کلاس های پدر هست استفاده کنید . اول اینکه دوباره نویسی کدهاتون فوق العاده کم میشه و بعدش اینکه مدیریت روی کدهاتون به راحتی بالا میره . کیه که این روش کد نویسی رو نخواد . چون واقعا کار رو راحتتر میکنه .
</p>
<p>
بزارید یک مثال ساده بزنم . در پایین من یک کلاس معمولی به اسم Father میسازم و یک method توش قرار میدم .
</p>

<pre><code class="language-php  line-numbers">class father
{
    public function getEyeCount() {
        return 2 ;
    }
}
</code></pre>

<p>
خب حالا که کلاس پدر رو ساختیم میخوام یک کلاس دیگه مثل زیر بسازم به اسم child و به father متصل کنم.
</p>

<pre><code class="language-php  line-numbers">class child extends father
{

}

$obj = new child;
echo $obj---&gt;getEyeCount; // 2
</code></pre>

<p>
در بالا ما با کمک کلمه کلیدی extends تونستیم کلاس child رو به کلاس father مرتبط کنیم و با استفاده از متدی که در کلاس father هست مقداری رو در کلاس فرزند برگردونیم .
</p>

<p>
نکته : به یاد داشته باشید property ها و method های که از نوع private باشن قابلیت ارث بری ندارن و نمیشه در کلاس های فرزند از این نوع method ها و property ها استفاده کرد .
</p>

<p>
در اینجا چند مسئله پیش میاد که شاید برای شما هم سوال شده باشه ! مسئله اول اینکه یک کلاس که از کلاس پدر ارث می بره خودش (فرزند) میتونه ویزگی های ( method ها و peroperty های ) خودش رو داشته باشه ؟ مسئله دوم اینکه آیا میشه method ها و property های که در کلاس پدر هست در کلاس فرزند هم دوباره نویسی کرد با یک ویژگی خاص دیگه ؟ بزارید اینجا به این دو مسئله جواب بدیم تا دیگه سوالی در موردش نباشه .
</p>

<p>
یک کلاس که از کلاس پدر ارث می بره خودش (فرزند) میتونه ویزگی های خودش رو داشته باشه ؟
</p>

<p>
جواب این مسئله بله است . چرا ؟ این دفعه بزارید با یک سوال از شما به چرایی این موضوع پی ببریم . آیا شمایی که ویژگی های رو از والدینتون به ارث میبرید . آیا خودتون اخلاق و ویژگی های خاص خودتون رو ندارید ؟ فکر کنم فهمیده باشید داستان چیه . چون مسئله سختی نیست . ولی با این حال

به کد زیر توجه کنید که در داخل کلاس فرزند یک متد جدید میسازیم و به راحتی ازش استفاده میکنیم .
</p>

<pre><code class="language-php  line-numbers">class MyClass
{
  public $prop1 = "I'm a class property!";

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1;
  }
}

class MyOtherClass extends MyClass
{
  public function newMethod()
  {
      echo "From a new method in" . __CLASS__ ;
  }
}

// Create a new object
$newobj = new MyOtherClass;

// Output the object as a string
echo $newobj-&gt;newMethod();

// Use a method from the parent class
echo $newobj-&gt;getProperty();
</code></pre>

<p>
 نتیجه کد بالا بصورت زیر به نمایش در میاد اما شاید براتون سوال شده باشه که __CLASS__ دقیقا چیه این اسم کلاس رو برامون بر میگردونه .
</p>

<pre><code class="language-php ">From a new method in MyOtherClass.
I'm a class property!
</code></pre>

<h3>مفهوم Overriding</h3>

<p>
 آیا میشه method ها و property های که در کلاس پدر هست در کلاس فرزند هم دوباره نویسی کرد با یک ویژگی دیگه ؟
</p>

<p>
جواب این مسئله هم بله است ، شما به راحتی مثل کد زیر می تونید همون متدی که در کلاس پدر هست با همون اسم در کلاس فرزند بسازین و دوباره نویسی کنید با ویژگی های جدید اینطوری اول چک میکنه که اون method در کلاس فزرند هست یا خیر اگر بود که برگشت داده میشه و اگر نبود به کلاس پدر میره و دنبال اون method میگرده و اگر بود برمیگردونه.
</p>

<pre><code class="language-php  line-numbers">class Foo
{
    public function printItem($string)
    {
        echo 'Foo: ' . $string . PHP_EOL;
    }

    public function printPHP()
    {
        echo 'PHP is great.' . PHP_EOL;
    }
}

class Bar extends Foo
{
    public function printItem($string)
    {
        echo 'Bar: ' . $string . PHP_EOL;
    }
}

$foo = new Foo();
$bar = new Bar();
$foo-&gt;printItem('baz'); // Output: 'Foo: baz'
$foo-&gt;printPHP();       // Output: 'PHP is great'
$bar-&gt;printItem('baz'); // Output: 'Bar: baz'
$bar-&gt;printPHP();       // Output: 'PHP is great'
</code></pre>

<h3>کلمه کلیدی Final</h3>

<p>
در PHP5 کلمه کلیدی final معرفی شد که از همپوشانی یک متدی که به صورت final‌تعریف شده توسط کلاس های فرزند جلوگیری می کند. اکر کلاس خودش به صورت final تعریف شود آنگاه نمی تواند ارث بری شود.
</p>

<pre><code class="language-php  line-numbers">&lt;?php
class BaseClass {
    public function test() {
        echo "BaseClass::test() called<br />";
    }

    final public function moreTesting() {
        echo "BaseClass::moreTesting() called<br />";
    }
}

class ChildClass extends BaseClass {
    public function moreTesting() {
        echo "ChildClass::moreTesting() called<br />";
    }
}
</code></pre>

<p>
مثال بالا منجر به خطای زیر شده است :
</p>

<pre><code class="language-php">
Cannot override final method BaseClass::moreTesting()
</code></pre>

<h3>عملگرهای parent و self</h3>
<p>
parent و self در PHP دو کلمه کلیدی هستند که کدنویسی را در زمان نوشتن برنامه های شیء گرا راحت می کنند. از کلمه کلیدی parent برای دسترسی به سازنده و متدهای کلاس والد و از کلمه کلیدی self برای دسترسی به کلاس جاری و استفاده از اعضا و متدهای استاتیک و همچنین ثابت های کلاس استفاده می شود. نحوه استفاده از این دو کلمه برای دسترسی به اعضا و متدها به صورت زیر است :
</p>

<pre><code class="language-php">parent :: class member
self :: class member
</code></pre>

<p>
یعنی مثلا اگر بخواهیم از یک ثابت در یک کلاس استفاده کنیم کافیست کلمه self و بعد از آن دو نقطه و سپس نام ثابت را بنویسیم. در کد زیر نحوه استفاده از این دو کلمه کلیدی آمده است :
</p>

<pre><code class="language-php   line-numbers">&lt;?php
     class ParentClass
     {
         const NAME = "ParentClass";
         function __construct()
         {
             echo "In " . self::NAME . " constructor" . "<br />";
         }
     }

     class Child extends ParentClass
     {
         const NAME = "Child";
         function __construct()
         {
             parent::__construct();
             echo "In " . self::NAME . " constructor" . "<br />";
         }
     }

     $child = new Child();
 </code></pre>

<p>خروجی : </p>
<pre><code class="language-php">
 In ParentClass constructor
 In Child constructor
  </code></pre>

<p>
  همانطور که احتمالا متوجه شده اید برای دسترسی به اعضا، متدها و ثابت ها بعد از این دو کلمه کلیدی علامت دو نقطه (::) می گذاریم. کلمه کلیدی self در خط 7 به کلاس ParentClass و در خط 17 به کلاس Child اشاره دارد. در همین دو خط علامت دو نقطه و سپس نام ثابت های این دو کلاس یعنی NAME را نوشته ایم و این بدین معنی است که می خواهیم از این ثابت ها استفاده کنیم. در خط 16 برای اینکه از تمام کدهای سازنده کلاس پدر استفاده کنیم، به راحتی کلمه parent و بعد دو نقطه و در نهایت نام سازنده یعنی ()constract__ را می نویسیم. این کار باعث می شود تمام کدهای موجود در سازنده کلاس پدر در داخل کلاس فرزند اجرا شوند. برای همین است که وقتی یک شیء از کلاس فرزند ایجاد می کنیم کدهای سازنده کلاس پدر (خط 7) اجرا می شوند.
  </p>

        </section>
        
<hr>
<p>
<div>منابع مورد مطالعه جهت جمع آوری این مطلب:</div>
<div  class="refrencehref">
        https://roocket.ir/articles/object-oriented-programming-in-php-part-4 <br> http://bshafiei.ir/Article_view/index/1XvocDexH9mhWT/برنامه-نویسی-شی-گرا-در-PHP <br>  http://w3-farsi.ir/?p=2432 <br> http://python.coderz.ir/lessons/l05.html
</div>
</p>

        <hr>
        <style>
    #commentsdiv{
        background-color: #f5f5f5;
        border: 1px solid #c5c5c5;
        border-bottom: 0px !important;
        padding: 12px;
    }
    #commentsborder{
        background-color: #fff;
        border: 1px solid #c5c5c5;
        white-space: normal;
        padding: 20px;
    }
</style>

<div id="commentsdiv">نظرات</div>
<div id="commentsborder">
<div id="wpac-comment"></div>
</div>
<script type="text/javascript">
wpac_init = window.wpac_init || [];
wpac_init.push({widget: 'Comment', id: 7878});
(function() {
    if ('WIDGETPACK_LOADED' in window) return;
    WIDGETPACK_LOADED = true;
    var mc = document.createElement('script');
    mc.type = 'text/javascript';
    mc.async = true;
    mc.src = 'https://embed.widgetpack.com/widget.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
})();
</script>

    </article>
</div>
<script src="/assets/js/anchor.min.js"></script>
<script>
    anchors.options = {
        placement: 'left',
        visible: 'always',
//        icon: '#',
    };
    anchors.add('.anchored h2,.anchored h3,.anchored h4,.anchored h5,.anchored h6');

    (function($){
        if(window.location.hash) {
            var hash = decodeURIComponent(window.location.hash);
            gotohash($(hash).offset().top);
        }
        $('a.anchorjs-link').click(function(){
			gotohash($(this).offset().top);
        });
        $('a.anchorjs').click(function(){
			var id = '#' + $(this).attr('title');
			gotohash($(id).offset().top);
        });		
        function gotohash(top){
            var headerHeight = 70; // Get fixed header height
            $('html,body').animate({
                scrollTop: top - headerHeight
            }, 20);
        }
    })(jQuery);
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script>
   $(document).ready(function (){

     var scrollPosition = getParameterByName('scroll');
     if(scrollPosition)
      $(".doc-menu").scrollTop(scrollPosition);

     $('.doc-link').click(function(){
        var scrollTop = $(".doc-menu").scrollTop();
        if(scrollTop > 0)
          $(this).attr("href",this.href + "?scroll=" + $(".doc-menu").scrollTop());
     });

     function getParameterByName(name, url) {
        if (!url) {
          url = window.location.href;
        }
        name = name.replace(/[\[\]]/g, "\\$&");
        var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
            results = regex.exec(url);
        if (!results) return null;
        if (!results[2]) return '';
        return decodeURIComponent(results[2].replace(/\+/g, " "));
    }

   });
</script>
    <div id="back-to-top" role="button" aria-label="Back to top">
        <i class="fa fa-angle-double-up" aria-hidden="true"></i>
    </div>
</main>
<!-- footer -->

<footer class="footer" role="contentinfo" aria-label="Site footer">
    <div class="navigation" role="navigation" aria-label="Footer links">
        <a href="http://localhost:4000" class="avatar" role="link" ></a>
        <ul role="menubar" aria-label="Footer links menubar">
            <li class="footer-products" role="menuitem" aria-label="Products">
                تولیدات
                <ul role="menu" aria-hidden="true" aria-label="Products link">
                </ul>
            </li>
            <li class="footer-blog" role="menuitem" aria-label="Blog">
                مقالات
                <ul role="menu" aria-hidden="true" aria-label="Blog link">
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2020/07/03/marriage.html" role="link" aria-label="ازدواج">ازدواج</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2019/10/11/vuejs.html" role="link" aria-label="آموزش vuejs">آموزش vuejs</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2017/12/18/laravel.html" role="link" aria-label="آموزش Laravel">آموزش Laravel</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/articles/2017/12/13/laravelcollective.html" role="link" aria-label="معرفی Laravel Collective">معرفی Laravel Collective</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2017/12/06/design-patterns.html" role="link" aria-label="معرفی  Design Pattern">معرفی  Design Pattern</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/blog" role="link" aria-label="Read more">Read More</a></li>
                </ul>
            </li>

            <li class="footer-connect" role="menuitem" aria-label="Connect">
                تماس
                <ul role="menu" aria-hidden="true" aria-label="Connect link">
                    <li role="listitem" aria-label="Connect link item"><a href="https://github.com/farhadmirzapour" target="_blank" role="link" aria-label="GitHub">GitHub</a></li>
                    <li role="listitem" aria-label="Connect link item"><a href="https://www.linkedin.com/in/farhad-mirzapour/" target="_blank" role="link" aria-label="Linkedin">Linkedin</a></li>
                    <li role="listitem" aria-label="Connect link item"><a href="https://twitter.com/farhadmirzapour" target="_blank" role="link" aria-label="Twitter">Twitter</a></li>
                </ul>
            </li>
        </ul>
    </div>
    <div class="socials"  role="navigation" aria-label="Social links">
        <ul role="menu" aria-hidden="true" aria-label="Social link">
            <li role="listitem" aria-label="Social link item"><a href="https://github.com/farhadmirzapour" target="_blank" role="link" aria-label="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a></li>
            <li role="listitem" aria-label="Social link item"><a href="https://twitter.com/farhadmirzapour" target="_blank" role="link" aria-label="Twitter"><i class="fa fa-twitter" aria-hidden="true"></i></a></li>
            <li role="listitem" aria-label="Social link item"><a href="https://www.linkedin.com/in/farhad-mirzapour-0043b862/" target="_blank" role="link" aria-label="Linkedin"><i class="fa fa-linkedin-square" aria-hidden="true"></i></a></li>
            <li role="listitem" aria-label="Social link item"><a href="/feed.xml" role="link" aria-label="RSS"><i class="fa fa-rss-square" aria-hidden="true"></i></a></li>
        </ul>
    </div>
    <div class="copyright" role="contentinfo" aria-label="Copyright">
        <p>&copy; <script type="text/javascript">document.write(new Date().getFullYear());</script> Farhad Mirzapour</p>
    </div>
</footer>

<!-- scripts -->
<script src="/assets/js/hamburger-menu.js"></script>

<script src="/assets/js/elevator.min.js"></script>
<script src="/assets/js/back-to-top.js"></script>
<script src="/assets/prisma/prism.js"></script>
<!-- google analytics -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-108878564-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-108878564-1');
</script>

</body>
</html>