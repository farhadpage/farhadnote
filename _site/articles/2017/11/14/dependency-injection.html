<!DOCTYPE html>
<html lang="">
<!-- head -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>مفهوم Dependency Injection در PHP | مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="مفهوم Dependency Injection در PHP" />
<meta name="author" content="Farhad Mirzapour" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="تزریق وابستگی یا Dependency Injection یک پترن و الگوی طراحی است که هدف اصلی آن حذف وابستگی‌ های موجود بین دو کلاس با استفاده از یک رابط (Interface) است. در تزریق وابستگی ها دو اصطلاح داریم: loosely coupled: بدین معنی‌ست که کمترین وابستگی بین دو کلاس وجود دارد. tight coupled: بدین معنی‌ست که بیشترین وابستگی بین دو کلاس وجود دارد. بنابراین باید برنامه و نرم‌افزار خود را طوری طراحی کنیم که تا حد ممکن استحکام ضعیف (loosely coupled) باشد. هنگامیکه دو کلاس tight coupled هستند (یعنی به همدیگر وابستگی بسیار دارند یا به اصطلاح دیگری در هم چفت شده‌اند) با استفاده از یک رابطه‌ی باینری به یکدیگر متصل هستند و این امر انعطاف‌پذیری نرم‌افزار را به شدت پایین می‌آورد. چرا بایستی کد وابستگی پایینی داشته باشد؟ Extensibility (توسعه پذیری) : با افزودن یک کلاس به برنامه نیازمند تغییرات در بخش های دیگر نباشیم Testability (قابلیت تست پذیری) : فرآیند تست واحد به سهولت و بدون نیاز به در نظرگرفتن بخش های دیگر در آزمون انجام گیرد Late Binding (انقیاد پویا) : بتوان در زمان اجرا و کامپایل خدمات مورداستفاده برنامه را تغییر داد Parallel Development (توسعه موازی) : توسعه یک بخش از برنامه منوط به توسعه بخش خاص دیگری نباشد Maintainability (قابلیت نگه داری) : افزودن بخش های جدید به برنامه و تغییرات پرهزینه نشوند. استفاده از DI یک آینده نگری است. همه ما میدانیم که احتمال تغییرات در سورس همیشه وجود دارد. پس نحوه کد نویسی در بهترین حالت خود, با کمترین تغییرات در آینده بیشترین کارایی را فراهم می نماید. در حالت های کد نویسی آشفته و بی برنامه ممکن است کوچکترین تغییری نیازمند بررسی و تغییر چندین کلاس و چندین فایل و چندین ماژول باشد. اما با برنامه ریزی این تغییرات به حداقل خود خواهد رسید علاوه بر آن مدیریت تغییرات را برای شما آسوده تر خواهد کرد. جهت مفهوم این مطلب به مثال زیر توجه کنید : &lt;?php class Photo { /** * @var PDO The connection to the database */ protected $db; /** * Construct. */ public function __construct() { $this-&gt;db = DB::getInstance(); } } در نگاه اول، این کد ممکن است به نظر بی عیب و بی نقص باشد. اما باید درنظر گرفت کلاس Photo وابستگی زیادی به اتصال پایگاه داده دارد(ممکن است در آینده بخواهیم از انواع مختلف پایگاه داده ها همانند sqlserver,mysql,oracle ... استفاده نماییم که مجبور به تغییرات زیاد در این بخش شده و حتی منجر به ایجاد باگ های زیاد در صورت فراموشی تغییرات مربوطه می گردد). آیا به این فکر می کنید چرا باید کلاس Photo با منابع خارجی ارتباط برقرار کند؟ ایده اصلی این است که هر کلاس مسئول یک وظیفه باشد و با توجه به این نکته مسئولیت اتصال به پایگاه داده طبیعی نیست. (اصل Single Responsibility Principle) بیایید نگاه دوباره ای به کلاس Photo بیاندازیم و اتصال پایگاه داده را به خارج از این کلاس انتقال دهیم. دو راه برای انجام این کار وجود دارد: Constructor Injection (تزریق با استفاده از سازنده کلاس) Setter Injection (تزریق با استفاده از متدهای setter کلاس) تزریق با استفاده از سازنده کلاس (Constructor Injection) در این روش، زمانی که متد سازنده کلاس اجرا می شود، همه وابستگی های مورد نیاز را تزریق می کنیم. همانند کد زیر : &lt;?php class Photo { /** * @var PDO The connection to the database */ protected $db; /** * Construct. * @param PDO $db_conn The database connection */ public function __construct($dbConn) { $this-&gt;db = $dbConn; } } $photo = new Photo($dbConn); تزریق با استفاده از متدهای setter کلاس (Setter Injection) در این روش می توان با استفاده از متدهایی که درون کلاس تعریف می کنیم اشیا کلاس های دیگر را به درون کلاس تزریق نماییم. همانند کد زیر : &lt;?php class Photo { /** * @var PDO The connection to the database */ protected $db; public function __construct() {} /** * Sets the database connection * @param PDO $dbConn The connection to the database. */ public function setDB($dbConn) { $this-&gt;db = $dbConn; } } $photo = new Photo; $photo-&gt;setDB($dbConn); با این تغییر ساده، کلاس دیگر وابسته به هیچ ارتباط خاص نیست. سیستم بیرونی کنترل کامل را حفظ می کند. این تکنیک باعث می شود که کلاس به راحتی تست شود، زیرا ما می توانیم در هنگام عملیات mock کردن دیتابیس در فرآیند تست واحد،از متد setDB استفاده نمائیم. مشکل اساسی جهت استفاده از تزریق کننده ها این است که کاربر باید از وابستگی های کلاس کاملا آگاه باشد و باید آن را به نحوی تنظیم کند. همانند زیر : $photo = new Photo; $photo-&gt;setDB($dbConn); $photo-&gt;setConfig($config); $photo-&gt;setResponse($response); قبل از این کاربر به سادگی می توانست نمونه جدیدی از کلاس Photo را ایجاد کند، اما اکنون باید تمام این وابستگی ها را به یاد داشته باشد که با همچنین در سردرگمی و پیچیدگی مواجه شدیم!!! راه حل این مشکل استفاده از مفهوم Inversion of Control) IoC) می باشد. مفهوم Inversion of Control) IoC) مفهوم Inversion of Control) IoC) بدین صورت بیان می گردد: در این فریم ورک امکان تنظیم اولیه وابستگی‌های سیستم وجود دارد. برای مثال زمانیکه برنامه از یک IoC Container، نوع اینترفیس خاصی را درخواست می‌کند، این فریم ورک با توجه به تنظیمات اولیه‌اش، کلاسی مشخص را بازگشت خواهد داد. به کلاس IoC کد زیر دقت نمایید : // Also frequently called &quot;Container&quot; class IoC { /** * @var PDO The connection to the database */ protected $db; /** * Create a new instance of Photo and set dependencies. */ public static newPhoto() { $photo = new Photo; $photo-&gt;setDB(static::$db); // $photo-&gt;setConfig(); // $photo-&gt;setResponse(); return $photo; } } همانطور که در کد بالا مشاهده می کنید ایجاد یک نمونه از کلاس و نیز فراخوانی وابستگی های مرتبط با آن درون متد newPhoto که بصورت static تعریف شده انجام می گردد. بنابراین هر زمان که به کلاس Photo نیاز داشتیم نیازی به خاطر سپردن وابستگی های مرتبط با آن نیست و تنها کافی است بصورت زیر عمل می کنیم : $photo = IoC::newPhoto(); بسیار خب فرض کنید علاوه بر کلاس Photo کلاس های دیگری نیز داشته باشیم، به جای ایجاد یک متد جدید در IoC به ازای هر کلاس می توانیم از روش عمومی تر همانند زیر استفاده نمائیم : // Also frequently called &quot;Container&quot; class IoC { /** * @var PDO The connection to the database */ protected static $registry = array(); /** * Add a new resolver to the registry array. * @param string $name The id * @param object $resolve Closure that creates instance * @return void */ public static function register($name, Closure $resolve) { static::$registry[$name] = $resolve; } /** * Create the instance * @param string $name The id * @return mixed */ public static function resolve($name) { if ( static::registered($name) ) { $name = static::$registry[$name]; return $name(); } throw new Exception(&#39;Nothing registered with that name, fool.&#39;); } /** * Determine whether the id is registered * @param string $name The id * @return bool Whether to id exists or not */ public static function registered($name) { return array_key_exists($name, static::$registry); } } در کد بالا یک آرایه به نام registry$ ایجاد کرده ایم که با استفاده از متد register مقادیر کلید (نام کلاس) و دیتای متناظر با آن که یک تابع از نوع Closure می باشد مقدار دهی می شود. همچنین از تابع resolve و registered برای بررسی اینکه آیا نام کلاس در آرایه قبلا ثبت شده است و یا خیر استفاده می شود. بنابراین تنها کافی است برای ثبت یک کلاس و وابستگی های مرتبط با آن و سپس فراخوانی کلاس مربوط به آن بدین صورت عمل کنیم : // Add `photo` to the registry array, along with a resolver IoC::register(&#39;photo&#39;, function() { $photo = new Photo; $photo-&gt;setDB(&#39;...&#39;); $photo-&gt;setConfig(&#39;...&#39;); return $photo; }); // Fetch new photo instance with dependencies set $photo = IoC::resolve(&#39;photo&#39;);" />
<meta property="og:description" content="تزریق وابستگی یا Dependency Injection یک پترن و الگوی طراحی است که هدف اصلی آن حذف وابستگی‌ های موجود بین دو کلاس با استفاده از یک رابط (Interface) است. در تزریق وابستگی ها دو اصطلاح داریم: loosely coupled: بدین معنی‌ست که کمترین وابستگی بین دو کلاس وجود دارد. tight coupled: بدین معنی‌ست که بیشترین وابستگی بین دو کلاس وجود دارد. بنابراین باید برنامه و نرم‌افزار خود را طوری طراحی کنیم که تا حد ممکن استحکام ضعیف (loosely coupled) باشد. هنگامیکه دو کلاس tight coupled هستند (یعنی به همدیگر وابستگی بسیار دارند یا به اصطلاح دیگری در هم چفت شده‌اند) با استفاده از یک رابطه‌ی باینری به یکدیگر متصل هستند و این امر انعطاف‌پذیری نرم‌افزار را به شدت پایین می‌آورد. چرا بایستی کد وابستگی پایینی داشته باشد؟ Extensibility (توسعه پذیری) : با افزودن یک کلاس به برنامه نیازمند تغییرات در بخش های دیگر نباشیم Testability (قابلیت تست پذیری) : فرآیند تست واحد به سهولت و بدون نیاز به در نظرگرفتن بخش های دیگر در آزمون انجام گیرد Late Binding (انقیاد پویا) : بتوان در زمان اجرا و کامپایل خدمات مورداستفاده برنامه را تغییر داد Parallel Development (توسعه موازی) : توسعه یک بخش از برنامه منوط به توسعه بخش خاص دیگری نباشد Maintainability (قابلیت نگه داری) : افزودن بخش های جدید به برنامه و تغییرات پرهزینه نشوند. استفاده از DI یک آینده نگری است. همه ما میدانیم که احتمال تغییرات در سورس همیشه وجود دارد. پس نحوه کد نویسی در بهترین حالت خود, با کمترین تغییرات در آینده بیشترین کارایی را فراهم می نماید. در حالت های کد نویسی آشفته و بی برنامه ممکن است کوچکترین تغییری نیازمند بررسی و تغییر چندین کلاس و چندین فایل و چندین ماژول باشد. اما با برنامه ریزی این تغییرات به حداقل خود خواهد رسید علاوه بر آن مدیریت تغییرات را برای شما آسوده تر خواهد کرد. جهت مفهوم این مطلب به مثال زیر توجه کنید : &lt;?php class Photo { /** * @var PDO The connection to the database */ protected $db; /** * Construct. */ public function __construct() { $this-&gt;db = DB::getInstance(); } } در نگاه اول، این کد ممکن است به نظر بی عیب و بی نقص باشد. اما باید درنظر گرفت کلاس Photo وابستگی زیادی به اتصال پایگاه داده دارد(ممکن است در آینده بخواهیم از انواع مختلف پایگاه داده ها همانند sqlserver,mysql,oracle ... استفاده نماییم که مجبور به تغییرات زیاد در این بخش شده و حتی منجر به ایجاد باگ های زیاد در صورت فراموشی تغییرات مربوطه می گردد). آیا به این فکر می کنید چرا باید کلاس Photo با منابع خارجی ارتباط برقرار کند؟ ایده اصلی این است که هر کلاس مسئول یک وظیفه باشد و با توجه به این نکته مسئولیت اتصال به پایگاه داده طبیعی نیست. (اصل Single Responsibility Principle) بیایید نگاه دوباره ای به کلاس Photo بیاندازیم و اتصال پایگاه داده را به خارج از این کلاس انتقال دهیم. دو راه برای انجام این کار وجود دارد: Constructor Injection (تزریق با استفاده از سازنده کلاس) Setter Injection (تزریق با استفاده از متدهای setter کلاس) تزریق با استفاده از سازنده کلاس (Constructor Injection) در این روش، زمانی که متد سازنده کلاس اجرا می شود، همه وابستگی های مورد نیاز را تزریق می کنیم. همانند کد زیر : &lt;?php class Photo { /** * @var PDO The connection to the database */ protected $db; /** * Construct. * @param PDO $db_conn The database connection */ public function __construct($dbConn) { $this-&gt;db = $dbConn; } } $photo = new Photo($dbConn); تزریق با استفاده از متدهای setter کلاس (Setter Injection) در این روش می توان با استفاده از متدهایی که درون کلاس تعریف می کنیم اشیا کلاس های دیگر را به درون کلاس تزریق نماییم. همانند کد زیر : &lt;?php class Photo { /** * @var PDO The connection to the database */ protected $db; public function __construct() {} /** * Sets the database connection * @param PDO $dbConn The connection to the database. */ public function setDB($dbConn) { $this-&gt;db = $dbConn; } } $photo = new Photo; $photo-&gt;setDB($dbConn); با این تغییر ساده، کلاس دیگر وابسته به هیچ ارتباط خاص نیست. سیستم بیرونی کنترل کامل را حفظ می کند. این تکنیک باعث می شود که کلاس به راحتی تست شود، زیرا ما می توانیم در هنگام عملیات mock کردن دیتابیس در فرآیند تست واحد،از متد setDB استفاده نمائیم. مشکل اساسی جهت استفاده از تزریق کننده ها این است که کاربر باید از وابستگی های کلاس کاملا آگاه باشد و باید آن را به نحوی تنظیم کند. همانند زیر : $photo = new Photo; $photo-&gt;setDB($dbConn); $photo-&gt;setConfig($config); $photo-&gt;setResponse($response); قبل از این کاربر به سادگی می توانست نمونه جدیدی از کلاس Photo را ایجاد کند، اما اکنون باید تمام این وابستگی ها را به یاد داشته باشد که با همچنین در سردرگمی و پیچیدگی مواجه شدیم!!! راه حل این مشکل استفاده از مفهوم Inversion of Control) IoC) می باشد. مفهوم Inversion of Control) IoC) مفهوم Inversion of Control) IoC) بدین صورت بیان می گردد: در این فریم ورک امکان تنظیم اولیه وابستگی‌های سیستم وجود دارد. برای مثال زمانیکه برنامه از یک IoC Container، نوع اینترفیس خاصی را درخواست می‌کند، این فریم ورک با توجه به تنظیمات اولیه‌اش، کلاسی مشخص را بازگشت خواهد داد. به کلاس IoC کد زیر دقت نمایید : // Also frequently called &quot;Container&quot; class IoC { /** * @var PDO The connection to the database */ protected $db; /** * Create a new instance of Photo and set dependencies. */ public static newPhoto() { $photo = new Photo; $photo-&gt;setDB(static::$db); // $photo-&gt;setConfig(); // $photo-&gt;setResponse(); return $photo; } } همانطور که در کد بالا مشاهده می کنید ایجاد یک نمونه از کلاس و نیز فراخوانی وابستگی های مرتبط با آن درون متد newPhoto که بصورت static تعریف شده انجام می گردد. بنابراین هر زمان که به کلاس Photo نیاز داشتیم نیازی به خاطر سپردن وابستگی های مرتبط با آن نیست و تنها کافی است بصورت زیر عمل می کنیم : $photo = IoC::newPhoto(); بسیار خب فرض کنید علاوه بر کلاس Photo کلاس های دیگری نیز داشته باشیم، به جای ایجاد یک متد جدید در IoC به ازای هر کلاس می توانیم از روش عمومی تر همانند زیر استفاده نمائیم : // Also frequently called &quot;Container&quot; class IoC { /** * @var PDO The connection to the database */ protected static $registry = array(); /** * Add a new resolver to the registry array. * @param string $name The id * @param object $resolve Closure that creates instance * @return void */ public static function register($name, Closure $resolve) { static::$registry[$name] = $resolve; } /** * Create the instance * @param string $name The id * @return mixed */ public static function resolve($name) { if ( static::registered($name) ) { $name = static::$registry[$name]; return $name(); } throw new Exception(&#39;Nothing registered with that name, fool.&#39;); } /** * Determine whether the id is registered * @param string $name The id * @return bool Whether to id exists or not */ public static function registered($name) { return array_key_exists($name, static::$registry); } } در کد بالا یک آرایه به نام registry$ ایجاد کرده ایم که با استفاده از متد register مقادیر کلید (نام کلاس) و دیتای متناظر با آن که یک تابع از نوع Closure می باشد مقدار دهی می شود. همچنین از تابع resolve و registered برای بررسی اینکه آیا نام کلاس در آرایه قبلا ثبت شده است و یا خیر استفاده می شود. بنابراین تنها کافی است برای ثبت یک کلاس و وابستگی های مرتبط با آن و سپس فراخوانی کلاس مربوط به آن بدین صورت عمل کنیم : // Add `photo` to the registry array, along with a resolver IoC::register(&#39;photo&#39;, function() { $photo = new Photo; $photo-&gt;setDB(&#39;...&#39;); $photo-&gt;setConfig(&#39;...&#39;); return $photo; }); // Fetch new photo instance with dependencies set $photo = IoC::resolve(&#39;photo&#39;);" />
<link rel="canonical" href="http://localhost:4000/articles/2017/11/14/dependency-injection.html" />
<meta property="og:url" content="http://localhost:4000/articles/2017/11/14/dependency-injection.html" />
<meta property="og:site_name" content="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-11-14T22:00:00+03:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="مفهوم Dependency Injection در PHP" />
<meta name="twitter:site" content="@farhadmirzapour" />
<meta name="twitter:creator" content="@Farhad Mirzapour" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Farhad Mirzapour"},"dateModified":"2017-11-14T22:00:00+03:30","datePublished":"2017-11-14T22:00:00+03:30","description":"تزریق وابستگی یا Dependency Injection یک پترن و الگوی طراحی است که هدف اصلی آن حذف وابستگی‌ های موجود بین دو کلاس با استفاده از یک رابط (Interface) است. در تزریق وابستگی ها دو اصطلاح داریم: loosely coupled: بدین معنی‌ست که کمترین وابستگی بین دو کلاس وجود دارد. tight coupled: بدین معنی‌ست که بیشترین وابستگی بین دو کلاس وجود دارد. بنابراین باید برنامه و نرم‌افزار خود را طوری طراحی کنیم که تا حد ممکن استحکام ضعیف (loosely coupled) باشد. هنگامیکه دو کلاس tight coupled هستند (یعنی به همدیگر وابستگی بسیار دارند یا به اصطلاح دیگری در هم چفت شده‌اند) با استفاده از یک رابطه‌ی باینری به یکدیگر متصل هستند و این امر انعطاف‌پذیری نرم‌افزار را به شدت پایین می‌آورد. چرا بایستی کد وابستگی پایینی داشته باشد؟ Extensibility (توسعه پذیری) : با افزودن یک کلاس به برنامه نیازمند تغییرات در بخش های دیگر نباشیم Testability (قابلیت تست پذیری) : فرآیند تست واحد به سهولت و بدون نیاز به در نظرگرفتن بخش های دیگر در آزمون انجام گیرد Late Binding (انقیاد پویا) : بتوان در زمان اجرا و کامپایل خدمات مورداستفاده برنامه را تغییر داد Parallel Development (توسعه موازی) : توسعه یک بخش از برنامه منوط به توسعه بخش خاص دیگری نباشد Maintainability (قابلیت نگه داری) : افزودن بخش های جدید به برنامه و تغییرات پرهزینه نشوند. استفاده از DI یک آینده نگری است. همه ما میدانیم که احتمال تغییرات در سورس همیشه وجود دارد. پس نحوه کد نویسی در بهترین حالت خود, با کمترین تغییرات در آینده بیشترین کارایی را فراهم می نماید. در حالت های کد نویسی آشفته و بی برنامه ممکن است کوچکترین تغییری نیازمند بررسی و تغییر چندین کلاس و چندین فایل و چندین ماژول باشد. اما با برنامه ریزی این تغییرات به حداقل خود خواهد رسید علاوه بر آن مدیریت تغییرات را برای شما آسوده تر خواهد کرد. جهت مفهوم این مطلب به مثال زیر توجه کنید : &lt;?php class Photo { /** * @var PDO The connection to the database */ protected $db; /** * Construct. */ public function __construct() { $this-&gt;db = DB::getInstance(); } } در نگاه اول، این کد ممکن است به نظر بی عیب و بی نقص باشد. اما باید درنظر گرفت کلاس Photo وابستگی زیادی به اتصال پایگاه داده دارد(ممکن است در آینده بخواهیم از انواع مختلف پایگاه داده ها همانند sqlserver,mysql,oracle ... استفاده نماییم که مجبور به تغییرات زیاد در این بخش شده و حتی منجر به ایجاد باگ های زیاد در صورت فراموشی تغییرات مربوطه می گردد). آیا به این فکر می کنید چرا باید کلاس Photo با منابع خارجی ارتباط برقرار کند؟ ایده اصلی این است که هر کلاس مسئول یک وظیفه باشد و با توجه به این نکته مسئولیت اتصال به پایگاه داده طبیعی نیست. (اصل Single Responsibility Principle) بیایید نگاه دوباره ای به کلاس Photo بیاندازیم و اتصال پایگاه داده را به خارج از این کلاس انتقال دهیم. دو راه برای انجام این کار وجود دارد: Constructor Injection (تزریق با استفاده از سازنده کلاس) Setter Injection (تزریق با استفاده از متدهای setter کلاس) تزریق با استفاده از سازنده کلاس (Constructor Injection) در این روش، زمانی که متد سازنده کلاس اجرا می شود، همه وابستگی های مورد نیاز را تزریق می کنیم. همانند کد زیر : &lt;?php class Photo { /** * @var PDO The connection to the database */ protected $db; /** * Construct. * @param PDO $db_conn The database connection */ public function __construct($dbConn) { $this-&gt;db = $dbConn; } } $photo = new Photo($dbConn); تزریق با استفاده از متدهای setter کلاس (Setter Injection) در این روش می توان با استفاده از متدهایی که درون کلاس تعریف می کنیم اشیا کلاس های دیگر را به درون کلاس تزریق نماییم. همانند کد زیر : &lt;?php class Photo { /** * @var PDO The connection to the database */ protected $db; public function __construct() {} /** * Sets the database connection * @param PDO $dbConn The connection to the database. */ public function setDB($dbConn) { $this-&gt;db = $dbConn; } } $photo = new Photo; $photo-&gt;setDB($dbConn); با این تغییر ساده، کلاس دیگر وابسته به هیچ ارتباط خاص نیست. سیستم بیرونی کنترل کامل را حفظ می کند. این تکنیک باعث می شود که کلاس به راحتی تست شود، زیرا ما می توانیم در هنگام عملیات mock کردن دیتابیس در فرآیند تست واحد،از متد setDB استفاده نمائیم. مشکل اساسی جهت استفاده از تزریق کننده ها این است که کاربر باید از وابستگی های کلاس کاملا آگاه باشد و باید آن را به نحوی تنظیم کند. همانند زیر : $photo = new Photo; $photo-&gt;setDB($dbConn); $photo-&gt;setConfig($config); $photo-&gt;setResponse($response); قبل از این کاربر به سادگی می توانست نمونه جدیدی از کلاس Photo را ایجاد کند، اما اکنون باید تمام این وابستگی ها را به یاد داشته باشد که با همچنین در سردرگمی و پیچیدگی مواجه شدیم!!! راه حل این مشکل استفاده از مفهوم Inversion of Control) IoC) می باشد. مفهوم Inversion of Control) IoC) مفهوم Inversion of Control) IoC) بدین صورت بیان می گردد: در این فریم ورک امکان تنظیم اولیه وابستگی‌های سیستم وجود دارد. برای مثال زمانیکه برنامه از یک IoC Container، نوع اینترفیس خاصی را درخواست می‌کند، این فریم ورک با توجه به تنظیمات اولیه‌اش، کلاسی مشخص را بازگشت خواهد داد. به کلاس IoC کد زیر دقت نمایید : // Also frequently called &quot;Container&quot; class IoC { /** * @var PDO The connection to the database */ protected $db; /** * Create a new instance of Photo and set dependencies. */ public static newPhoto() { $photo = new Photo; $photo-&gt;setDB(static::$db); // $photo-&gt;setConfig(); // $photo-&gt;setResponse(); return $photo; } } همانطور که در کد بالا مشاهده می کنید ایجاد یک نمونه از کلاس و نیز فراخوانی وابستگی های مرتبط با آن درون متد newPhoto که بصورت static تعریف شده انجام می گردد. بنابراین هر زمان که به کلاس Photo نیاز داشتیم نیازی به خاطر سپردن وابستگی های مرتبط با آن نیست و تنها کافی است بصورت زیر عمل می کنیم : $photo = IoC::newPhoto(); بسیار خب فرض کنید علاوه بر کلاس Photo کلاس های دیگری نیز داشته باشیم، به جای ایجاد یک متد جدید در IoC به ازای هر کلاس می توانیم از روش عمومی تر همانند زیر استفاده نمائیم : // Also frequently called &quot;Container&quot; class IoC { /** * @var PDO The connection to the database */ protected static $registry = array(); /** * Add a new resolver to the registry array. * @param string $name The id * @param object $resolve Closure that creates instance * @return void */ public static function register($name, Closure $resolve) { static::$registry[$name] = $resolve; } /** * Create the instance * @param string $name The id * @return mixed */ public static function resolve($name) { if ( static::registered($name) ) { $name = static::$registry[$name]; return $name(); } throw new Exception(&#39;Nothing registered with that name, fool.&#39;); } /** * Determine whether the id is registered * @param string $name The id * @return bool Whether to id exists or not */ public static function registered($name) { return array_key_exists($name, static::$registry); } } در کد بالا یک آرایه به نام registry$ ایجاد کرده ایم که با استفاده از متد register مقادیر کلید (نام کلاس) و دیتای متناظر با آن که یک تابع از نوع Closure می باشد مقدار دهی می شود. همچنین از تابع resolve و registered برای بررسی اینکه آیا نام کلاس در آرایه قبلا ثبت شده است و یا خیر استفاده می شود. بنابراین تنها کافی است برای ثبت یک کلاس و وابستگی های مرتبط با آن و سپس فراخوانی کلاس مربوط به آن بدین صورت عمل کنیم : // Add `photo` to the registry array, along with a resolver IoC::register(&#39;photo&#39;, function() { $photo = new Photo; $photo-&gt;setDB(&#39;...&#39;); $photo-&gt;setConfig(&#39;...&#39;); return $photo; }); // Fetch new photo instance with dependencies set $photo = IoC::resolve(&#39;photo&#39;);","headline":"مفهوم Dependency Injection در PHP","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/articles/2017/11/14/dependency-injection.html"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/img/logo/blankspace-avatar.png"},"name":"Farhad Mirzapour"},"url":"http://localhost:4000/articles/2017/11/14/dependency-injection.html"}</script>
<!-- End Jekyll SEO tag -->

    <!-- stylesheets -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css">
    <link rel="stylesheet" href="/assets/main.css">
    <link rel="stylesheet" href="/assets/prisma/prism.css">
    <!-- favicons and rss -->
    <link rel="alternate" type="application/rss+xml" title="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" href="/feed.xml">
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/img/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/img/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/img/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
</head>
<body>
<!-- header -->
<header class="header" role="banner" aria-label="Header">
    <button class="hamburger-button" onclick="hamburgerMenu();" role="button" aria-label="Hamburger menu button">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </button>
    <a href="/" class="logo" role="link" aria-label="Home">
        <img alt="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" src="/assets/img/logo/farhadmirzapour-logo.png" role="img" aria-label="Logo">
    </a>
    <nav class="navigation" role="navigation" aria-label="Navigation">
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
            <li role="menuitem" aria-label="Navigation menu item">
                <a href="/" class="logo" role="menuitem" aria-label="Home">
                    <img alt="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" src="/assets/img/logo/farhadmirzapour-logo.png" role="img" aria-label="Logo">
                </a>
            </li>
            
            <li role="menuitem"><a href="/blog" role="menuitem" aria-label="مقالات">مقالات</a></li>
            
            <li role="menuitem"><a href="/contactus" role="menuitem" aria-label="تماس">تماس</a></li>
            
        </ul>
    </nav>
    <div class="searchbox" role="search" aria-label="Search">
        <form action="/search" id="searchthis" method="get" role="form" aria-label="Search form">
            <i class="fa fa-search" aria-hidden="true"></i>
            <input type="search" id="search" name="query" placeholder="Search..." role="textbox" aria-label="Search textbox">
        </form>
    </div>
</header>

<nav id="hamburger-menu" role="navigation" aria-label="Hamburger menu">
    <div class="searchbox" role="search" aria-label="Search">
        <form action="/search" id="searchthis" method="get" role="form" aria-label="Search form">
            <i class="fa fa-search" aria-hidden="true"></i>
            <input type="search" id="search" name="query" placeholder="Search..." role="textbox" aria-label="Search textbox">
        </form>
    </div>
    <div class="home-nav" role="navigation" aria-label="Site navigation">
        <a href="/" role="menuitem" aria-label="Home">صفحه اصلی</a>
        
        <a href="/blog" role="menuitem" aria-label="مقالات">مقالات</a>
        
        <a href="/contactus" role="menuitem" aria-label="تماس">تماس</a>
        
    </div>

    
</nav>
<!-- main content -->
<main class="container" role="main">
    <div class="rcpostcontainerimg">
<div class="rc-DRTVBanner-new rc-DRTVBanner-bigsize">
    <div style="background: url('/images/original/what-is-dependency-injection.jpg'); " class="blurred_img"></div>
    <div class="mask"></div>
    <div class="bot"></div>
    <div class="over">
        <div class="container-rc">
            <img class="image" src="/images/original/what-is-dependency-injection.jpg" alt="مفهوم Dependency Injection در PHP" height="190">
            <div class="desktop-banner-container">
                <h1 class="display-5-text headline">
                    
                    مفهوم Dependency Injection در PHP
                    
                    </h1>
                <!--<div class="tagslist"><ul class='lyda-tag-list'><li class='lyda-tag-list-title'>برچسب ها</li><li><a class="tags" href="/tag/لاراول">#لاراول</a></li><li><a class="tags" href="/tag/لاراول-5-5">#لاراول 5.5</a></li></ul></div>-->
            </div>
        </div>
    </div>
</div>

<!--<div class="bread-crumb">-->
<!--<div class="container   ">-->
<!--<div class="pull-right ">-->
<!--<div class="bread-button text-custom b-left">-->
<!--انتشار : 2 ماه پیش-->
<!--</div>-->
<!--<a href="/category/article/" class="bread-button back-to-all b-left hidden-xs">همه مقالات</a>-->
<!--<div class="cat-lable">-->
<!--<a href="/category/article/laravel/">-->
<!--لاراول-->
<!--</a>-->
<!--</div>-->
<!--</div>-->
<!--</div>-->
<!--</div>-->
<script>
    $(window).scroll(function(){
        var sticky = $('.doc-menu'),
            scroll = $(window).scrollTop();
        if (scroll >= 101) {sticky.addClass('doc-header-scroll'); }
        else {sticky.removeClass('doc-header-scroll'); };
    });
</script>
</div>
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <div class="time">
    سه شنبه 23 آبان 1396
  </div>
  <div class="post-content anchored" itemprop="articleBody">
    <p>
تزریق وابستگی یا Dependency Injection یک پترن و الگوی طراحی است که هدف اصلی آن حذف وابستگی‌ های موجود بین دو کلاس با استفاده از یک رابط (Interface) است. در تزریق وابستگی ها دو اصطلاح داریم:
</p>

<p>
</p>
<ol>
<li>
<strong>loosely coupled:</strong> بدین معنی‌ست که کمترین وابستگی بین دو کلاس وجود دارد.
</li>
<li>
<strong>tight coupled:</strong> بدین معنی‌ست که بیشترین وابستگی بین دو کلاس وجود دارد.
</li>
</ol>


<blockquote>
<p>
بنابراین باید برنامه و نرم‌افزار خود را طوری طراحی کنیم که تا حد ممکن استحکام ضعیف (loosely coupled) باشد. هنگامیکه دو کلاس tight coupled هستند (یعنی به همدیگر وابستگی بسیار دارند یا به اصطلاح دیگری در هم چفت شده‌اند) با استفاده از یک رابطه‌ی باینری به یکدیگر متصل هستند و این امر انعطاف‌پذیری نرم‌افزار را به شدت پایین می‌آورد.
</p>
</blockquote>

<p><strong>
چرا بایستی کد وابستگی پایینی داشته باشد؟
</strong></p>

<p>
</p>
<ul>
<li>
<strong>Extensibility (توسعه پذیری) :</strong> با افزودن یک کلاس به برنامه نیازمند تغییرات در بخش های دیگر نباشیم
</li>

<li>
<strong>Testability (قابلیت تست پذیری) :</strong> فرآیند تست واحد به سهولت و بدون نیاز به در نظرگرفتن بخش های دیگر در آزمون انجام گیرد
</li>
<li>
<strong>Late Binding (انقیاد پویا) :</strong> بتوان در زمان اجرا و کامپایل خدمات مورداستفاده برنامه را تغییر داد
</li>

<li>
<strong>Parallel Development (توسعه موازی) :</strong> توسعه یک بخش از برنامه منوط به توسعه بخش خاص دیگری نباشد
</li>

<li>
<strong>Maintainability (قابلیت نگه داری) :</strong> افزودن بخش های جدید به برنامه و تغییرات پرهزینه نشوند.
</li>
</ul>


<p>
استفاده از DI یک آینده نگری است. همه ما میدانیم که احتمال تغییرات در سورس همیشه وجود دارد. پس نحوه کد نویسی در بهترین حالت خود, با کمترین تغییرات در آینده بیشترین کارایی را فراهم می نماید. در حالت های کد نویسی آشفته و بی برنامه ممکن است کوچکترین تغییری نیازمند بررسی و تغییر چندین کلاس و چندین فایل و چندین ماژول باشد. اما با برنامه ریزی این تغییرات به حداقل خود خواهد رسید علاوه بر آن مدیریت تغییرات را برای شما آسوده تر خواهد کرد.
</p>

<p>
جهت مفهوم این مطلب به مثال زیر توجه کنید :
</p>

<pre><code class="language-php  line-numbers">&lt;?php
class Photo {
    /**
     * @var PDO The connection to the database
     */
    protected $db;

    /**
     * Construct.
     */
    public function __construct()
    {
        $this-&gt;db = DB::getInstance();
    }
}
</code></pre>

<p>
در نگاه اول، این کد ممکن است به نظر بی عیب و بی نقص باشد. اما باید درنظر گرفت کلاس Photo وابستگی زیادی  به اتصال پایگاه داده دارد(ممکن است در آینده بخواهیم از انواع مختلف پایگاه داده ها همانند sqlserver,mysql,oracle ... استفاده نماییم که مجبور به تغییرات زیاد در این بخش شده و  حتی منجر به ایجاد باگ های زیاد در صورت فراموشی تغییرات مربوطه می گردد). آیا به این فکر می کنید چرا باید کلاس Photo  با منابع خارجی ارتباط برقرار کند؟
</p>

<blockquote>
<p>
ایده اصلی این است که هر کلاس مسئول یک وظیفه باشد و با توجه به این نکته مسئولیت اتصال به پایگاه داده طبیعی نیست. (<a href="/documentation/solid-object-oriented-design/single-responsibility-principle" target="_blank" title="مفهوم Single Responsibility Principle">اصل Single Responsibility Principle</a>)
</p>
</blockquote>

<p>
بیایید نگاه دوباره ای به  کلاس Photo بیاندازیم و اتصال پایگاه داده را به خارج از این کلاس انتقال دهیم. دو راه برای انجام این کار وجود دارد:
</p>
<p>
</p>
<ul>
<li>
Constructor Injection (تزریق با استفاده از سازنده کلاس)
</li>
<li>
Setter Injection (تزریق با استفاده از متدهای setter  کلاس)
</li>
</ul>


<p><br></p>
<h3>تزریق با استفاده از سازنده کلاس (Constructor Injection)</h3>

<p>
در این روش، زمانی که متد سازنده کلاس اجرا می شود، همه وابستگی های مورد نیاز را تزریق می کنیم. همانند کد زیر :
</p>

<pre><code class="language-php  line-numbers">&lt;?php
class Photo {
    /**
     * @var PDO The connection to the database
     */
    protected $db;

    /**
     * Construct.
     * @param PDO $db_conn The database connection
     */
    public function __construct($dbConn)
    {
        $this-&gt;db = $dbConn;
    }
}

$photo = new Photo($dbConn);
</code></pre>

<p><br></p>
<h3>تزریق با استفاده از متدهای setter  کلاس (Setter Injection)</h3>

<p>
در این روش می توان با استفاده از متدهایی که درون کلاس تعریف می کنیم اشیا کلاس های دیگر را به درون کلاس تزریق نماییم. همانند کد زیر :
</p>

<pre><code class="language-php  line-numbers">&lt;?php
class Photo {
    /**
     * @var PDO The connection to the database
     */
    protected $db;

    public function __construct() {}

    /**
     * Sets the database connection
     * @param PDO $dbConn The connection to the database.
     */
    public function setDB($dbConn)
    {
        $this-&gt;db = $dbConn;
    }
}

$photo = new Photo;
$photo-&gt;setDB($dbConn);
</code></pre>

<p>
با این تغییر ساده، کلاس دیگر وابسته به هیچ ارتباط خاص نیست. سیستم بیرونی کنترل کامل را حفظ می کند. این تکنیک باعث می شود که کلاس به راحتی تست شود، زیرا ما می توانیم در هنگام عملیات mock کردن دیتابیس در فرآیند تست واحد،از متد setDB استفاده نمائیم.
</p>

<p>
مشکل اساسی جهت استفاده از تزریق کننده ها این است که کاربر باید از وابستگی های کلاس کاملا آگاه باشد و باید آن را به نحوی تنظیم کند. همانند زیر :
</p>

<pre><code class="language-php  line-numbers">$photo = new Photo;
$photo-&gt;setDB($dbConn);
$photo-&gt;setConfig($config);
$photo-&gt;setResponse($response);
</code></pre>

<p>
 قبل از این کاربر به سادگی می توانست نمونه جدیدی از کلاس Photo را ایجاد کند، اما اکنون باید تمام این وابستگی ها را به یاد داشته باشد که با همچنین در سردرگمی و پیچیدگی مواجه شدیم!!!
</p>

<p>
راه حل این مشکل استفاده از مفهوم  Inversion of Control) IoC) می باشد.
</p>

<p><br></p>
<h3>مفهوم Inversion of Control) IoC)</h3>

<p>
مفهوم Inversion of Control) IoC) بدین صورت بیان می گردد:
</p>

<blockquote>
<p>
 در این فریم ورک امکان تنظیم اولیه وابستگی‌های سیستم وجود دارد. برای مثال زمانیکه برنامه از یک IoC Container، نوع اینترفیس خاصی را درخواست می‌کند، این فریم ورک با توجه به تنظیمات اولیه‌اش، کلاسی مشخص را بازگشت خواهد داد.
</p>
</blockquote>

<p>
به کلاس IoC کد زیر دقت نمایید :
</p>

<pre><code class="language-php  line-numbers">// Also frequently called "Container"
class IoC {
    /**
     * @var PDO The connection to the database
     */
    protected $db;

    /**
     * Create a new instance of Photo and set dependencies.
     */
    public static newPhoto()
    {
        $photo = new Photo;
        $photo-&gt;setDB(static::$db);
        // $photo-&gt;setConfig();
        // $photo-&gt;setResponse();

        return $photo;
    }
}
</code></pre>

<p>
همانطور که در کد بالا مشاهده می کنید ایجاد یک نمونه از کلاس و نیز فراخوانی وابستگی های مرتبط با آن درون متد newPhoto که بصورت static تعریف شده انجام می گردد. بنابراین هر زمان که به کلاس Photo نیاز داشتیم نیازی به خاطر سپردن وابستگی های مرتبط با آن نیست و تنها کافی است بصورت زیر عمل می کنیم :
</p>

<pre><code class="language-php  line-numbers">$photo = IoC::newPhoto();
</code></pre>

<p>
بسیار خب فرض کنید علاوه بر کلاس Photo  کلاس های دیگری  نیز داشته باشیم، به جای ایجاد یک متد جدید در IoC  به ازای هر کلاس می توانیم از روش عمومی تر همانند زیر استفاده نمائیم :
</p>

<pre><code class="language-php  line-numbers">// Also frequently called "Container"
class IoC {
    /**
     * @var PDO The connection to the database
     */
    protected static $registry = array();

    /**
     * Add a new resolver to the registry array.
     * @param  string $name The id
     * @param  object $resolve Closure that creates instance
     * @return void
     */
    public static function register($name, Closure $resolve)
    {
        static::$registry[$name] = $resolve;
    }

    /**
     * Create the instance
     * @param  string $name The id
     * @return mixed
     */
    public static function resolve($name)
    {
        if ( static::registered($name) )
        {
            $name = static::$registry[$name];
            return $name();
        }

        throw new Exception('Nothing registered with that name, fool.');
    }

    /**
     * Determine whether the id is registered
     * @param  string $name The id
     * @return bool Whether to id exists or not
     */
    public static function registered($name)
    {
        return array_key_exists($name, static::$registry);
    }
}
</code></pre>

<p>
در کد بالا یک آرایه به نام  registry$ ایجاد کرده ایم که با استفاده از متد register مقادیر کلید (نام کلاس) و دیتای متناظر با آن که یک تابع از نوع Closure می باشد مقدار دهی می شود. همچنین از تابع resolve و registered برای بررسی اینکه آیا نام کلاس در آرایه قبلا ثبت شده است و یا  خیر استفاده می شود.
</p>

<p>
بنابراین تنها کافی است  برای ثبت یک کلاس و وابستگی های مرتبط با آن و سپس فراخوانی کلاس مربوط به آن بدین صورت عمل کنیم :
</p>

<pre><code class="language-php  line-numbers">// Add `photo` to the registry array, along with a resolver
IoC::register('photo', function() {
    $photo = new Photo;
    $photo-&gt;setDB('...');
    $photo-&gt;setConfig('...');

    return $photo;
});

// Fetch new photo instance with dependencies set
$photo = IoC::resolve('photo');
</code></pre>

  </div>
    
<hr>
<p>
</p>
<div>منابع مورد مطالعه جهت جمع آوری این مطلب:</div>
<div class="refrencehref">
        https://code.tutsplus.com/tutorials/dependency-injection-huh--net-26903 <br> http://roxo.ir/آموزش-تزریق-وابستگی/ <br> http://pikneek.com/programming/زند-فریم-ورک-۲-dependency-injection/
</div>


  <hr>
  <style>
    #commentsdiv{
        background-color: #f5f5f5;
        border: 1px solid #c5c5c5;
        border-bottom: 0px !important;
        padding: 12px;
    }
    #commentsborder{
        background-color: #fff;
        border: 1px solid #c5c5c5;
        white-space: normal;
        padding: 20px;
    }
</style>

<div id="commentsdiv">نظرات</div>
<div id="commentsborder">
<div id="wpac-comment"></div>
</div>
<script type="text/javascript">
wpac_init = window.wpac_init || [];
wpac_init.push({widget: 'Comment', id: 7878});
(function() {
    if ('WIDGETPACK_LOADED' in window) return;
    WIDGETPACK_LOADED = true;
    var mc = document.createElement('script');
    mc.type = 'text/javascript';
    mc.async = true;
    mc.src = 'https://embed.widgetpack.com/widget.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
})();
</script>

</article>
<script src="/assets/js/anchor.min.js"></script>
<script>
    anchors.options = {
        placement: 'left',
        visible: 'always',
//        icon: '#',
    };
    anchors.add('.anchored h2,.anchored h3,.anchored h4,.anchored h5,.anchored h6');

    (function($){
        if(window.location.hash) {
            var hash = decodeURIComponent(window.location.hash);
            gotohash($(hash).offset().top);
        }
        $('a.anchorjs-link').click(function(){
			gotohash($(this).offset().top);
        });
        $('a.anchorjs').click(function(){
			var id = '#' + $(this).attr('title');
			gotohash($(id).offset().top);
        });		
        function gotohash(top){
            var headerHeight = 70; // Get fixed header height
            $('html,body').animate({
                scrollTop: top - headerHeight
            }, 20);
        }
    })(jQuery);
</script>





    <div id="back-to-top" role="button" aria-label="Back to top">
        <i class="fa fa-angle-double-up" aria-hidden="true"></i>
    </div>
</main>
<!-- footer -->

<footer class="footer" role="contentinfo" aria-label="Site footer">
    <div class="navigation" role="navigation" aria-label="Footer links">
        <a href="http://localhost:4000" class="avatar" role="link"></a>
        <ul role="menubar" aria-label="Footer links menubar">
            <li class="footer-products" role="menuitem" aria-label="Products">
                تولیدات
                <ul role="menu" aria-hidden="true" aria-label="Products link">
                </ul>
            </li>
            <li class="footer-blog" role="menuitem" aria-label="Blog">
                مقالات
                <ul role="menu" aria-hidden="true" aria-label="Blog link">
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2020/07/03/marriage.html" role="link" aria-label="ازدواج">ازدواج</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2019/10/11/vuejs.html" role="link" aria-label="آموزش vuejs">آموزش vuejs</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2017/12/18/laravel.html" role="link" aria-label="آموزش Laravel">آموزش Laravel</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/articles/2017/12/13/laravelcollective.html" role="link" aria-label="معرفی Laravel Collective">معرفی Laravel Collective</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2017/12/06/design-patterns.html" role="link" aria-label="معرفی  Design Pattern">معرفی  Design Pattern</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/blog" role="link" aria-label="Read more">Read More</a></li>
                </ul>
            </li>

            <li class="footer-connect" role="menuitem" aria-label="Connect">
                تماس
                <ul role="menu" aria-hidden="true" aria-label="Connect link">
                    <li role="listitem" aria-label="Connect link item"><a href="https://github.com/farhadmirzapour" target="_blank" role="link" aria-label="GitHub">GitHub</a></li>
                    <li role="listitem" aria-label="Connect link item"><a href="https://www.linkedin.com/in/farhad-mirzapour/" target="_blank" role="link" aria-label="Linkedin">Linkedin</a></li>
                    <li role="listitem" aria-label="Connect link item"><a href="https://twitter.com/farhadmirzapour" target="_blank" role="link" aria-label="Twitter">Twitter</a></li>
                </ul>
            </li>
        </ul>
    </div>
    <div class="socials" role="navigation" aria-label="Social links">
        <ul role="menu" aria-hidden="true" aria-label="Social link">
            <li role="listitem" aria-label="Social link item"><a href="https://github.com/farhadmirzapour" target="_blank" role="link" aria-label="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a></li>
            <li role="listitem" aria-label="Social link item"><a href="https://twitter.com/farhadmirzapour" target="_blank" role="link" aria-label="Twitter"><i class="fa fa-twitter" aria-hidden="true"></i></a></li>
            <li role="listitem" aria-label="Social link item"><a href="https://www.linkedin.com/in/farhad-mirzapour-0043b862/" target="_blank" role="link" aria-label="Linkedin"><i class="fa fa-linkedin-square" aria-hidden="true"></i></a></li>
            <li role="listitem" aria-label="Social link item"><a href="/feed.xml" role="link" aria-label="RSS"><i class="fa fa-rss-square" aria-hidden="true"></i></a></li>
        </ul>
    </div>
    <div class="copyright" role="contentinfo" aria-label="Copyright">
        <p>© <script type="text/javascript">document.write(new Date().getFullYear());</script> Farhad Mirzapour</p>
    </div>
</footer>

<!-- scripts -->
<script src="/assets/js/hamburger-menu.js"></script>

<script src="/assets/js/elevator.min.js"></script>
<script src="/assets/js/back-to-top.js"></script>
<script src="/assets/prisma/prism.js"></script>
<!-- google analytics -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-108878564-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-108878564-1');
</script>

</body>
</html>