<!DOCTYPE html>
<html lang="">
<!-- head -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>مفهوم namespace در PHP | مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="مفهوم namespace در PHP" />
<meta name="author" content="Farhad Mirzapour" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="یکی از ویژگی های مهمی که در 5.3 PHP اضافه شد، namespace بود. برنامه نویس های #C و جاوا با این ویژگی آشنا هستند. namespace باعث بهبود ساختار اپلیکیشن‌های PHP میشود به طوری که مشکل نام گذاری‌های یکتا حل، همچنین امکان بخش بندی کدها را به توسعه دهندگان می‌دهد، و سازماندهی و پکیج بندی کدها در آن خیلی شبیه به ساختار دایرکتوری‌ها در فایل سیستم هست. علاوه بر موارد بالا شما را قادر می سازد تا از تمام مزایای autoloaderهایی که از جدیدترین استانداردها پیروی می کنند، که شامل اتولودر کامپوزر (Composer’s autoloader) هم می‌شود بهره ببرید. مفهوم و مقدمات namespace از مزایای namespace گفتیم، اما بیایید کمی دقیق‌تر به موضوع نگاه کنیم. چه زمانی به استفاده از آنها نیاز پیدا می کنیم؟ فضای پیش فرض، که شما در آن به نوشتن کد PHP می‌پردازید فضای سراسری یا global space نام دارد در این فضا شما اجازه تعریف دو کلاس با نام یکسان را ندارید و اگر این کار را انجام دهید با Fatal error روبرو میشوید. این موضوع برای نام تابع‌ها و ثابت‌ها نیز صدق می‌کند. مثال مشابه برای روشن‌تر شدن موضوع، ساختار دایرکتوری‌ها در سیستم عامل‌ها است که امکان ندارد در یک مسیر واحد دو فایل foo.txt ایجاد کرد ولی برای گروه بندی فایل‌های مرتبط می‌توان دایرکتوری دیگری تعریف کرد و یک فایل foo.txt در یک دایرکتوی و فایل foo.txt دیگر را در دایرکتوری دیگر ایجاد کرد. وقتی پروژه گسترده می‌شود این احتمال بالاتر می‌رود که دوباره بخواهیم از نام تابع یا کلاسی که قبلا تعریف شده برای تعریف مجدد استفاده کنید. اوضاع وقتی بدتر می‌شود که بخواهید کامپوننت یا پلاگین شخص دیگری را به پروژه اضافه کنید. این احتمال وجود دارد که در کامپوننتی که میخواهید به پروژه اضافه کنید هم، نام چند تا از کلاسها با نام کلاس‌هایی که شما انتخاب کردید یکی باشد. بنابراین پیامدهایی که بوجود می‌آید شامل موارد زیر هستند: تداخل نام بین کدهایی که شما ایجاد کردید، و کلاس ها و ثابت ها و توابع داخلی PHP و یا کلاس ها و ثابت ها و توابع یک کامپوننت&nbsp;دیگر. برای حل مشکل اول از نام های طولانی و توصیفگر یا پیشوند گذاری قبل بعضی نام ها استفاده می‌شد. که این کار خودش به نوعی کار برنامه‌نویس را سخت‌تر می‌کند. اما حالا براحتی می‌توانیم فضای نام یا namespace تعریف کنیم که با این کار به نوعی کلاس ها و تابع ها و ثابت‌هامون رو بخش بندی خواهیم کرد و دیگر خبری از تداخل نیست. نکته: داخل یک namespace هم طبیعتا نمی توان کلاس‌ها یا تابع‌ها یا ثابت‌های هم نام تعریف کرد. تعریف namespace خط تعریف namespace باید اولین دستور در بالای کدهایتان و قبل از هر کد دیگری باشد. طبق استاندار PSR-2 یک خط خالی بعد از تعریف آن با بقیه کدها باید وجود داشته باشد. &lt;?php namespace FooProject; const CONNECT_OK = 1; class Connection { /* ... */ } function connect() { /* ... */ } تعریف Sub-namespaces مانند فایل‌ها و دایرکتوری‌ها، میتوانید یک ساختار سلسله مراتبی و تو در تو برای کدهایتان درست کنید که با کاراکتر backslash (\) از هم جدا میشوند. &lt;?php namespace MyProject1; class Foo { public function Bar() { echo &#39;Bar method for MyProject1, Foo class. &#39;; } } $objFoo1=new Foo; $objFoo1-&gt;bar(); namespace MyProject2; class Foo { public function Bar() { echo &#39;Bar method for MyProject2, Foo class. &#39;; } } $objFoo2=new Foo; $objFoo2-&gt;bar(); در مثال بالا ما دو namespace در یک فایل PHP تعریف کردیم که اینکار امکان پذیر است، اما هرگز توصیه نمی‌شود و برای هر فایل بایستی یک namespace تعریف کرد. نکته: اگر در یک فایل بخواهید از کد namespace شده و کد namespace نشده (Global code) استفاده کنید. باید از ساختار براکت شده مثل زیر استفاده کنید: &lt;?php namespace MyProject { // MyProject namespace code } namespace { // global code } فراخوانی کدهای Namespace شده در فایل lib1.php، یک ثابت و یک تابع و یک کلاس تعریف کرده ایم و namespace آنرا App\Lib1 قرار داده ایم: &lt;?php // application library 1 namespace App\Lib1; const MYCONST = &#39;App\Lib1\MYCONST&#39;; function MyFunction() { return __FUNCTION__; } class MyClass { static function WhoAmI() { return __METHOD__; } } حال برای صدا زدن (call) کدهای بالا در فایل دیگر برای مثال فایل myapp.php یک روش استفاده از کدی مشابه کد زیر است: &lt;?php header(&#39;Content-type: text/plain&#39;); require_once(&#39;lib1.php&#39;); echo \App\Lib1\MYCONST . &quot;\n&quot;; echo \App\Lib1\MyFunction() . &quot;\n&quot;; echo \App\Lib1\MyClass::WhoAmI() . &quot;\n&quot;; بسیارخب، در کد myapp.php هیچ namespaceایی تعریف نشده، بنابراین در فضای global هستیم. از آنجاییکه MYCONST و MyFunction و MyClass در فضای نام App\Lib1 تعریف شده‌اند شما به طور مستقیم قادر به فراخوانی آنها نیستید و بایستی پیشوند \App\Lib1 را اضافه کنید تا یک نام fully-qualified داشته باشید. در نهایت خروجی زیر را خواهید داشت: &lt;?php App\Lib1\MYCONST App\Lib1\MyFunction App\Lib1\MyClass::WhoAmI اما نام های fully-qualified خیلی طولانی هستند و مزیت زیادی نسبت به مثلا نامگذاری کلاس به صورت App-Lib1-MyClass ندارند. قبل از اینکه بخواهید استفاده از namespaceها را یاد بگیرید مهم است که بدانید PHP چطور تشخیص میدهد که کدام بخش از کد namespace شده درخواست شده است. یک قیاس ساده بین namespaces در PHP و فایل سیستم می‌تواند مثال خوبی باشد. در فایل سیستم 3 راه برای دسترسی به یک فایل داریم: نام فایل به صورت نسبی (Relative) باشد مانند foo.txt. که این مسیر به currentdirectory/foo.txt تبدیل می‌شود که currentdirectory همان دایرکتوری جاری است که در آن قرار داریم. آدرس دهی نسبی مثل subdirectory/foo.txt که به currentdirectory/subdirectory/foo.txt تبدیل میشود. آدرس دهی مطلق مانند main/foo.txt/&nbsp;که تبدیل می‌شود&nbsp;به main/foo.txt/&nbsp;(یعنی به خودش). همین قاعده نیز برای عناصر namespace شده PHP کاربرد دارد. مثلا نام کلاس به سه روش زیر معرفی شده: 1. Unqualified name یا نام کلاس بدون پیشوند مثل : $a = new foo(); یا foo::staticmethod(); اگر namespace جاری currentnamespace باشد، تبدیل می‌شود به currentnamespace\foo اگر هم بدون namespace باشد تبدیل می شود به foo. نکته: وقتی علامت \ را قبل از نام تابع یا ثابت قرار بدهیم تابع یا ثابت global هدف قرار میگیرد. &lt;?php namespace A\B\C; function strlen($str) { return &#39;ok&#39;; } echo strlen(&#39;hi&#39;), &quot;&quot;; // prints &quot;ok&quot; echo \strlen(&#39;hi&#39;), &quot;&quot;; // prints &quot;2&quot; 2. Qualified name یا نام کلاس همراه با پیشوند مثل : $a = new subnamespace\foo(); یا subnamespace\foo::staticmethod(); اگر namespace جاری currentnamespace باشد تبدیل به currentnamespace\subnamespace\foo می‌شود و اگر بدون namespace باشد، subnamespace\foo اجرا می‌شود. 3. Fully qualified name یا نام پیشوند گذاری شده با پیشوند global \ مثل : new \currentnamespace\foo(); یا \currentnamespace\foo::staticmethod(); همیشه تبدیل می‌شود به همان نام مشخص شده یعنی خودش currentnamespace\foo" />
<meta property="og:description" content="یکی از ویژگی های مهمی که در 5.3 PHP اضافه شد، namespace بود. برنامه نویس های #C و جاوا با این ویژگی آشنا هستند. namespace باعث بهبود ساختار اپلیکیشن‌های PHP میشود به طوری که مشکل نام گذاری‌های یکتا حل، همچنین امکان بخش بندی کدها را به توسعه دهندگان می‌دهد، و سازماندهی و پکیج بندی کدها در آن خیلی شبیه به ساختار دایرکتوری‌ها در فایل سیستم هست. علاوه بر موارد بالا شما را قادر می سازد تا از تمام مزایای autoloaderهایی که از جدیدترین استانداردها پیروی می کنند، که شامل اتولودر کامپوزر (Composer’s autoloader) هم می‌شود بهره ببرید. مفهوم و مقدمات namespace از مزایای namespace گفتیم، اما بیایید کمی دقیق‌تر به موضوع نگاه کنیم. چه زمانی به استفاده از آنها نیاز پیدا می کنیم؟ فضای پیش فرض، که شما در آن به نوشتن کد PHP می‌پردازید فضای سراسری یا global space نام دارد در این فضا شما اجازه تعریف دو کلاس با نام یکسان را ندارید و اگر این کار را انجام دهید با Fatal error روبرو میشوید. این موضوع برای نام تابع‌ها و ثابت‌ها نیز صدق می‌کند. مثال مشابه برای روشن‌تر شدن موضوع، ساختار دایرکتوری‌ها در سیستم عامل‌ها است که امکان ندارد در یک مسیر واحد دو فایل foo.txt ایجاد کرد ولی برای گروه بندی فایل‌های مرتبط می‌توان دایرکتوری دیگری تعریف کرد و یک فایل foo.txt در یک دایرکتوی و فایل foo.txt دیگر را در دایرکتوری دیگر ایجاد کرد. وقتی پروژه گسترده می‌شود این احتمال بالاتر می‌رود که دوباره بخواهیم از نام تابع یا کلاسی که قبلا تعریف شده برای تعریف مجدد استفاده کنید. اوضاع وقتی بدتر می‌شود که بخواهید کامپوننت یا پلاگین شخص دیگری را به پروژه اضافه کنید. این احتمال وجود دارد که در کامپوننتی که میخواهید به پروژه اضافه کنید هم، نام چند تا از کلاسها با نام کلاس‌هایی که شما انتخاب کردید یکی باشد. بنابراین پیامدهایی که بوجود می‌آید شامل موارد زیر هستند: تداخل نام بین کدهایی که شما ایجاد کردید، و کلاس ها و ثابت ها و توابع داخلی PHP و یا کلاس ها و ثابت ها و توابع یک کامپوننت&nbsp;دیگر. برای حل مشکل اول از نام های طولانی و توصیفگر یا پیشوند گذاری قبل بعضی نام ها استفاده می‌شد. که این کار خودش به نوعی کار برنامه‌نویس را سخت‌تر می‌کند. اما حالا براحتی می‌توانیم فضای نام یا namespace تعریف کنیم که با این کار به نوعی کلاس ها و تابع ها و ثابت‌هامون رو بخش بندی خواهیم کرد و دیگر خبری از تداخل نیست. نکته: داخل یک namespace هم طبیعتا نمی توان کلاس‌ها یا تابع‌ها یا ثابت‌های هم نام تعریف کرد. تعریف namespace خط تعریف namespace باید اولین دستور در بالای کدهایتان و قبل از هر کد دیگری باشد. طبق استاندار PSR-2 یک خط خالی بعد از تعریف آن با بقیه کدها باید وجود داشته باشد. &lt;?php namespace FooProject; const CONNECT_OK = 1; class Connection { /* ... */ } function connect() { /* ... */ } تعریف Sub-namespaces مانند فایل‌ها و دایرکتوری‌ها، میتوانید یک ساختار سلسله مراتبی و تو در تو برای کدهایتان درست کنید که با کاراکتر backslash (\) از هم جدا میشوند. &lt;?php namespace MyProject1; class Foo { public function Bar() { echo &#39;Bar method for MyProject1, Foo class. &#39;; } } $objFoo1=new Foo; $objFoo1-&gt;bar(); namespace MyProject2; class Foo { public function Bar() { echo &#39;Bar method for MyProject2, Foo class. &#39;; } } $objFoo2=new Foo; $objFoo2-&gt;bar(); در مثال بالا ما دو namespace در یک فایل PHP تعریف کردیم که اینکار امکان پذیر است، اما هرگز توصیه نمی‌شود و برای هر فایل بایستی یک namespace تعریف کرد. نکته: اگر در یک فایل بخواهید از کد namespace شده و کد namespace نشده (Global code) استفاده کنید. باید از ساختار براکت شده مثل زیر استفاده کنید: &lt;?php namespace MyProject { // MyProject namespace code } namespace { // global code } فراخوانی کدهای Namespace شده در فایل lib1.php، یک ثابت و یک تابع و یک کلاس تعریف کرده ایم و namespace آنرا App\Lib1 قرار داده ایم: &lt;?php // application library 1 namespace App\Lib1; const MYCONST = &#39;App\Lib1\MYCONST&#39;; function MyFunction() { return __FUNCTION__; } class MyClass { static function WhoAmI() { return __METHOD__; } } حال برای صدا زدن (call) کدهای بالا در فایل دیگر برای مثال فایل myapp.php یک روش استفاده از کدی مشابه کد زیر است: &lt;?php header(&#39;Content-type: text/plain&#39;); require_once(&#39;lib1.php&#39;); echo \App\Lib1\MYCONST . &quot;\n&quot;; echo \App\Lib1\MyFunction() . &quot;\n&quot;; echo \App\Lib1\MyClass::WhoAmI() . &quot;\n&quot;; بسیارخب، در کد myapp.php هیچ namespaceایی تعریف نشده، بنابراین در فضای global هستیم. از آنجاییکه MYCONST و MyFunction و MyClass در فضای نام App\Lib1 تعریف شده‌اند شما به طور مستقیم قادر به فراخوانی آنها نیستید و بایستی پیشوند \App\Lib1 را اضافه کنید تا یک نام fully-qualified داشته باشید. در نهایت خروجی زیر را خواهید داشت: &lt;?php App\Lib1\MYCONST App\Lib1\MyFunction App\Lib1\MyClass::WhoAmI اما نام های fully-qualified خیلی طولانی هستند و مزیت زیادی نسبت به مثلا نامگذاری کلاس به صورت App-Lib1-MyClass ندارند. قبل از اینکه بخواهید استفاده از namespaceها را یاد بگیرید مهم است که بدانید PHP چطور تشخیص میدهد که کدام بخش از کد namespace شده درخواست شده است. یک قیاس ساده بین namespaces در PHP و فایل سیستم می‌تواند مثال خوبی باشد. در فایل سیستم 3 راه برای دسترسی به یک فایل داریم: نام فایل به صورت نسبی (Relative) باشد مانند foo.txt. که این مسیر به currentdirectory/foo.txt تبدیل می‌شود که currentdirectory همان دایرکتوری جاری است که در آن قرار داریم. آدرس دهی نسبی مثل subdirectory/foo.txt که به currentdirectory/subdirectory/foo.txt تبدیل میشود. آدرس دهی مطلق مانند main/foo.txt/&nbsp;که تبدیل می‌شود&nbsp;به main/foo.txt/&nbsp;(یعنی به خودش). همین قاعده نیز برای عناصر namespace شده PHP کاربرد دارد. مثلا نام کلاس به سه روش زیر معرفی شده: 1. Unqualified name یا نام کلاس بدون پیشوند مثل : $a = new foo(); یا foo::staticmethod(); اگر namespace جاری currentnamespace باشد، تبدیل می‌شود به currentnamespace\foo اگر هم بدون namespace باشد تبدیل می شود به foo. نکته: وقتی علامت \ را قبل از نام تابع یا ثابت قرار بدهیم تابع یا ثابت global هدف قرار میگیرد. &lt;?php namespace A\B\C; function strlen($str) { return &#39;ok&#39;; } echo strlen(&#39;hi&#39;), &quot;&quot;; // prints &quot;ok&quot; echo \strlen(&#39;hi&#39;), &quot;&quot;; // prints &quot;2&quot; 2. Qualified name یا نام کلاس همراه با پیشوند مثل : $a = new subnamespace\foo(); یا subnamespace\foo::staticmethod(); اگر namespace جاری currentnamespace باشد تبدیل به currentnamespace\subnamespace\foo می‌شود و اگر بدون namespace باشد، subnamespace\foo اجرا می‌شود. 3. Fully qualified name یا نام پیشوند گذاری شده با پیشوند global \ مثل : new \currentnamespace\foo(); یا \currentnamespace\foo::staticmethod(); همیشه تبدیل می‌شود به همان نام مشخص شده یعنی خودش currentnamespace\foo" />
<link rel="canonical" href="http://localhost:4000/articles/2017/11/05/namespace.html" />
<meta property="og:url" content="http://localhost:4000/articles/2017/11/05/namespace.html" />
<meta property="og:site_name" content="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-11-05T20:35:42+03:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="مفهوم namespace در PHP" />
<meta name="twitter:site" content="@farhadmirzapour" />
<meta name="twitter:creator" content="@Farhad Mirzapour" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"مفهوم namespace در PHP","url":"http://localhost:4000/articles/2017/11/05/namespace.html","datePublished":"2017-11-05T20:35:42+03:30","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/img/logo/blankspace-avatar.png"},"name":"Farhad Mirzapour"},"dateModified":"2017-11-05T20:35:42+03:30","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/articles/2017/11/05/namespace.html"},"author":{"@type":"Person","name":"Farhad Mirzapour"},"description":"یکی از ویژگی های مهمی که در 5.3 PHP اضافه شد، namespace بود. برنامه نویس های #C و جاوا با این ویژگی آشنا هستند. namespace باعث بهبود ساختار اپلیکیشن‌های PHP میشود به طوری که مشکل نام گذاری‌های یکتا حل، همچنین امکان بخش بندی کدها را به توسعه دهندگان می‌دهد، و سازماندهی و پکیج بندی کدها در آن خیلی شبیه به ساختار دایرکتوری‌ها در فایل سیستم هست. علاوه بر موارد بالا شما را قادر می سازد تا از تمام مزایای autoloaderهایی که از جدیدترین استانداردها پیروی می کنند، که شامل اتولودر کامپوزر (Composer’s autoloader) هم می‌شود بهره ببرید. مفهوم و مقدمات namespace از مزایای namespace گفتیم، اما بیایید کمی دقیق‌تر به موضوع نگاه کنیم. چه زمانی به استفاده از آنها نیاز پیدا می کنیم؟ فضای پیش فرض، که شما در آن به نوشتن کد PHP می‌پردازید فضای سراسری یا global space نام دارد در این فضا شما اجازه تعریف دو کلاس با نام یکسان را ندارید و اگر این کار را انجام دهید با Fatal error روبرو میشوید. این موضوع برای نام تابع‌ها و ثابت‌ها نیز صدق می‌کند. مثال مشابه برای روشن‌تر شدن موضوع، ساختار دایرکتوری‌ها در سیستم عامل‌ها است که امکان ندارد در یک مسیر واحد دو فایل foo.txt ایجاد کرد ولی برای گروه بندی فایل‌های مرتبط می‌توان دایرکتوری دیگری تعریف کرد و یک فایل foo.txt در یک دایرکتوی و فایل foo.txt دیگر را در دایرکتوری دیگر ایجاد کرد. وقتی پروژه گسترده می‌شود این احتمال بالاتر می‌رود که دوباره بخواهیم از نام تابع یا کلاسی که قبلا تعریف شده برای تعریف مجدد استفاده کنید. اوضاع وقتی بدتر می‌شود که بخواهید کامپوننت یا پلاگین شخص دیگری را به پروژه اضافه کنید. این احتمال وجود دارد که در کامپوننتی که میخواهید به پروژه اضافه کنید هم، نام چند تا از کلاسها با نام کلاس‌هایی که شما انتخاب کردید یکی باشد. بنابراین پیامدهایی که بوجود می‌آید شامل موارد زیر هستند: تداخل نام بین کدهایی که شما ایجاد کردید، و کلاس ها و ثابت ها و توابع داخلی PHP و یا کلاس ها و ثابت ها و توابع یک کامپوننت&nbsp;دیگر. برای حل مشکل اول از نام های طولانی و توصیفگر یا پیشوند گذاری قبل بعضی نام ها استفاده می‌شد. که این کار خودش به نوعی کار برنامه‌نویس را سخت‌تر می‌کند. اما حالا براحتی می‌توانیم فضای نام یا namespace تعریف کنیم که با این کار به نوعی کلاس ها و تابع ها و ثابت‌هامون رو بخش بندی خواهیم کرد و دیگر خبری از تداخل نیست. نکته: داخل یک namespace هم طبیعتا نمی توان کلاس‌ها یا تابع‌ها یا ثابت‌های هم نام تعریف کرد. تعریف namespace خط تعریف namespace باید اولین دستور در بالای کدهایتان و قبل از هر کد دیگری باشد. طبق استاندار PSR-2 یک خط خالی بعد از تعریف آن با بقیه کدها باید وجود داشته باشد. &lt;?php namespace FooProject; const CONNECT_OK = 1; class Connection { /* ... */ } function connect() { /* ... */ } تعریف Sub-namespaces مانند فایل‌ها و دایرکتوری‌ها، میتوانید یک ساختار سلسله مراتبی و تو در تو برای کدهایتان درست کنید که با کاراکتر backslash (\\) از هم جدا میشوند. &lt;?php namespace MyProject1; class Foo { public function Bar() { echo &#39;Bar method for MyProject1, Foo class. &#39;; } } $objFoo1=new Foo; $objFoo1-&gt;bar(); namespace MyProject2; class Foo { public function Bar() { echo &#39;Bar method for MyProject2, Foo class. &#39;; } } $objFoo2=new Foo; $objFoo2-&gt;bar(); در مثال بالا ما دو namespace در یک فایل PHP تعریف کردیم که اینکار امکان پذیر است، اما هرگز توصیه نمی‌شود و برای هر فایل بایستی یک namespace تعریف کرد. نکته: اگر در یک فایل بخواهید از کد namespace شده و کد namespace نشده (Global code) استفاده کنید. باید از ساختار براکت شده مثل زیر استفاده کنید: &lt;?php namespace MyProject { // MyProject namespace code } namespace { // global code } فراخوانی کدهای Namespace شده در فایل lib1.php، یک ثابت و یک تابع و یک کلاس تعریف کرده ایم و namespace آنرا App\\Lib1 قرار داده ایم: &lt;?php // application library 1 namespace App\\Lib1; const MYCONST = &#39;App\\Lib1\\MYCONST&#39;; function MyFunction() { return __FUNCTION__; } class MyClass { static function WhoAmI() { return __METHOD__; } } حال برای صدا زدن (call) کدهای بالا در فایل دیگر برای مثال فایل myapp.php یک روش استفاده از کدی مشابه کد زیر است: &lt;?php header(&#39;Content-type: text/plain&#39;); require_once(&#39;lib1.php&#39;); echo \\App\\Lib1\\MYCONST . &quot;\\n&quot;; echo \\App\\Lib1\\MyFunction() . &quot;\\n&quot;; echo \\App\\Lib1\\MyClass::WhoAmI() . &quot;\\n&quot;; بسیارخب، در کد myapp.php هیچ namespaceایی تعریف نشده، بنابراین در فضای global هستیم. از آنجاییکه MYCONST و MyFunction و MyClass در فضای نام App\\Lib1 تعریف شده‌اند شما به طور مستقیم قادر به فراخوانی آنها نیستید و بایستی پیشوند \\App\\Lib1 را اضافه کنید تا یک نام fully-qualified داشته باشید. در نهایت خروجی زیر را خواهید داشت: &lt;?php App\\Lib1\\MYCONST App\\Lib1\\MyFunction App\\Lib1\\MyClass::WhoAmI اما نام های fully-qualified خیلی طولانی هستند و مزیت زیادی نسبت به مثلا نامگذاری کلاس به صورت App-Lib1-MyClass ندارند. قبل از اینکه بخواهید استفاده از namespaceها را یاد بگیرید مهم است که بدانید PHP چطور تشخیص میدهد که کدام بخش از کد namespace شده درخواست شده است. یک قیاس ساده بین namespaces در PHP و فایل سیستم می‌تواند مثال خوبی باشد. در فایل سیستم 3 راه برای دسترسی به یک فایل داریم: نام فایل به صورت نسبی (Relative) باشد مانند foo.txt. که این مسیر به currentdirectory/foo.txt تبدیل می‌شود که currentdirectory همان دایرکتوری جاری است که در آن قرار داریم. آدرس دهی نسبی مثل subdirectory/foo.txt که به currentdirectory/subdirectory/foo.txt تبدیل میشود. آدرس دهی مطلق مانند main/foo.txt/&nbsp;که تبدیل می‌شود&nbsp;به main/foo.txt/&nbsp;(یعنی به خودش). همین قاعده نیز برای عناصر namespace شده PHP کاربرد دارد. مثلا نام کلاس به سه روش زیر معرفی شده: 1. Unqualified name یا نام کلاس بدون پیشوند مثل : $a = new foo(); یا foo::staticmethod(); اگر namespace جاری currentnamespace باشد، تبدیل می‌شود به currentnamespace\\foo اگر هم بدون namespace باشد تبدیل می شود به foo. نکته: وقتی علامت \\ را قبل از نام تابع یا ثابت قرار بدهیم تابع یا ثابت global هدف قرار میگیرد. &lt;?php namespace A\\B\\C; function strlen($str) { return &#39;ok&#39;; } echo strlen(&#39;hi&#39;), &quot;&quot;; // prints &quot;ok&quot; echo \\strlen(&#39;hi&#39;), &quot;&quot;; // prints &quot;2&quot; 2. Qualified name یا نام کلاس همراه با پیشوند مثل : $a = new subnamespace\\foo(); یا subnamespace\\foo::staticmethod(); اگر namespace جاری currentnamespace باشد تبدیل به currentnamespace\\subnamespace\\foo می‌شود و اگر بدون namespace باشد، subnamespace\\foo اجرا می‌شود. 3. Fully qualified name یا نام پیشوند گذاری شده با پیشوند global \\ مثل : new \\currentnamespace\\foo(); یا \\currentnamespace\\foo::staticmethod(); همیشه تبدیل می‌شود به همان نام مشخص شده یعنی خودش currentnamespace\\foo","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <!-- stylesheets -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css">
    <link rel="stylesheet" href="/assets/main.css">
    <link rel="stylesheet" href="/assets/prisma/prism.css">
    <!-- favicons and rss -->
    <link rel="alternate" type="application/rss+xml" title="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" href="/feed.xml">
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/img/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/img/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/img/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
</head>
<body>
<!-- header -->
<header class="header" role="banner" aria-label="Header">
    <button class="hamburger-button" onclick="hamburgerMenu();" role="button" aria-label="Hamburger menu button">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </button>
    <a href="/" class="logo" role="link" aria-label="Home">
        <img alt="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" src="/assets/img/logo/farhadmirzapour-logo.png" role="img" aria-label="Logo"/>
    </a>
    <nav class="navigation" role="navigation" aria-label="Navigation">
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
            <li role="menuitem" aria-label="Navigation menu item">
                <a href="/" class="logo" role="menuitem" aria-label="Home">
                    <img alt="مجموعه مقالات و مطالب آموزشی وب - گرداوری توسط فرهاد میرزاپور" src="/assets/img/logo/farhadmirzapour-logo.png" role="img" aria-label="Logo"/>
                </a>
            </li>
            
            <li role="menuitem"><a href="/blog" role="menuitem" aria-label="مقالات">مقالات</a></li>
            
            <li role="menuitem"><a href="/contactus" role="menuitem" aria-label="تماس">تماس</a></li>
            
        </ul>
    </nav>
    <div class="searchbox" role="search" aria-label="Search">
        <form action="/search" id="searchthis" method="get" role="form" aria-label="Search form">
            <i class="fa fa-search" aria-hidden="true"></i>
            <input type="search" id="search" name="query" placeholder="Search..." role="textbox" aria-label="Search textbox"/>
        </form>
    </div>
</header>

<nav id="hamburger-menu" role="navigation" aria-label="Hamburger menu">
    <div class="searchbox" role="search" aria-label="Search">
        <form action="/search" id="searchthis" method="get" role="form" aria-label="Search form">
            <i class="fa fa-search" aria-hidden="true"></i>
            <input type="search" id="search" name="query" placeholder="Search..." role="textbox" aria-label="Search textbox"/>
        </form>
    </div>
    <div class="home-nav" role="navigation" aria-label="Site navigation">
        <a href="/" role="menuitem" aria-label="Home">صفحه اصلی</a>
        
        <a href="/blog" role="menuitem" aria-label="مقالات">مقالات</a>
        
        <a href="/contactus" role="menuitem" aria-label="تماس">تماس</a>
        
    </div>

    
</nav>
<!-- main content -->
<main class="container" role="main">
    <div class="rcpostcontainerimg">
<div class="rc-DRTVBanner-new rc-DRTVBanner-bigsize">
    <div style="background: url('/images/original/namespaces-1024x413-compressor.jpg'); " class="blurred_img"></div>
    <div class="mask"></div>
    <div class="bot"></div>
    <div class="over">
        <div class="container-rc">
            <img class="image" src="/images/original/namespaces-1024x413-compressor.jpg" alt="مفهوم namespace  در PHP" height="190">
            <div class="desktop-banner-container">
                <h1 class="display-5-text headline">
                    
                    مفهوم namespace  در PHP
                    
                    </h1>
                <!--<div class="tagslist"><ul class='lyda-tag-list'><li class='lyda-tag-list-title'>برچسب ها</li><li><a class="tags" href="/tag/لاراول">#لاراول</a></li><li><a class="tags" href="/tag/لاراول-5-5">#لاراول 5.5</a></li></ul></div>-->
            </div>
        </div>
    </div>
</div>

<!--<div class="bread-crumb">-->
<!--<div class="container   ">-->
<!--<div class="pull-right ">-->
<!--<div class="bread-button text-custom b-left">-->
<!--انتشار : 2 ماه پیش-->
<!--</div>-->
<!--<a href="/category/article/" class="bread-button back-to-all b-left hidden-xs">همه مقالات</a>-->
<!--<div class="cat-lable">-->
<!--<a href="/category/article/laravel/">-->
<!--لاراول-->
<!--</a>-->
<!--</div>-->
<!--</div>-->
<!--</div>-->
<!--</div>-->
<script>
    $(window).scroll(function(){
        var sticky = $('.doc-menu'),
            scroll = $(window).scrollTop();
        if (scroll >= 101) {sticky.addClass('doc-header-scroll'); }
        else {sticky.removeClass('doc-header-scroll'); };
    });
</script>
</div>
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <div class="time">
    یکشنبه 14 آبان 1396
  </div>
  <div class="post-content anchored" itemprop="articleBody">
    <p>
یکی از ویژگی های مهمی که در 5.3 PHP اضافه شد، namespace بود. برنامه نویس های #C و جاوا با این ویژگی آشنا هستند.

namespace باعث بهبود ساختار اپلیکیشن‌های PHP میشود به طوری که مشکل نام گذاری‌های یکتا حل، همچنین امکان بخش بندی کدها را به توسعه دهندگان می‌دهد، و سازماندهی و پکیج بندی کدها در آن خیلی شبیه به ساختار دایرکتوری‌ها در فایل سیستم هست.

علاوه بر موارد بالا شما را قادر می سازد تا از تمام مزایای autoloaderهایی که از جدیدترین استانداردها پیروی می کنند، که شامل اتولودر کامپوزر (Composer’s autoloader) هم می‌شود بهره ببرید.
</p>

<h3>مفهوم و مقدمات namespace</h3>

<p>از مزایای namespace گفتیم، اما بیایید کمی دقیق‌تر به موضوع نگاه کنیم. چه زمانی به استفاده از آنها نیاز پیدا می کنیم؟</p>

<p>
فضای پیش فرض، که شما در آن به نوشتن کد PHP می‌پردازید فضای سراسری یا global space نام دارد در این فضا شما اجازه تعریف دو کلاس با نام یکسان را ندارید و اگر این کار را انجام دهید با Fatal error روبرو میشوید. این موضوع برای نام تابع‌ها و ثابت‌ها نیز صدق می‌کند.
</p>

<p>
مثال مشابه برای روشن‌تر شدن موضوع، ساختار دایرکتوری‌ها در سیستم عامل‌ها است که امکان ندارد در یک مسیر واحد دو فایل foo.txt ایجاد کرد ولی برای گروه بندی فایل‌های مرتبط می‌توان دایرکتوری دیگری تعریف کرد و یک فایل foo.txt در یک دایرکتوی و فایل foo.txt دیگر را در دایرکتوری دیگر ایجاد کرد.
</p>

<p>
وقتی پروژه گسترده می‌شود این احتمال بالاتر می‌رود که دوباره بخواهیم از نام تابع یا کلاسی که قبلا تعریف شده برای تعریف مجدد استفاده کنید. اوضاع وقتی بدتر می‌شود که بخواهید کامپوننت یا پلاگین شخص دیگری را به پروژه اضافه کنید.
</p>

<p>
این احتمال وجود دارد که در کامپوننتی که میخواهید به پروژه اضافه کنید هم، نام چند تا از کلاسها با نام کلاس‌هایی که شما انتخاب کردید یکی باشد.
</p>

<p>
بنابراین پیامدهایی که بوجود می‌آید شامل موارد زیر هستند:
</p>

<p>
<ul>
<li>تداخل نام بین کدهایی که شما ایجاد کردید، و کلاس ها و ثابت ها و توابع داخلی PHP و یا کلاس ها و ثابت ها و توابع یک کامپوننت&nbsp;دیگر.</li>
<li>برای حل مشکل اول از نام های طولانی و توصیفگر یا پیشوند گذاری قبل بعضی نام ها استفاده می‌شد. که این کار خودش به نوعی کار برنامه‌نویس را سخت‌تر می‌کند.</li>
</ul>
</p>

<p>
اما حالا براحتی می‌توانیم فضای نام یا namespace تعریف کنیم که با این کار به نوعی کلاس ها و تابع ها و ثابت‌هامون رو بخش بندی خواهیم کرد و دیگر خبری از تداخل نیست.
</p>

<p>
نکته: داخل یک namespace هم طبیعتا نمی توان کلاس‌ها یا تابع‌ها یا ثابت‌های هم نام تعریف کرد.
</p>

<h3>تعریف namespace</h3>

<p>
خط تعریف namespace باید اولین دستور در بالای کدهایتان و قبل از هر کد دیگری باشد. طبق استاندار PSR-2 یک خط خالی بعد از تعریف آن با بقیه کدها باید وجود داشته باشد.
</p>

<pre><code class="language-php  line-numbers">&lt;?php
namespace FooProject;

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
</code></pre>

<h3>تعریف Sub-namespaces</h3>

<p>
مانند فایل‌ها و دایرکتوری‌ها، میتوانید یک ساختار سلسله مراتبی و تو در تو برای کدهایتان درست کنید که با کاراکتر backslash (\)  از هم جدا میشوند.
</p>

<pre><code class="language-php  line-numbers">&lt;?php
namespace MyProject1;

class Foo {
	public function Bar()
	{
		echo 'Bar method for MyProject1, Foo class. <br />';
	}
}
$objFoo1=new Foo;
$objFoo1-&gt;bar();

namespace MyProject2;

class Foo {
	public function Bar()
	{
		echo 'Bar method for MyProject2, Foo class. <br />';
	}
}
$objFoo2=new Foo;
$objFoo2-&gt;bar();
</code></pre>

<p>
در مثال بالا ما دو namespace در یک فایل PHP تعریف کردیم که اینکار امکان پذیر است، اما هرگز توصیه نمی‌شود و برای هر فایل بایستی یک namespace تعریف کرد.
</p>

<p>
نکته: اگر در یک فایل بخواهید از کد namespace شده و کد namespace نشده (Global code) استفاده کنید. باید از ساختار براکت شده مثل زیر استفاده کنید:
</p>

<pre><code class="language-php  line-numbers">&lt;?php
namespace MyProject { // MyProject namespace code
}

namespace { // global code
}
</code></pre>

<h3>
فراخوانی کدهای Namespace شده
</h3>

<p>
در فایل lib1.php، یک ثابت و یک تابع و یک کلاس تعریف کرده ایم و namespace آنرا App\Lib1 قرار داده ایم:
</p>

<pre><code class="language-php  line-numbers">&lt;?php
// application library 1
namespace App\Lib1;

const MYCONST = 'App\Lib1\MYCONST';

function MyFunction() {
	return __FUNCTION__;
}

class MyClass {
	static function WhoAmI() {
		return __METHOD__;
	}
}
</code></pre>

<p>
حال برای صدا زدن (call) کدهای بالا در فایل دیگر برای مثال فایل myapp.php یک روش استفاده از کدی مشابه کد زیر است:
</p>

<pre><code class="language-php  line-numbers">&lt;?php
header('Content-type: text/plain');
require_once('lib1.php');

echo \App\Lib1\MYCONST . "\n";
echo \App\Lib1\MyFunction() . "\n";
echo \App\Lib1\MyClass::WhoAmI() . "\n";
</code></pre>

<p>
بسیارخب، در کد myapp.php هیچ namespaceایی تعریف نشده، بنابراین در فضای global هستیم. از آنجاییکه MYCONST و MyFunction و MyClass در فضای نام App\Lib1 تعریف شده‌اند شما به طور مستقیم قادر به فراخوانی آنها نیستید و بایستی پیشوند \App\Lib1 را اضافه کنید تا یک نام fully-qualified داشته باشید. در نهایت خروجی زیر را خواهید داشت:
</p>

<pre><code class="language-php  line-numbers">&lt;?php
App\Lib1\MYCONST
App\Lib1\MyFunction
App\Lib1\MyClass::WhoAmI
</code></pre>

<p>
اما نام های fully-qualified خیلی طولانی هستند و مزیت زیادی نسبت به مثلا نامگذاری کلاس به صورت App-Lib1-MyClass ندارند.
قبل از اینکه بخواهید استفاده از namespaceها را یاد بگیرید مهم است که بدانید PHP چطور تشخیص میدهد که کدام بخش از کد namespace شده درخواست شده است. یک قیاس ساده بین namespaces در PHP و فایل سیستم می‌تواند مثال خوبی باشد.
</p>

<p>
در فایل سیستم 3 راه برای دسترسی به یک فایل داریم:
</p>

<p>
<ul>
<li>نام فایل به صورت نسبی (Relative) باشد مانند <span class="en-words">foo.txt</span>. که این مسیر به <span class="en-words">currentdirectory/foo.txt</span> تبدیل می‌شود که <span class="en-words">currentdirectory</span> همان دایرکتوری جاری است که در آن قرار داریم.</li>
<li>آدرس دهی نسبی مثل <span class="en-words">subdirectory/foo.txt</span> که به <span class="en-words">currentdirectory/subdirectory/foo.txt</span> تبدیل میشود.</li>
<li>آدرس دهی مطلق مانند <span class="en-words">main/foo.txt/</span>&nbsp;که تبدیل می‌شود&nbsp;به <span class="en-words">main/foo.txt/</span>&nbsp;(یعنی به خودش).</li>
</ul>
</p>

<p>
همین قاعده نیز برای عناصر namespace شده PHP کاربرد دارد. مثلا نام کلاس به سه روش زیر معرفی شده:
</p>

<div align="center">
<img src="/images/post/2_resolve_name-compressor.png" alt="مفهوم namespace  در PHP" />
</div>

<p>
1. Unqualified name یا نام کلاس بدون پیشوند مثل :
</p>

<pre><code class="language-php  line-numbers">$a = new foo();</code></pre>

<p>
یا
</p>

<pre><code class="language-php  line-numbers">foo::staticmethod();</code></pre>

<p>
اگر namespace جاری currentnamespace باشد، تبدیل می‌شود به currentnamespace\foo اگر هم بدون namespace باشد تبدیل می شود به foo.
</p>

<p>
نکته: وقتی علامت \ را قبل از نام تابع یا ثابت قرار بدهیم تابع یا ثابت global هدف قرار میگیرد.
</p>

<pre><code class="language-php  line-numbers">&lt;?php
namespace A\B\C;

function strlen($str)
{
	return 'ok';
}

echo strlen('hi'), "<br />"; // prints "ok"
echo \strlen('hi'), "<br />"; // prints "2"
</code></pre>

<p>
2. Qualified name یا نام کلاس همراه با پیشوند مثل :
</p>

<pre><code class="language-php  line-numbers">$a = new subnamespace\foo();
</code></pre>

<p>
یا
</p>

<pre><code class="language-php  line-numbers">subnamespace\foo::staticmethod();
</code></pre>

<p>
اگر namespace جاری currentnamespace باشد تبدیل به currentnamespace\subnamespace\foo می‌شود و اگر  بدون namespace باشد، subnamespace\foo اجرا می‌شود.
</p>

<p>
3. Fully qualified name یا نام پیشوند گذاری شده با پیشوند global \ مثل :
</p>

<pre><code class="language-php  line-numbers">new \currentnamespace\foo();
</code></pre>

<p>
یا
</p>

<pre><code class="language-php  line-numbers">\currentnamespace\foo::staticmethod();
</code></pre>

<p>
همیشه تبدیل می‌شود به همان نام مشخص شده یعنی خودش
</p>

<pre><code class="language-php  line-numbers">currentnamespace\foo
</code></pre>

  </div>
    
<hr>
<p>
<div>منابع مورد مطالعه جهت جمع آوری این مطلب:</div>
<div  class="refrencehref">
        http://aparnet.ir/3021-namespaces-in-php-part-1
</div>
</p>

  <hr>
  <style>
    #commentsdiv{
        background-color: #f5f5f5;
        border: 1px solid #c5c5c5;
        border-bottom: 0px !important;
        padding: 12px;
    }
    #commentsborder{
        background-color: #fff;
        border: 1px solid #c5c5c5;
        white-space: normal;
        padding: 20px;
    }
</style>

<div id="commentsdiv">نظرات</div>
<div id="commentsborder">
<div id="wpac-comment"></div>
</div>
<script type="text/javascript">
wpac_init = window.wpac_init || [];
wpac_init.push({widget: 'Comment', id: 7878});
(function() {
    if ('WIDGETPACK_LOADED' in window) return;
    WIDGETPACK_LOADED = true;
    var mc = document.createElement('script');
    mc.type = 'text/javascript';
    mc.async = true;
    mc.src = 'https://embed.widgetpack.com/widget.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
})();
</script>

</article>
<script src="/assets/js/anchor.min.js"></script>
<script>
    anchors.options = {
        placement: 'left',
        visible: 'always',
//        icon: '#',
    };
    anchors.add('.anchored h2,.anchored h3,.anchored h4,.anchored h5,.anchored h6');

    (function($){
        if(window.location.hash) {
            var hash = decodeURIComponent(window.location.hash);
            gotohash($(hash).offset().top);
        }
        $('a.anchorjs-link').click(function(){
			gotohash($(this).offset().top);
        });
        $('a.anchorjs').click(function(){
			var id = '#' + $(this).attr('title');
			gotohash($(id).offset().top);
        });		
        function gotohash(top){
            var headerHeight = 70; // Get fixed header height
            $('html,body').animate({
                scrollTop: top - headerHeight
            }, 20);
        }
    })(jQuery);
</script>





    <div id="back-to-top" role="button" aria-label="Back to top">
        <i class="fa fa-angle-double-up" aria-hidden="true"></i>
    </div>
</main>
<!-- footer -->

<footer class="footer" role="contentinfo" aria-label="Site footer">
    <div class="navigation" role="navigation" aria-label="Footer links">
        <a href="http://localhost:4000" class="avatar" role="link" ></a>
        <ul role="menubar" aria-label="Footer links menubar">
            <li class="footer-products" role="menuitem" aria-label="Products">
                تولیدات
                <ul role="menu" aria-hidden="true" aria-label="Products link">
                </ul>
            </li>
            <li class="footer-blog" role="menuitem" aria-label="Blog">
                مقالات
                <ul role="menu" aria-hidden="true" aria-label="Blog link">
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2020/07/03/marriage.html" role="link" aria-label="ازدواج">ازدواج</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2019/10/11/vuejs.html" role="link" aria-label="آموزش vuejs">آموزش vuejs</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2017/12/18/laravel.html" role="link" aria-label="آموزش Laravel">آموزش Laravel</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/articles/2017/12/13/laravelcollective.html" role="link" aria-label="معرفی Laravel Collective">معرفی Laravel Collective</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/2017/12/06/design-patterns.html" role="link" aria-label="معرفی  Design Pattern">معرفی  Design Pattern</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/blog" role="link" aria-label="Read more">Read More</a></li>
                </ul>
            </li>

            <li class="footer-connect" role="menuitem" aria-label="Connect">
                تماس
                <ul role="menu" aria-hidden="true" aria-label="Connect link">
                    <li role="listitem" aria-label="Connect link item"><a href="https://github.com/farhadmirzapour" target="_blank" role="link" aria-label="GitHub">GitHub</a></li>
                    <li role="listitem" aria-label="Connect link item"><a href="https://www.linkedin.com/in/farhad-mirzapour/" target="_blank" role="link" aria-label="Linkedin">Linkedin</a></li>
                    <li role="listitem" aria-label="Connect link item"><a href="https://twitter.com/farhadmirzapour" target="_blank" role="link" aria-label="Twitter">Twitter</a></li>
                </ul>
            </li>
        </ul>
    </div>
    <div class="socials"  role="navigation" aria-label="Social links">
        <ul role="menu" aria-hidden="true" aria-label="Social link">
            <li role="listitem" aria-label="Social link item"><a href="https://github.com/farhadmirzapour" target="_blank" role="link" aria-label="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a></li>
            <li role="listitem" aria-label="Social link item"><a href="https://twitter.com/farhadmirzapour" target="_blank" role="link" aria-label="Twitter"><i class="fa fa-twitter" aria-hidden="true"></i></a></li>
            <li role="listitem" aria-label="Social link item"><a href="https://www.linkedin.com/in/farhad-mirzapour-0043b862/" target="_blank" role="link" aria-label="Linkedin"><i class="fa fa-linkedin-square" aria-hidden="true"></i></a></li>
            <li role="listitem" aria-label="Social link item"><a href="/feed.xml" role="link" aria-label="RSS"><i class="fa fa-rss-square" aria-hidden="true"></i></a></li>
        </ul>
    </div>
    <div class="copyright" role="contentinfo" aria-label="Copyright">
        <p>&copy; <script type="text/javascript">document.write(new Date().getFullYear());</script> Farhad Mirzapour</p>
    </div>
</footer>

<!-- scripts -->
<script src="/assets/js/hamburger-menu.js"></script>

<script src="/assets/js/elevator.min.js"></script>
<script src="/assets/js/back-to-top.js"></script>
<script src="/assets/prisma/prism.js"></script>
<!-- google analytics -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-108878564-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-108878564-1');
</script>

</body>
</html>